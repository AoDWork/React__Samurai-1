    //============================================  React Samurai 1.0   ===========================================================
    
    /* После прохождения курса автор общает знания реакта для позиции солидного джуна, слудеющий курс 2.0 сделает нас солидным
                мидлом, но это уже после того как произойдет трудоустройство. Курс находится на ютубе по ссылке
                        https://courses.prometheus.org.ua/courses/course-v1:LITS+114+2022_T2/about                       */


    
{/*    ====    01. Как проходить курс     ====

    Изучаем react + Redux потому что это самая популярная связка для трудоустройства(на 2020 год).


    На верстку забиваем, вестаем - "абы було", в уроках изобретамем свой redux(24-41) потом изучаем обычный(42), также изобретам свой
        connect(43-44) в redux, потом смотрим редаксовский(45). Делается это для того что бы знать как все происходит внутри, не 
        абстрагируясь от сложных вещей JS.

        44 - просто ознакомиться что он есть, не записывая, держать в голове что connect работает через context API и забить.

        Начиная с connect - так как оно должно быть в продакшене.
    
        Взаимодействие с сервером бесплатное до какого то лимита. Что бы было безлим нужно кинуть копеечку автору. Решение некторых
            трудностей с запросами есть на сайте на который делаем запросы.

        53 - классовые компоненты. В 2020м стало возможно пользоваться хуками, но тогда еще на них все не перешли потому что прогеры
            очень инертны, также будем это учить потому что в Angular классовые компоненты и нужно это понимать.
        
        82 - селекторы не раскрыта полностью тема. Более лучше будет раскрыта в путь самурая 2.0.

        95 - делаем свой пейджинатор, а не используем готовый в учебных целях.


    Ведем конспект.


    Работаем в VSCode или Web Shtorme.


    Каждую неделю пересматриваем 100 урок, для визуализации полной картины что мы будем учить в целом и где находимся сейчас, а также
        для запоминания терминов.
     

    После прохождения курса обязательно идем на собеседования, 4 проваливаем на 5м устраиваемся на работу. После каждого собеседования
        составляем список вопросов на которые на смог ответить и учить их.
    
*/}


{/*    ====    02. Для чего Nodejs фронтенду     ====

    Изначально JS был создан для того чтобы выполнятся в браузере и делать какие то действия с хтмл + ксс, теперь оно так и осталось.


    Позже для работы с файловой системой компьютера и базами данных была создана программа Nodejs. Код для Nodejs также пишеться на
        JS передается в Nodejs и там выполняется(при выполнении в Nodejs код не имеет доступа к сайтам, а в браузере наоборот - 
        имеет доступ к сайтам но не может работать с файловой системой компьютера и программами). 

        И гугл хром и Nodejs используют движок V8, браузер дополняет V8 своими компонентами API(например хтмл элементы, ДОМ модель,
        события), а программа написаная для Nodejs взаимодействует с ОС(программы, девайсы(вебка, микрофон)), файловой системой, 
        базой данных. И браузер и Nodejs понимает, интерпретирует+ компилирует JS.

    
    Для чего Nodejs(программа, платформа в которой выполняетс JS код) нужен фронтенд разработчику: работа с файловой системой, 
        базой данных, Nodejs можно установить в микроконтроллер и написать код на JS чтобы например обслаживать холодильник(показ
        температуры, сигнал когда открыта дверь).

        Для удобства разработки(автоматизации процесса) - мы пишем код для браузера, потом готовим его для загрузки в браузер:
        компилируем (например из sass в css), бандлы создаем, склеиваем все JS файлы, минифицируем их, склеиваем картинки в спрайты.
        То есть перед отправкой программы в браузер мы делаем много дополнительных задач. Также для удобства разработки хотим чтобы
        не сохранять код постоянно, а в браузере делать оьновление страницы, а чтобы это было автоматически. Сегодня мы даже можем
        писать на другом языке который превращается в JS код и потом запускается в браузере(например в React пишем на языке JSX
        который должен превратиться в понятный браузеру язык). 
        
        Для того чтобы у всей комманды был одинаковый процесс всего этого нужно использовать сторонние программы(модули, пакеты)
        которые написаны для Nodejs(на JS) и выполняются в нем, и через его менеджер пакетов(npm) можно их загружать и 
        устанавливать(удалять). NPM - как каталог который контролирует какие модули у него уже есть. Потом можно настроить эти 
        модули так чтобы все выполнялось автоматически. А NPX - менеджер для запуска этих модулей. Получается что в рабочей папке
        кроме JS кода лежат еше програмки которые наш код в нужный момент времени преобразуют, минифицируют, компилируют, проверяют
        на ошибки и т.д.

        
    Серверным JS Nodejs называют потому что одной из программ которую можно написать для Nodejs это программа которая будет хендлить
        аштитипи запросы (handle HTTP request) - она принимает хттп запросы от клиента(браузер) формировать респонс(ответ) и
        возвращать ответ. То есть мы можем написать программу которая и будет програмным ХТТП сервером и будет работать внутри
        Nodejs. На сегодня это самая популярная задача для которой используется Nodejs.
 
*/}


{/*    ====    03. Установка Nodejs    ====

    Заходим на сайт Nodejs и скачиваем последнюю версию(ОС определяется автоматически). Устанавливаем. Проверим чтобы значек нода
        был в установленных программах.

    Лучше использовать английскую виндоус, ну в крайнем случае не называть рабочие папки на русском языке и с пробелами и не делать 
        в имени пользователя виндовс пробелов и писать тоже на английском языке. Вместо пробелов используем дефисы - . Точку в этих
        названиях тоже лучше не ставить, используем или дефис или нижнее подчеркивание.

*/}


{/*    ====    04. Create-react-app    ====

    Теперь будем устанавливать и запускать React приложение. 
    

    Реакт создали программеры из Фейсбука и его там используют. Загуглим Create-react-app - первая ссылка ведет на GitHub, перейдя
        туда видим что это некий проект. Все модули написанные под Nodejs лежат на GitHub имеют открытый код и под той или иной
        лицензией могут использоваться для своих нужд.

    Create-react-app - это такая же программа.  С помощью NPX(надстройка над npm) мы ее запустим и эта программа установит в нашу
        рабочую папку кучу всего, потянет за собой кучу пакетов, всё настроит, подготовит, а нам останется только запустить.


        
    Ниже на GitHub этого проекта Create-react-app есть инструкция - Quick Overview. Есть 3 комманды которые нужно написать в 
        Node.js command prompt - это консольная программка(найти ее можно через поиск в пуске, она установилась вместе с Nodejs).


        Запускаем эту консольную программу, по умолчанию у автора она открылась по пути C:\Users\notePad.by, поэтому нужно перейти
        в папку где у нас будет проект например D:\React-Samurai\Project-1. Сначала выберем нужный диск где лежит папка с проектом, 
        для этого просто напишем D: и нажмем ентер, нас кинет на диск Д. Потом нужно прописать cd - change directory, а дальше 
        остальной путь к папке cd React-Samurai\Project-1 - жмем ентер и перешли в рабочую папку в этом консольном окне(при вводе
        названия папки можно нажимать tab и если такая папка есть в этой директории допишет полное ее имя, или можно просто
        скопировать путь из папки в виндовсе и вставить в консоль; чтобы подняться на папку выше cd .. (cd и двоеточие через пробел))

        Написать следующие строки можно и в терминале VScode. Открыв как open folder - рабочую папку Project-1, и перейдя в нее
        способом выше(если по умолчанию не перешло) в терминале VScode(сверху вкладка New terminal чтобы его открыть).



    Теперь находясь в консоли в рабочей папке проекта пишем эти консольные команды:

        npx create-react-app my-app  (my-app - название проекта, можно писать своё) - так как мы пишем npx то кроме установки
                                        всех необъодимых модулей произойдет еще и их настройка. Жмем ентер. 
                                        
        Создается папка с названием проекта в данном случае my-app и в нее будет происходить загрузка модулей. В файле
        package.json - храниться информация об этой папке проекта как о проекте(модуле, таком же как мы устанавливаем), чтобы
        можно было его запустить в Nodejs.

        Появилась папка node_modules - каждый проект который мы устанавливаем через npm содержит такую папку, в нее сохраняются
        все пакеты(модули которые нужны нам для работы react-app)


        Установка завершилась. Видим комманды которые можно написать в середине директории(папки) my-app:
            npm start       - starts the development server

            npm run build   - bundle the app into static files for production

            npm test        - starts the test runner

            npm run eject   - removes this tool and copies build dependencies, configuration files and scripts into the app
                                directory. If you do this, you can't go back.

            
        Рекомендуют начать с перехода в папку проекта(пакета/модуля потому что для запуска нужен файл package.json) и запуска его
        через нпм:
            cd my-app
            npm start

        Видим что нпм запустил локальный сервер(он умеет принимать хттп запросы и отправлять на них респонсы), он будет отдавать нам
            наш index.html и именно в нем будет вестись наша разработка сингл пейдж аппликейшена (single page application - spa)

*/}


{/*    ====    05. Single page application - spa    ====

    Spa - одностраничное приложение.


    Очень давно жизненный цикл страницы бал такой. Traditional Page Lifecycle. Например для личных сообщений.
    При заходе на страницу бразер посылал запрос серверу(Initial request), и он в ответ присылал хтмл файл. Потом когда мы обновляли
        сайт чтобы посмотреть появилось ли например новое сообщение на форуме, браузер делал снова запрос(Form POST) - и сервер снова
        присылал этот же хтмл полностью если там не было изменений или совсем немного измененный если там были какие-то изменения, а
        браузер перезагружал полсностью страницу чтобы получить свежую версию хтмл.

                        Initial request
                        ------------------------->

                        <------HTML----JS---------
            CLIENT      Form POST                     SERVER
                        ------------------------->

            reload       <------HTML---------------


        При этом пакет ХТМЛ был большой, а следом за ним шел файл с JS очень небольшой. Сообщения раньше были сгенерированы(зашиты)
        уже в ХТМЛ как теги.

    
    Spa - загружают страницу единожды. Файл ХТМЛ приходит почти пустой, а следом большой файл JS который уже отрисовывает весь сайт.
        
                        Initial request
                        ------------------------->

                        <------HTML----JS---------
            CLIENT      AJAX                          SERVER
                        ------------------------->

                        <------JSON---------------

        Теперь сообщения могут храниться или в файле JS(очень редко), но чаще всего после получения этих файлов браузер делает
        Ajax запрос на сервер, а тот возвращает json данные(все сообщения которые есть), а JS который ранее загрузился в браузер
        берет эти данные и без перезагрузки страницы генерирует на ходу ХТМЛ. При этом для того чтобы посмотреть есть ли новые
        сообщения не нужно перезагружать страницу, а в JS есть код который время от времени опрашивает сервер и если появилось
        новое сообщение, то присылается это одно сообщение(JSON файл с сообщениями???) и под это новое сообщение на сайте 
        генерируется новый хтмл тег. При таком подходе очень разгружается сервер, экономиться много траффика, ускоряется работа
        сайта.

        При Traditional Page Lifecycle для каждой страницы, например настройки или новостная лента или моя стена, для каждой такой
        страницы был отдельный адресс и по этому адресу загружалась хтмл страница. В Spa - всегда одна страница, не нужно путать с
        лендингом, в spa мало ХТМЛ(полупустой файл) + много JS скрипта который создает динамически нужную разметку, в том числе
        не только когда мы находимся на одной странице(например - сообщения) но и когда мы кликаем на ссылку перехода на другую
        страницу этого же сайта, адрес url меняется, но фактически на сервер не идет запрос на новый хтмл, а JS перехватывает
        изменение этого url делает нужный ajax запрос на сервак - для отображения новой страницы, возвращается json и наш JS
        вытирает(удаляет) страницу "сообщения" (хтмл контент) и рисует контент для новой страницы. Если некоторые элементы на
        этих страницах одинаковые, например хедер, футер, aside то они не перерисовываются. React, angular работают по этой же
        схеме. Получается что страница генерируется на стороне клиента, разгружая сервер, и сервер по сути выступает теперь в роли
        API(эй пи ай).

        При старом формате когда сервер работал с веб страницей он работал только с ХТМЛ, а теперь когда он работает со spa, а 
        это уже как полноценная программа - веб приложение с большим кодом логики, для которого теперь нужно с основном json файлы.
        Так как json формат универсальный то при запросе таких данных сервер может отдавать json как в веб приложение(spa) так и
        в мобильное приложение, хотя там другой UI(user interface - ю ай), просто по другому эти данные обрабатываются и по другому 
        рисуется интерфейс, при этом сервер становиться универсальным.

*/}


{/*    ====    06. Index.js, app, JSX    ====

    Продолжаем с конца 4го урока, после запуска реакт-апп набором этих комманд в терминале по пути рабочей папки(где создалась папка
        с проектом my-app):

        cd my-app
        npm start

        Запустился локальный сервер и открыл страничку проекта в браузере. Так как мы пока ничего не меняли то по умолчанию 
        показывается страница приветствия(та самая spa страница) с крутящимся логотипом реакта.


    
    Рассмотрим какие файлы есть в папке проекта, что нам можно изменять чтобы изменялась страница. 
        
        package.json. Папка my-app считается проектом (модулем/пакетом) когда в ней присутствует package.json.

        Папка node_modules обязательно должна быть загружена до запуске проекта. npm анализирует содержимое package.json и загружает
        необходимые для работы модули в папку node_modules. Эту папку вручную не изменяем никогда. Позже посмотрим что в нейл лежит,
        а пока забываем про нее.

        Папка public. В этой папке лежит иконка реакта для приветственной страницы. Index.html - та самая хтмл(spa)Ю которая 
        единственная существует в нашем проекте(видим что файл практичеси пустой). manifest.json.

        Папка src. На приветственной странице видим текст - Edit src/App.js and save to reload(отредактируйте файл App.js в папке
        src и сохраните для перезагрузки страницы). Смотрим что лежит в папке src: App.css, App.js, App.test.js, index.css, 
        index.js, logo.svg. 



    Заходим в App.js и видим что тут есть разметка которая и отображается сейчас на странице. Попробуем изменить текст сообщения
        например слово Edit поменять на my-app, сохраняем файл, видим что в браузере мигнула страница - видим что текст изменился
        и нам не пришлось обновлять страницу в ручную.


        Но постойте, мы редактируем хтмл теги в JS файле и этот хтмл код даже не взят в кавычки, как так. Видим что разметка эта
        находится в 

            class App extends Component { render(){ return(хтмл разметка); } } 
            
            - в следующих видео разберем что такое класс и екстендс, а сейчас разберем что происходит.


        Разработчики реакта создали язык JSX который позволяет писать хтмл внутри джаваскрипта. По факту этот хтмл это джаваскрипт,
        просто на таком синтаксисе привычнее писать человеку, а для работы в браузере этот синтаксис JSX перекомпилируется в JS. 


        Упростим разметку: 
            удалим все содержимое хтмл разметки кроме родительского дива с className="App"
            удалим строку import logo from './logo.svg';
            предполагая что мы не знаем что такое класс - заменим код на такой:

                const App = () => {  return(<divclassName="App">Simple HTML</div>); } 

                создадим переменную App и присвоим ей стрелочную ф-ю которая возвращает хтмл разметку. Автор рекомендует почитать 
                про ключевые слова создания переменных var, let, const и стрелочные ф-и, потому что тут он подробно останавливаться
                на этом не будет.


        Сохраняем файл и видим что теперь страница у нас с белым фоном(потому что слетели ксс стили так как мы удалили почти
            всю разметку) по центру(потому что стили для контейнера работают, а он был отцентрирован по центру) сверху видим надпись
            из нашего дива в разметке - Simple HTML.

        То есть содержимое файла апп.дс попадает внутрь страницы которую мы видим - разберем в следующих видео.


        Снова модифицируем код, добавим список, но забудем добавить закрывающий тег:
            
            <ul>
                <li>Some text
            </ul>

            Наш редактор кода подчеркивает красными всю разметку, и после сохранения кода, в браузере вместо страницы отобразится
            ошибка Failed to compile  - ошибка компилирования и пишет на такой то строке ожидает закрывающий тег <li>. Так 
            получается потому что это не хтмл разметка по сути(если мы в хтмл забудем закрывающий тег то браузер все равно попробует
            отобразить страницу, добавив тег за нас), а это код JS который выполнить возможно потому что он не валидный, и компилятор
            нам выдает ошибку потому что не может преобразовать наш код в JS код.


        Обратим внимание что вместо class в тегах хтмл мы пишем className по той причине что слово класс в JS коде в который будет
            преобразован этот код зарезервировано за классами.


        Допишем наш список:

            <ul>
                <li>HTML</li>
                <li>CSS</li>
                <li>JS</li>
                <li>React</li>
            </ul>

            видим что он отобразился на странице, но нам хотелось бы задать внешний вид. Смотрим в начало апп.дж файла и там есть
            строки начинающиеся с import и одна строка содержит: 

            import './App.css';

            этот файл лежит в той же папке что и наш файл - ./ и называется App.css и мы его ипортируем(добавляем в апп.дс ). 
            Зайдем в  App.css и видим стили которые были написаны для привественной страницы, удалим все эти стили и пропишем стили
            для нашего списка:

            ul li { list-style-type: georgian; }

            видим что внешний вид списка изменился(сместился влево и точку заменились на символы georgian).


        То есть сама концепция тут другая, мы работаем не в хтмл и туда добавляем ксс и JS файлы, а работаем в JS и туда импортируем
            ксс файл.


        В разметке всегда должен быть ОДИН корневой(родительский) элемент(див), а все остальное мы помещаем внутрь него.(в видео
            добавили еще див выше нашего с классНейм - апп - получилась ошибка, потом эти два дива обернули еще в тег див без
            дополнительных аттрибутов и всё заработало, то есть не обязательно что бы див с классом апп был родительским для всей
            разметки).

*/}


{/*    ====    07. Компонент    ====

    Если в кратце Компонент - это ф-я возвращающая разметку JSX( может работать и выполнять разный код, но по итогу return(ретурном)
        все равно должна вернуть разметку JSX).

    В нашем апп.дс const App и есть эта компонент, потому что ей присвоена ф-я которая возвращает разметку JSX.


    Примеры ф-й 

        function Welcome() {                - ф-я объявлена через ключевое слово function
            return <h1>Hello, there</h1>;
        }

        const Welcome = function () {       - анонимная(без названия) ф-я объявлена через function присвоенная переменной
            return <h1>Hello, there</h1>;
        }

        const Welcome = () => {             - стрелочная ф-я присвоенная переменной
            return <h1>Hello, there</h1>;
        }


        Если код находится на строке return то скобки можно не ставить: 
        
        return <h1>Hello, there</h1>;

        Если не на строке с return то нужно ставить скобки, но лучше по умолчанию ставить скобки:

        return(
            <h1>Hello, there</h1>;
            );


    Чтобы использовать ф-ю в обычном JS ее нужно вызвать (дальше по коду) - Welcome();.

    В реакте при создании ф-ии у нас появляется новый тег - в данном случае который можно вставить куда то на страницу,
        а реакт сам ее вызовет.

         <Welcome />
        

    То есть теперь компонент получается - тег.

    
    Посмотрим наш пример, тут у нас есть const App найдем куда вставляется созданный тег этой ф-ии. В вскоде нажимаем ctrl+shift+F
        это поиск во всех файлах проекта и вбиваем в поиск <App нашло 2 результата App.test.js(этот файл не смотрим) и index.js.
        
        Помним что главный файл хтмл называется index.html и он у нас лежит в папке public, откроем его и видим что в body есть
        пустой div с id="root". Как раз внутри этого тега и будет отрисовываться всё то что мы пишем на реакте.

        Откроем index.js. Видим что тоже есть много import строк, а далее видим ф-ю(обїект???) ReactDOM у которой есть метод render.
            render(переводится - отрисовать), этот метод отрисовывает созданный в App.js тег <App />. И отрисовывается он в елементе
            который мы находим по айди Root - document.getElementById('root').

            ReactDOM.render(<App />, document.getElementById('root'));



    Для закрепления создадим еще одну компоненту.

        const Header = () => {
            return (
                <div>
                    <a>Home</a>
                    <a>News</a>
                    <a>Messages</a>
                </div>
            );
        }
        
        Она в коде есть но на странице не видна потому что не вызывалась и не была вставлена в хтмл. Что бы пока не заморачиваться
            с import вставим компоненту Header в хтмл разметку компоненты App:

            <div><Header /></div>

            теперь когда рисуется App компонент в ее хтмл коде встречается компонент Header и идет обращение к этой компоненте
            (вызывается ф-я Header она возвращает свою разметку которую отрисовывает в разметке App вместо тега <Header />)

            <div>
                <div><Header /></div>
                <div className="App">
                    <ul>
                        <li>HTML</li>
                        <li>CSS</li>
                        <li>JS</li>
                        <li>React</li>
                    </ul>
                </div>
            </div>


        Выглядит както не логично, у нас есть Header. а потом пошли какие-то liшки. Вынесем весь код для списка в отдельную 
            компоненту Technologies и просто поместим ее в компоненту App которая будет все отрисовывать. Удалим класснейм потому 
            что он нам не нужен, он нужен был для стилей которые были в приветственной странице. Также удалим дивы вокруг хедера так 
            как можно и без них - они лишние.

            const App = () => {
                return (
                    <div>
                        <Header />
                        <Technologies />
                    </div>
                );
            }

            const Header = () => {
                return (
                    <div>
                        <a>Home</a>
                        <a>News</a>
                        <a>Messages</a>
                    </div>
                );
            }

            const Technologies = () => {
                return (
                    <div>
                        <ul>
                            <li>HTML</li>
                            <li>CSS</li>
                            <li>JS</li>
                            <li>React</li>
                        </ul>
                    </div>
                );
            }

            Теперь наш компонент App которая отрисовывается состоит из двух компонент которые мы подключили тегами в нее. Код стал
            более читабельным, осмысленным(логическим) и семантически правильным.

*/}


{/*    ====    08. Import, export - теория    ====

    Так как компонентов будет очень много, и они могут в себе содержать еще компоненты, то мы их разобьем на разные файлы для лучшей
        читабельности. Но для того чтобы оно потом работало вместе нужно

    ПРИМЕР.
    Есть 4 файла
        main.js     - одна ф-я которая вызывается - openAllMaps();
        maps.js     - let openAllMaps = ()=>{openGoogle(); openYandex();}
        google.js   - подключается к гугл карте и показывает ее. В ней одна ф-я(компонент) - openGoogle
        yandex.js   - подключается к яндекс карте и показывает ее. В ней одна ф-я(компонент) - openYandex


        Автор утверждает что создав таким образом глобальные переменные в JS коде, они будут видны в других файлах(если так как
            сейчас написано - нет не будут, разве что будут експортированы) и поэтому при работе с ними могут возникнуть проблемы,
            например если две переменные с одинаковым именем то одна может затереть другую и будет использована только одна.


            Реакт же использует модульность(модульный подход) - все const, let которые объявлены в одном фале, остаются видимы 
            только в этом файле, что позволяет избежать таких проблем. Для связи таких файлов используем import. Например сделаем
            импорт в файле main.js ф-и openGoogle из google.js по относительному пути к файлу в который испортируем.

            import openGoogle from './google.js';  - этот файл лежит в той же папке где и файл в который импортируем(./) 
            import openYandex from './../yandex.js'; - этот файл лежит на уровень вложенности выше(../)
            

            А в main.js теперь нужно импортировать openAllMaps из maps.js.

            import openAllMaps from './maps';     - расширение файла можно не указывать


            Чтобы import работал нужно в файле который отдает компоненту ее экспортировать - export. То есть в файле google.js:

            export default openGoogle;


            Есть несколько видов импорта/экспорта мы пока будем работать с таким. Когда мы делаем экспорт по дефолту(default) мы
            из файла можем экспортировать что то одно.
            
        // *! Рекомендует прочитать про модуль амд - modules AMD require.js после просмотра этого видео или перед собеседованием.



    Посмотрим на наш файл App.js. Видим что есть:
    
        import './App.css'; - испортируются стили из ксс файла, поэтому нету from

        import React, { Component } from 'react';  - тут видим что испорт идет не из файла, а из модуля реакт который лежит в 
                                                    папке node_modules поэтому нету пути к файлу.


    Смотрим в index.js , тут мы отрисовываем компоненту апп, но она в другом файле, значите ее нужно импортировать:

        import App from './App';

*/}


{/*    ====    09. Import, export наших компонент    ====

    Создаем файлы для Header Technologies и переносим туда код по принадлежности, в этих файлах прописываем:

        export default Header/Technologies


    а в App.js пропишем импорты:

        import Header from './Header.js';
        import Technologies from './Technologies.js';


    Сохраняем. Запускаем проект и нам выкидывает ошибку 'React' must be in scope when using JSX, что означает что в новых файлах для
        того чтобы использовать JSX(наша верстка в компонентах) нужно импортировать реакт в эти файлы.

        import React from 'react';  - (, { Component } - это мы удалили потому что class не используем, а используем ф-ю компоненту).

*/}


{/*    ====    10. Default опасность, плагин auto import    ====

    В Апп.дс закомментируем строку ипорта Header и сам тег Header в хтмл разметке. Смотрим на сайт - хедер пропал, показывается
        только Technologies.


    Теперь в import Technologies заменим файл из которого импортируется на Header.
    
        import Technologies from './Header.js';

        Смотрим на сайт, а вместо наших технологий отрисовывается Header хотя мы импортировали Technologies, такое поведение
        получается из-за дефолта(default) - при этом нету привязки к конкретному имени экспорта, и при импорте то что экспортировали
        называется как записано в импорте, но так как мы все равно будем его использовать нужно быть очень внимательными при
        импорте.



    При импорте будет использовано очень много файлов и у них могут быть сложные пути, чтобы нам облегчить этот процесс можно 
        поставить в VSCode плагин - "Auto Import", после установки нужно нажать кнопку для перезагрузки VSCode. Он работает не
        так круто как в Web Storm, но теперь когда мы начинаем писать тег с компонентой которую нужно импортировать, высвечивается
        подсказка - Auto Import - клацнув по ней в верхней части кода добавляется импорт этой компоненты из файла. 

        Сначала плагин может не работать, нужно или время для скана или создать в новом файле новую компоненту и тогда запустится
        скан, и плагин будет работать. Но нужно все равно проверять из какого файла идет импорт.

*/}


{/*    ====    11. Соц. сеть. Шаг 1(вёрстка, grid)     ====

    Все компоненты нужно называть с большой буквы чтобы измежать совпадений с названиями тегов ХТМЛ.


    Начнем с верстки макета, у нас будет 3 блока Хедер, боковая меню, и контент справа от сайдбара под хедером.

    Верстать будем на grid(только появившемся на то время). Так как автор сам учил в видео гриды он решил начать делать проект в
        одном файле.  В главный див накидаем теги которые будут отвечать за секции, а потом их уже заполним.

        return (
            <div>
                <header><img src="https://th.bing.com/th/id/OIP.PBVmERenoA81uh26kHU04QHaHa?pid=ImgDet&rs=1" /></header>
                <nav>Menu navigation</nav>
                <main>Main Content</main>
            </div>
        );

        Видим что появился большой логотип и надписи Menu navigation и Main Content все располагается одно под одним потому что
        элементы блочные.

    Для родительского эл. задаим класс app-wrapper, также добави классы для всех элементов.

        return (
            <div className="app-wrapper">
                <header className="header"><img src="https://th.bing.com/th/id/OIP.PBVmERenoA81uh26kHU04QHaHa?pid=ImgDet&rs=1" /></header>
                <nav classname="nav">Menu navigation</nav>
                <main className="content">Main Content</main>
            </div>
        );

        теперь можем обратиться к ним из ксс файла и задать ксс свойства. Для app-wrapper задать display: grid; и количество колонок,
        а для элементов размеры и имена для грид эреа темплейт.

        .app-wrapper{
            display: grid;

            grid-template-areas: 
            "header header"
            "nav content";
            
            grid-template-columns: 2fr 10fr;
            grid-template-rows: 60px 1fr;

        }

        .header{
            grid-area: header;
            background: rgb(1, 30, 37);
        }

        .header img{
            max-width: 50px;
        }

        .nav {
            grid-area: nav;
            background: rgb(252, 13, 13);
        }

        .content{
            grid-area: content;
            background: rgb(19, 72, 218);
        }


    Добавим меню в сайдбар.

        <nav className="nav">
          <ul>
            <li><a href="#">Profile</a></li>
            <li><a href="#">Messages</a></li>
            <li><a href="#">News</a></li>
            <li><a href="#">Music</a></li>
            <li><a href="#">Settings</a></li>
          </ul>
        </nav>
        
    
    В контенте у нас должна быть хедер картинка на всю ширину, ниже аватарка, справа от аватарки данные пользователя(имя, данные),
        ниже будет блок - надпись My Posts + ниже поле для ввода, а еще ниже будут сообщения. Grid использовали для общего макета
        сайта, для расстановки элементов в content будем пользоваться другими технологиями например flexbox. Автор каждый блок 
        оборачивает в div чтобы обозначить блоки которые будут, и не заморачиваться с версткой. Пока оставили схематическую верстку
        без причёсывания в ксс.


    // todo изучить grid потому что мы хотим не просто владеть инструментом реакт, а быть трендовыми фронтенд разрабочиками.
    //*! Красивые дизайны для верстки на themeforest.net social template

*/}


{/*    ====    12. Соц. сеть. Шаг 2(разбивка на компоненты)     ====

    Разобьем проект на компоненты и выделим подкомпоненты. Создадим для них папку components в папке src. 
    
    Для хедера создаем файл Header.jsx - такое расширение чтобы сразу было видно что это компонент, а не просто JS сервис, файл или
        логика. Прописываем import React from 'react'; далее создаем наш компонент - ф-ю Header и помещаем туда верстку для хедера 
        из файла Апп. Прописываем export default Header;. А в файле Апп вместо разметки хедера ставим тег <Header /> (сейчас тег 
        выглядит так { Header() } ), и прописываем - import Header from './components/Header'

    Тоже самое делаем с Navbara.

    Так как у нас страницы контента будут разные: Profile, Messages, News, Music, под каждую файл назовем соответствующе, потому
        что разметка у них будет отличаться. Та разметка которая у нас есть сейчас будет относиться к Profile. Так и назовем файл и
        компонент в нем.

*/}


{/*    ====    13. Git-репозиторий     ====

    Автор создал репозиторий на гитхабе, можно его клонировать себе. Для этого в папку куда будем клонировать, открываем для нее 
        терминал умтановленного гита(git Bash here - выбираем из списка после клика правой кнопкой в папке куда будем клонировать
        репозиторий), и в нем пишем git clone address(вместо адресса вставляем хттпс адресс к репозиторию) После клонирования у нас
        отсутствует папка с модулями, потому что он большая и заливать ее на гитхаб не стоит(будет долго обновляться проект как 
        минимум), она прописана в файле гитигнор чтобы когда у нас будет папка с модулями она не отправилась на заливку. 

    Так как мы смотрим уже когда в репозитории весь проект готов, нужно откатиться на предыдущую версию соответствующую коду в
        конкретном уроке. Это можно сделать открыв в папке проекта git Bash here терминал(консоль) и пишем комманду
        gitk --all&   жмем ентер, открывается графический интерфейсВ котором есть коммиты с номерами уроков. Чтобы откатится к
        определенному коммиту нужно на него кликнуть и под окном с коммитом отобразиться для него код SHA ID, его копируем при
        помощи ctr + insert(ctrl+C - не работает), возвращаемся в консоль и пишем git checkout copied_ID(вместо copied_ID надо
        при помощи shift + insert, вставить скопированный айди) - жмем ентер. 
        
        Может выскочить ошибка если уже немного поигралис репозиторием на счет того что сделанные изменения нужно или закоммитить 
        или удалить. Автор предлагает удалить файл package-lock потом повторно ввести комманду и мы ереключимся на нужный коммит. 
        Ни в коем случае не нужно трогать код, просто смотреть его, а то будут проблемы при переключении на следующие коммиты. 
        Если всетаки мы сделали какие то изменения нужно их удалить пишем git status - красным покажется в каком файл изменения
        далее пишем git checkout src/App.js( git checkout + путь к измененному файлу), изменения удаляться и можно снова прыгать
        по коммитам. 

    Откроем склонированную папку проекта в ВСкоде, запустим терминал и если прописать npm start то проект не стартанет так как нету
        модулей. Что бы их установить пропишем npm install при этом npm  посмотрив в package.json какие модули нужно установить для
        данного проекта и установит их автоматически в папку node_modules.

    Если мы будем устанавливать дополнительные модули, то чтобы они у нас потом тоже автоматически подгружались нужно после их
        установки делать save(npm i module.name -save ), при этом в package.json добавиться зависимость для этого модуля.

*/}


{/*    ====    14. Css modules     ====

    Мы должны знать БЭМ методологию, хотя бы основные понятия, потому что будем придерживаться похожей концепции, но реализовывать
        будем не самостоятельно, а это будет автоматически делать Create React app.

    К картинке лого мы обращались в ксс файле через вложенность .header img{ , если так не сделать то стили для просто img{ 
        применятся ко всем картинкам на проекте. Если бы мы делали по БЭМ нам нужно было бы написать класс .header__img{ и его
        прцепить к картинке, в этом тоже есть свой недостаток, нужно лезть в верстку того элемента и прописывать там классНейм.
        А нам хочется чтобы названия классов были какими то простыми, чтобы не писать длинные классы и модули позволяют нам этого
        добиться.

    Рассмотрим на примере Навбара, присвоим каждой лишке класс item, это короткое название для класса, но оно может часто 
        встречаться в проекте и нам бы хотелось чтобы мы об этом не думали и поэтому также как мы разнесли код JS по файлам
        также разнесем и ксс код по своим файлам с такими же названиями в папке src.
            
        <ul>
            <li className="item"><a href="#">Profile</a></li>
            <li className="item"><a href="#">Messages</a></li>
            <li className="item"><a href="#">News</a></li>
            <li className="item"><a href="#">Music</a></li>
            <li className="item"><a href="#">Settings</a></li>
        </ul>

        В каждый файл компонент jsx теперь пропишем импорт соответственного файла ксс, например в Header.jsx пропишем 
            import './Header.css' .


    Для постов допусти тоже задали класс айтем  

        <div className="item">
            Post 1
        </div>
        <div className="item">
            Post 2
        </div>

        в ксс навбар присвоим айтемам навбара цвет черный и видим что item в Portfolio тоже сменили цвет на черный

        .item{
            color: black;
        }

    Почему так происходит, загляним во вкладку Network(сеть) панели разработчиков, у автора там нету никаких ксс файлов(у меня есть
        так как я подключал в файле индекс.хтмл эти все ксс файлы) но есть такой файл как bundle.js - это тот файл в который
        превращаются(собираются) все наши jsx файлы и Апп.дс тоже. Все ксс файлы которые импортируются таким образом добавляются
        через JS код в head index.html файла и они получаются все равно связаны и становятся глобальными, тоесть нету инкапсуляции.
        
        Инкапсуляции можно достичь добавили module в название файла ксс, тоесть Navbar.module.css , теперь этот файл ведет себя 
        иначе, и работать с ним нам надо иначе, теперь импорт будет выглядеть таким образом

            import classes from './Navbar.module.css';  (classes - можно называть как нравиться)

        верстка сломалась, смотрим в head документа и видим что теперь вместо item у нас есть Navbar_item__3qaF3 и если мы в верстке
        заменим item на Navbar_item__3qaF3 то стили к нему применятся. Но это еще более неудобно, и что бы так не делать мы будем
        работать с импортируемым ОБЪЕКТОМ classes. У него есть свойства "ключ" : "значение" - ключи будут - названия стилей которые
        мы писали в ксс файле, тоесть классы - .nav, .item, только без точки, а значением будет как раз автоматически сгенерированые
        классы - Navbar_item__3qaF3. И теперь в разметку нужно присваивать объект:

            <div className={classes.nav}


    Для глобальных классов например для body мы App.css в модуль НЕ превращаем. Можно оставить и для других файлов ксс обычные
        стили если нам не трудно придумывать уникальные имена для тегов. Если внутри модульного ксс будет вложенность .header img{
        то программа header переделает в новый нужный тег и сохранит путь к этой картинке таким образом. Медиазапросы тоже
        подхватываются.


    При такой модульности не стоит называть классы через дефис item-nav, из-за допустимых названий свойств объекта в  JS, потому что
        тогда к ним нужно обращаться прописывая кавычки и квадратные скобки, а это не удобно. Лучше слитно, или камел кейсом, 
        или через нижнее подчеркивание.

        <div className={classes["item-nav"]}

    
    //*!Если хотим дать тегу два класса например <div className="item active" мы бы в ксс написали если у тега два класса тогда 
        цвет будет золотой и цвет активной ссылки был бы золотым  -  .item .active{color:gold;}.  А теперь часть этой строки с 
        классами у нас сидит в значении свойства объекта, то теперь нам нужно использовать бектики для вставки в строку двух 
        значений свойств объекта, а свойство active - появиться в объекте потому что в реакт прочитает модульный ксс и увидит что
        в записи .item .active{ - два класса и оба их добавит.

        <div className="item active"

        <div className={`${classes.item} ${classes.active}`}
        // ** или можно еще так {s.dialog + ' ' + s.active}


    Чтобы увидеть что лежит в объекте можно его вывести в консоль в том же файле jsx куда он импортируется.


    Если нам нужны будут стили для общих элементов мы рассмотрим это в следующих видео.

    //! При работе в окружении реакта имена классов автоматически переделывались в ВебШторме при импорте например:
        content-header - в jsx файле нужно изменять на contentHeader в файле модуля, потому что тире нельзя использовать.

*/}


{/*    ====    15. Структура папок, новые компоненты, улучшаем css     ====

    Компонентов в проекте будет очень много и если будем их складывать все просто в папку components то очень быстро будет трудно 
        искать нужные файлы, поэтому структурируем файлы. Если у нас есть несколько файлов относящихся к какому то компоненту то
        делаем папку с названием этих компонентов и складывает туда файлы. Например в папке components делаем папку Header и туда
        складываем Header.jsx + Header.module.css , при этом конечно ломаются пути импорта и нужно будет их обновить. При
        перетаскивании в ВСкоде файлов в новые папки, он предлагает обновить импорты (хотя может это делает плагин move TS или 
        сами модули Реакта).


    Теперь нужно поработать с компонентом Profile, разбить его на подкомпоненты создадим компонент My Posts и для него компонент
        post который будет отвечать за один пост(сообщение). Для этого в Profile создаем папку My Posts а в ней папку Post. 
        
        В My Posts скопируем файлы Profilе.jsx и Profile.module.css и переименуем их в MyPosts.jsx и MyPosts.module.css. 
        
        В MyPosts.jsx переназначим импорт для  MyPosts.module.css и сменим название компонента на MyPosts и удаляем все теги до тегов
        с постами, также переназовем экспорт под название компонента. 
        
        В MyPosts.module.css оставляем только класс item потому что класс content относится к вышестоящей разметке которой в 
        MyPosts.jsx нету. 
        
        А из Profile.module.css наоборот удалим item. А из Profilе.jsx удалим разметку с постами и добавим на ее место тег 
        компонента <MyPosts /> и соответственно нужно  проконтролировать добавление import на этот компонент.


    В разметке MyPosts.jsx видим что дивы с постами выглядят одинаково но с разным текстом, так что можно вынести в отдельный 
        комопнент. Предварительно добавим еще картинку пользователя написавшего пост <img>, этот аватар будет у каждого поста, для 
        него нужно будет писать класс, а там еще добавяться кнопки лайк/дизлайк и в итоге когда постов будет много это будет
        огромная работа по копированию. Чтобы такого избежать мы и выносим общий вид(разметку) поста в отдельный компонент, он
        будет строиться по общим правилам но изменять свои свойства типа текста и аватара пользователя.

        Снова переносим более глобальный(полный) компонент MyPosts в дочернюю папку Post, изменяем файлам соответсвенно названия.
    
        В  Post.jsx изменяем импорт под ксс модуль, название компонента и удаляем лишнюю разметку - оставляем 1 пост, меняем название
        экспорта.

        В MyPosts.module.css удаляем стили для класса item и всё что связано с тегом пост.

        В MyPosts.jsx - удаляем верстку с постами и добавим несколько тегами <Post />, также смотрим чтобы был импорт из Post

    
    Теперь можем менять внешний вид всех постов сразу работая в одном файле.


    Но текст у постов одинаковый, а должен быть разный текст который изменялся бы от принятых данных. Это мы рассмотрим в следующих
        уроках.

*/}


{/*    ====    16. Props     ====

    Нужно настроить наш компонент Post так чтобы он отображал свой текст для каждого поста для этого нужно использовать props.

    Каждый компонент(ф-я) может принимать параметры чтобы потом с ними работать внутри себя, и главный параметр у нас будет 
        ОБЪЕКТ - props, название можно придумать другое, но по соглашению в реакте используют именно props. Реакт когда вызывает
        компонент всегда передает в параметр этот объект.

        const Header = (props) => {
            return(
                <...>
                <...>
                <...>
                );
        }

        Например если у нас есть объект obj = { name: "Dima" } и при вызове ф-и в нее передадим этот объект Header(obj), то когда
        ф-я будет выполняться внутри себя она назовет этот объект props и будет обращаться к нему уже по этому имени props.name .
        

    // *! Тут мы сами вызвали компонент Header, но в реакте мы никогда не вызываем компонент напрямую, а  пишем тег <Header /> - 
        вызывает ф-ю реакт и именно он определяет какой объект передать в Header, props в компонент приходит всегда и по умолчанию
        это пустой объект, и какже нам передать в него нужный нам объект. По аналогии с тегами хтмл у которых есть аттрибуты и они
        настраивают эти теги, наш тег который мы пишем тоже можно настраивать аттрибутом.

            <Header name='Dima' /> - реакт создает объект у которого будет свойство name со значением 'Dima'

            <Header name='Dima' age='30'/> - { name:'Dima', age:'30' }


        и теперь можно эти значения использовать внутри ф-и

            const Header = (props) => {
                        return(
                            <span> {props.name}, {props.age} </span>
                            <...>
                            <...>
                            );
                    }


    Теперь сделаем 2 поста с разными сообщениями:

        <Post message='Yo' />

        <Post message="It's my fist post." />

        а в компоненте поста пропишем props - в параметры и в разметке обратимся к {props.message} - экранируя его {} - фигурными
        скобками потому что выполняем код JS в середине JSX, если не заэкранировать то увидели бы просто надпись props.message на
        сайте.

        const Post = (props)=> {
            return(
                <div className="post">
                    <img src="https://th.bing.com/th/id/R.bf5e1eba30b53dffbc6a0353361855d4?rik=7duhy3rpO8d7MQ&riu=http%3a%2f%2feskipaper.com%2fimages%2favatar-3.jpg&ehk=YnIJUh9Lgb92QMa1swP9zHGNKXU66it9IG4vR41p6I4%3d&risl=&pid=ImgRaw&r=0" />
                    <div className="post__message">{props.message}</div> 
                </div>
            );
        }
                
*/}


{/*    ====    17. Остановочка, react за час №1     ====

    Вспомним что мы уже прошли. На следующих уроках сделаем будем делать остальные вкладки.

*/}


{/*    ====    18. Страница Dialogues(Messages)     ====

    Автор перешел на WebStorm потому что ему он больше нравится и там больше настроеных возможностей из коробки.


    На этой странице в разметке будет тот же хедер, тот же сайдбар, но контент другой. Он будет состоять из двух колонок, в левой
        будут люди с которыми ведем переписку, а в правой будут сообщения от этого человека.


    Закоментируем в App.js тег с <Profile /> и вместо него создадим тег <Dialogs />. Создадим компонент для этого тега, в папке
        components создадим папку Dialogs, а в ней Dialogs.jsx и Dialogs.module.css.

        В Dialogs.jsx  импортируем реакт, импортируем ксс модуль, создаем ф-ю Dialogs и делаем экспорт.

            import React from "react";
            import style from "./Dialogs.module.css"

            const Dialogs = (props) => {
                return(
                    <main className={style.content}>
                        <div className="dialogs__users">ПОЛЬЗОВАТЕЛИ</div>
                        <div className="dialogs__users-msgs">СООБЩЕНИЯ</div>
                    </main>
                );
            }

        В Апп.дс добавим импорт - import Dialogs from "./components/Dialogs/Dialogs";

        Видим что стили для content не применились, это потому что в ./Dialogs.module.css нету стилей для этого блока, а в нем
            храниться название для разметки грида grid-area: content, и получается нам нужно этот код скопировать из ксс модуля
            для портфолио. Происходит дублирование кода, зачит можно этот тег вынести из всех этих страниц в верстку в Апп.дс
            чтобы в него вставлялись меняющиеся страницы.  Пропишем имя класса без модуля <main className="app-wrapper-content">
            и теперь модно перенисти этот код ксс в Апп.ксс чтобы верстка при смене страниц сохраняла свою структуру.

*/}


{/*    ====    19. Route, browser-router, маршрутизация     ====

    Сделаем ссылки в Navbar кликабельными. Изменяем название в href. //*! никогда НЕ ставить точку в этих путях(они будут
        подставляться в путь аддресса сайта, поэтому точек там быть не не должно):

            <li className={style.item}><a href="/profile">Profile</a></li>
            <li className={style.item}><a href="/dialogs">Messages/Dialogs</a></li>

            Видим что теперь по клику на ссылку в аддрессную строку к локалхосту подставлятся название которое мы написали
            http://localhost:3000/dialogs , но сам сайт пока не меняется, только мигает(обновляется???) потому что не
            прописали убрать стандартное поведение ссылки. Пока что при обновлении загружаются все файлы которые мы создавали
            ксс, jsx, все модули(позже это исправим чтобы приходил только тот модуль который нужен для показа друго страницы).


    Для того чтобы при клике на измененные ссылки показывалась та страница которую мы хотим, нужно работать с роутами(route)
        - маршртур, маршрутизация. Нам нужна система роутинга которая будет смотреть какой путь сейчас у сайта и реагировать
        на его изменение загрузкой соответствующего компонента. Для работы с роутами нужно установить дополнительный модуль
        через npm. Если пропишем просто в папке проекта то модуль скачается в нод_модулс и при загрузке проекта на Гит
        модуль не поедет с кодом и когда другой человек скачает проект и попробует его запустить он не будет работать, потому
        что у человека не будет установлен этот модуль. Значит надо при инсталяции модуля дописать -save чтобы модуль
        сохранился в package.json и при запуске npm install на другом комьютере по умолчанию подтянулся вмесе со стандартными.

        Прописываем:  npm i react-router-dom -save

        Пакет установился и в package.json видим что он добавился в dependencies - "react-router-dom": "^6.3.0",

        "dependencies": {
            "@testing-library/jest-dom": "^5.16.5",
            "@testing-library/react": "^13.3.0",
            "@testing-library/user-event": "^13.5.0",
            "react": "^18.2.0",
            "react-dom": "^18.2.0",
            "react-router-dom": "^6.3.0",
            "react-scripts": "5.0.1",
            "web-vitals": "^2.1.4"


    Теперь в Апп.дс на места где находятся Диалогс и Профайл прописываем тег компонента Роут <Route /> при этом в Вебшторме
        атоматически прописался импорт в Апп.дс  import {Route} from "react-router-dom"; у автора не прописался автоматом
        и в ВСКоде наверное тоже не пропишеться автоматом и подчеркивается красным. Автор в Вебшторме нажимает alt + Enter
        и открывается меню где предлагает импортировать из двух файлов:

            insert "import {Route} from "react-router-dom""
            insert  "import Route from "react-router-dom/es/Route""

        Он выбрал наикратчайший путь, то есть такой как у нас import {Route} from "react-router-dom" - теперь сделалась
        запись импорта и тег Роут перестал подвечиваться красным. Заполняем Роут соответствующими компонентами, только
        название потому что Роут уже в теге.

          <Route component={Dialogs}/>
          <Route component={Profile}/>


    При запуске проекта вывелась ошибка - не может использовать Роут вне Роутера. Это значит что нам нужно всю нашу разметку
        поместить в тег(вроде как есть 2 тега но мы выбрали один из них BrowserRouter), помещаем и нам этот тег подчеркивает
        красным, нужно его тоже импортировать из модуля который установили теперь импорт такой:

        import {BrowserRouter, Route} from "react-router-dom";

        а разметка такая:

        <BrowserRouter>
          <div className='app-wrapper'>
              <Header/>
              <Navbar/>
               <div className='app-wrapper-content'>
                  <Route component={Dialogs}/>
                  <Route component={Profile}/>
                </div>
           </div>
        </BrowserRouter>


    У автора загрузился сайт и отрисовалась и страница диалогов и страница профиля, у меня не загрузился, пришлось дополнительно
        обернуть Роут в Роуты и импортировать его тоже и сайт отрисовался, но без контента, только хедер и боковуха, а при
        клике по ссылкам пишет в консоли - No routes matched location "/profile"

        import {BrowserRouter, Route, Routes} from "react-router-dom";

        function App() {
          return (
              <BrowserRouter>
                  <div className='app-wrapper'>
                      <Header/>
                      <Navbar/>
                      <div className='app-wrapper-content'>
                          <Routes>
                          <Route component={Dialogs}/>
                          <Route component={Profile}/>
                          </Routes>
                      </div>
                  </div>
              </BrowserRouter>
             );
            }

    Автор добавляет path="/dialogs" для диалогов и профайл для Профайла в тег Роут.

      <Route path="/dialogs" component={Dialogs}/>
      <Route path="/profile" component={Profile}/>

        У него все заработало, у меня выводит ошибку Matched leaf route at location "/dialogs" does not have an element.
        This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.


    //*! Заработало при такой конфигурации, так происходит потому что модуль обновился и теперь Route пишеться с element,
        и вставляется сам тег компонента, поэтому дальше по программе render в Route не понадобиться, также в новой версии
        удален switch поэтому он не импортируется из модуля а вместо него используется Route.

        import {BrowserRouter as Router, Routes, Route, Link, useRouteMatch, useParams} from "react-router-dom";

        function App() {
          return (
              <Router>
                  <div className='app-wrapper'>
                      <Header/>
                      <Navbar/>
                      <div className='app-wrapper-content'>
                          <Routes>
                              <Route path="/dialogs" element={<Dialogs />} />
                              <Route path="/profile" element={<Profile />} />
                          </Routes>
                      </div>
                  </div>
              </Router>
          );
        }

*/}


{/*    ====    20. NavLink     ====

    Сделали что при клике на ссылку происходит переключение контента, но страница перезагружается, из-за этого тратится траффик и
        получается моргание страницы и это получается веб сайт, а не SPA. Это стандартное поведение ссылки <a></a>, значит вместо
        нее будем использовать теги NavLink для этого его нужно импортировать из react-router-dom, а вместо href используется to. 

        import {NavLink} from "react-router-dom"

        <NavLink to='/profile'>Profile</NavLink>

        теперь по клике на ссылку страница не перезагружается, но меняется путь в адрессной строке и происходит обновление 
        контента.


    Если посмотрим в верстку сайта то видим что по прежнему эти ссылки являются тегами <a></a>, перезагрузки страницы не происходит
        потому что тег NavLink возвращает тег <a> и вешает на него евент лисенер в котором подменяет адресс обращаясь(c помощью)
        к history API, и помещает в этот eventListener - preventDefault - отмена стандартного поведения ссылки.

        //todo почитать про  history API


    Ссылки после нажатия становяться фиолетовыми и по умолчанию имеют подчеркивание, сделаем чтобы они были как обычный текст, для
        этого в Navbar.module.css пропишем стиль:

        .item a{
            color: white;
            text-decoration: none;
        }

        
    Еще сделаем выбраную(активную) ссылку золотым цветом(если у ссылки а в класе .item будет присутсвовать класс .active):

        .item a.active{
            color:gold;
        }

        NavLink автоматически присваивает возвращаемой ссылке класс - active, но так как у нас из модуля приходит не просто
        active, а с добавленными словами, нам нужно изменить стандартное поведение NavLink, чтобы он присваивал такой же класс
        как в модулях, для этого передадим ему этот класс из модуля как к другим тегам.

        <NavLink to='/profile' activeClassName={s.active} >Profile</NavLink>

*/}


{/*    ====    21. Верстаем страницу диалогов     ====

    Нужно сделать 2 колонки. В Dialogs.jsx создаем две дивки, в одной будут Диалоги(почему не пользователи, потому что может
        появиться кнопочка - удалить беседу, и мы же не пользователя удаляем, а диалог), а вторая колонка - сообщения.

        Видим что все в куче, нужно прописать стили в Dialogs.module.css перенести их как объект из модуля в верстку:

        const Dialogs = (props) => {
            return (
                <main className={s.dialogs}>
                <div className={s.dialogsItems}>
                    <div className={s.dialog + ' ' + s.active}>Dmitriy</div>
                    <div className={s.dialog}>Andrey</div>
                    <div className={s.dialog}>Valera</div>
                    <div className={s.dialog}>Sveta</div>
                    <div className={s.dialog}>Viktor</div>
                </div>
                <div className={s.messages}>
                    <div className={s.message}>Hi</div>
                    <div className={s.message}>Yo</div>
                    <div className={s.message}>What's up?</div>
                </div>
                </main>
            );
        }


        css file:

        .dialogs {
            display: grid;
            grid-template-columns: 2fr 8fr;

        }

        .dialogsItems {
            padding: 20px;
        }

        .dialogsItems .active {
            color: gold;
        }

        .dialog {
        margin-bottom: 10px;    
        }

        .messages {
            padding: 20px;
        }

        .messages .message {
            margin-bottom: 10px;
        }


    На следующем уроке сделаем чтобы при нажатии на dialog происходила подгрузка содержимого беседы, логика будет как с кликами по
        ссылкам для смены контента.

*/}


{/*    ====    22. Route exact     ====

    Обернем имя пользователя с которым диалог в NavLink чтобы они генерили путь в адрессной строке и им можно было делится с
        кем-то чтобы у него сайт подстроился также, также по этому пути будет показываться сообщения с этим человеком. Импортируем
        НавЛинк из модуля.

        import {NavLink} from "react-router-dom"

        const Dialogs = (props) => {
            return (
                <main className={s.dialogs}>
                <div className={s.dialogsItems}>
                    <div className={s.dialog + ' ' + s.active}>
                        <NavLink to='/dialogs/1'>Dmitriy</NavLink>
                    </div>
                    <div className={s.dialog}>
                        <NavLink to='/dialogs/2'>Andrey</NavLink>
                    </div>
                    <div className={s.dialog}>
                        <NavLink to='/dialogs/3'>Valera</NavLink>
                    </div>
                    <div className={s.dialog}>
                        <NavLink to='/dialogs/4'>Sveta</NavLink>
                    </div>
                    <div className={s.dialog}>
                        <NavLink to='/dialogs/5'>Viktor</NavLink>
                    </div>
                </div>
                <div className={s.messages}>
                    <div className={s.message}>Hi</div>
                    <div className={s.message}>Yo</div>
                    <div className={s.message}>What's up?</div>
                </div>
                </main>
            );
        }


    //*!Так как в нашем пути /dialogs/5 - присутствует часть пути /dialogs - для Route Dialogs из App.js, то контент не 
        перезагружается а остается прежним, тоесть Route проверяет путь на нужный кусок пути. Можно задать чтобы Route
        проверял весь путь не частичное совпадение, а полное совпадение, тоесть Dialogs отобразится только когда путь будет
        полностью совпадать:

        <Route exact path="/dialogs" component={Dialogs}/>

        Пока оставим без exact.


    Не обязательно при смене url создавать новый Route, не обязательно нам должен показываться компонент новый. В нашем случае
        при клике на пользователя мы хотим показывать другие сообщения, а не компоненты(я так понял он хочет сделать несколько
        сообщений-дивов, а уже их содержимое менять в зависимости от props).

*/}


{/*    ====    23. Props для диалогов     ====

    Создадим подкомпоненты Dialog и Message в Dialogs.jsx и пока оставим в это файле потому что они больше нигде не используются,
        но если нужно будет их использовать в других компонентах или неужобно будет работать с этим фалом потому что много кода
        тогда вынесем в отдельные файлы. Напишем их гибкими с props.

        const DialogItem = (props) => {
            return(
                <div className={s.dialog}>
                    <NavLink to={"/dialogs/" + props.id}>{props.name}</NavLink>
                </div>
            );
        }

        const Message = (props) => {
            return(
                 <div className={s.message}>{props.msg}</div>
            );
        }


         const Dialogs = (props) => {
            return (
                <main className={s.dialogs}>
                    <div className={s.dialogsItems}>
                        <DialogItem name="Dmitriy" id="1" />
                        <DialogItem name="Andrey" id="2" />
                        <DialogItem name="Valera" id="3" />
                        <DialogItem name="Sveta" id="4" />
                        <DialogItem name="Viktor" id="5" />
                    </div>
                    <div className={s.messages}>
                        <Message msg="Hi" />
                        <Message msg="Yo" />
                        <Message msg="What's up?" />
                    </div>
                </main>
            );
        }



    Теперь зарефакторм страницу Profile. Вынесем в отдельный компонент остальной код вместе с большой картинкой, и оставим только
        тег компонента. Создадим импорт. В файле компонента сделаем экспорт и импорт из ксс модуля.

        const Profile = () => {
            return (
                <main className="content">
                <ProfileInfo />
                <MyPosts />
                </main>
            );
            }

        const ProfileInfo = () => {
            return (
                <div>
                <div>
                    <img className="content__header" src="https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RE4wwuO?ver=1fc3" />
                </div>
                <div className="form__user">
                    <img className="user-avatar" src="https://images.archive-digger.com/taboola/image/fetch/f_jpg%2Cq_auto%2Ch_225%2Cw_300%2Cc_fill%2Cg_faces:auto%2Ce_sharpen/https%3A%2F%2Fi.imgur.com%2FhDNiJvY.png" />
                    <div className="user-description">Description</div>
                </div>
                </div>
            );
        }

*/}


{/*    ====    24. UI - BLL, выносим данные в сторону     ====

    В компоненте Dialogs идет много дублирования и props мы передаем прямо в тегах, в реальном проекте эти данные приходяд с 
        сервера по запросу. Смотрим на DialogItem и видим что его props сгруппированы, тоесть две пары ключ-значение. Значит
        можносказать что нам нужен объект под каждого пользователя, их будет много поэтому сделаем для них массив. 

         <DialogItem name="Dmitriy" id="1" />


         создадим его прямо тут в середине компонента Dialogs перед return.

         const Dialogs = (props) => {

            let dialogsData = [
                {id: 1, name: "Dmitriy"},
                {id: 2, name: "Andrey"},
                {id: 3, name: "Valera"},
                {id: 4, name: "Sveta"},
                {id: 5, name: "Viktor"}
                ];

            return (
                <main className="dialogs">
                    <div className="dialogsItems">
                        <DialogItem name={dialogsData[0].name} id={dialogsData[0].id}/>
                        <DialogItem name={dialogsData[1].name} id={dialogsData[1].id}/>
                        <DialogItem name={dialogsData[2].name} id={dialogsData[2].id}/>
                    </div>
                    <div className="messages">
                        <Message msg="Hi" />
                        <Message msg="Yo" />
                        <Message msg="What's up?" />
                    </div>
                </main>
            );
        }

        //! классы для тегов изменены чтобы работало в файле на работе без реакт-апп

        Таким образом мы разграничим данные BLL(Business Logic Layer) и пользовательский интерфейс UI.


    Чтобы не добавлять теги вручную, мы можем с помощью метода map для массивов сгенерировать столько тегов сколько будет
        объектов в массиве, этот метод рассмотрим в следующем уроке. 
        
    //*! Эти диалоги как и сообщения , как и пользователи или какая-то информация - это сущности(какие-то записи в базе данных).

    А пока подготовимся к следующему уроку и сделаем тоже самое для  message. Мы могли бы для них сделать массив строк, но мы 
        понимаем что сообщение это не только строка, это еще и дата когда оно отправлено, отправитель, ссылка на авататарку, айди по
        которому его можно удалить - тоесть все равно это ОБЪЕКТ. Пока это у нас строка, но нужно всегда закладывать на перед
        возможные свойства и предусмотреть.

        Тут же в Dialogs копируем массив dialogsData и переделываем его в messagesData, id в этих массивах будут одинаковые, но
        это не повлияет на работоспособность потому что это разные массивы, и под одним айди в них храняться разные данные.
        Пока мы айди задаем сами, но потом они будут приходить с сервера, заменим в верстке код чтобы читать из этого массива.

        let messagesData = [
            { id: 1, msg: "Hi" },
            { id: 2, msg: "Yo" },
            { id: 3, msg: "What's up?" },
            { id: 4, msg: "Hi" },
            { id: 5, msg: "Yo" }
        ];

        return (
            <main className="dialogs">
            <div className="dialogsItems">
                <DialogItem name={dialogsData[0].name} id={dialogsData[0].id} />
                <DialogItem name={dialogsData[1].name} id={dialogsData[1].id} />
                <DialogItem name={dialogsData[2].name} id={dialogsData[2].id} />
            </div>
            <div className="messages">
                <Message msg={messagesData[0].msg} />
                <Message msg={messagesData[1].msg} />
                <Message msg={messagesData[2].msg} />
            </div>
            </main>
        );
    }

       
    Сделаем также с постами в MyPost.jsx

        const MyPosts = () => {

            let postsData = [
                { id: 1, post: "yo", likesCount:12 },
                { id: 2, post: "It's my fist post.", likesCount:11 },
                { id: 3, post: "0", likesCount:13 },
            ];

            return (
                <div className="form__new-post">
                <div className="new-post__title">New Post
                    <textarea></textarea>
                    <button>Add Post</button>
                </div>
                <Post msg={postsData[0].post}  likesCount={postsData[0].likesCount}/>
                <Post msg={postsData[1].post} likesCount={postsData[1].likesCount}/>
                <Post msg={postsData[2].post} likesCount={postsData[2].likesCount}/>
                </div>
            );
            }

            const Post = (props) => {
            console.log(props);
            return (
                <div className="post">
                <img src="https://th.bing.com/th/id/R.bf5e1eba30b53dffbc6a0353361855d4?rik=7duhy3rpO8d7MQ&riu=http%3a%2f%2feskipaper.com%2fimages%2favatar-3.jpg&ehk=YnIJUh9Lgb92QMa1swP9zHGNKXU66it9IG4vR41p6I4%3d&risl=&pid=ImgRaw&r=0" />
                <div className="post__message">{props.msg}</div>
                <div className="likes">Likes: {props.likesCount}</div>
                </div>
            );
        }

*/}


{/*    ====    25. Метод массива map     ====

    Если мы закомментируем код и вместо него напишем просто массив строк в фигурных скобках, то компилятор их просто 
        распкрое, потому что массив нельзя отобразить в виде хтмл элемента, и отобразит строки.
        
        return (
        <main className="dialogs">
            <div className="dialogsItems">

                {
                ['sdsdsd', 'sdsdsda', 'sdsdasaaaa']
                }

                // <DialogItem name={dialogsData[0].name} id={dialogsData[0].id} />
                //<DialogItem name={dialogsData[1].name} id={dialogsData[1].id} />
                //<DialogItem name={dialogsData[2].name} id={dialogsData[2].id} />
            </div>

    Если вместо строк будут объекты - выдаст ошибку, потому что объект он никак не сможет отобразить. Но если вместо строк
        в массив вставить реакт компонент, то реакт раскроет массив и отобразит этот компонент.

         <main className="dialogs">
            <div className="dialogsItems">

                {
                    [<DialogItem name={dialogsData[0].name} id={dialogsData[0].id} />,
                    <DialogItem name={dialogsData[1].name} id={dialogsData[1].id} />,
                    <DialogItem name={dialogsData[2].name} id={dialogsData[2].id} />]
                }


    Таким образом можем вынести этот массив вне  return ф-и в dialogsElements , а вместо него оставим ссылку, будет
        работать также.

        let dialogsElements = [
        <DialogItem name={dialogsData[0].name} id={dialogsData[0].id} />,
        <DialogItem name={dialogsData[1].name} id={dialogsData[1].id} />,
        <DialogItem name={dialogsData[2].name} id={dialogsData[2].id} />
        ]


        return (
            <main className="dialogs">
            <div className="dialogsItems">

                {dialogsElements}

        Отсюда вывод - что можно отбразить массив который мы сами сформируем на основе массива с объектами с данными,
        и тогда количество тегов будет не статическое, а такое же сколько объектов в пришедшем массиве с объектами
        dialogsData. Такое преобразование будем делать с помощью метода массива map.


    map - преобразовывает массив одних эл. в массив других. Новый массив по длинне будет такмим же как и изначальный.
        map возвращает НОВЫЙ массив, принимает стрелочную ф-ю(//? колбек) аргументы: el, ind, arr.
        Она вызывается столько раз сколько элементов в массиве, в середине нее и происходят нужные нам преобразования.
        //! Если стрелочная ф-я только возвращает что-то(перед return нету кода) то можно убрать фигурные скобки и
        слово return, если аргумент только 1 например обязательный аргумент - el(эл. который мы перебираем) - можно
        убрать скобки вокруг него, также его можно назвать как нам вздумается(по специфике массива).

        Тут из массива имен определяются мужские и женские и для мужских в новый массив заносятся 1, женских - 0.
            
            ['Evgen', 'Aleksandr', 'Olya', 'Yana']                      [1, 1, 0, 0]

            let newArray = oldArray.map((el)=>{         let newArray = oldArray.map(name => isMale(name) ? 1 : 0)
                return isMale(el) ? 1 : 0;
            })


        Тут из массива имен получаем массив эл. li с этими именами в середине.

            ['Evgen', 'Aleksandr', 'Olya', 'Yana'] превратится в  
            ['<li>Evgen</li>', '<li>Aleksandr</li>', '<li>Olya</li>', '<li>Yana</li>']

            let newArray = oldArray.map(name => {       let newArray = oldArray.map(name => `<li>${name}</li>`
                return "<li>"" + name + "</li>';
            })


        Тут из массива слов получаем массив с объектами. Тут если хотим убрать ретурн и написать все в одну строку
            так как раньше сделать не получиться потому что браузер будет думать что оставшиеся фигурны скобки
            это не тело объекта, а тело ф-ии, поэтому объект нужно взять в скобки.

            ['blabla', 'hello', 'hi']       
            [{eng:'blabla', ru:'блабла'}, {eng:'hello', ru:'привет'}, {eng:'hi', ru:'здарова'}]

            let newArray = oldArray.map( word => {       let newArray = oldArray.map(word => (
                return {                                        {
                    eng: word,                                    eng: word,
                    ru: translateIntoRu(word)                     ru: translateIntoRu(word)
                };                                              }
            });                                              ) );


        Чаще всего для реакта будем использовать преобразование массива с объктами в массив с JSX елементами

            [{eng:'blabla', ru:'блабла'}, {eng:'hello', ru:'привет'}, {eng:'hi', ru:'здарова'}]

        [<Message eng='blabla' ru='блабла' />, <Message eng='hello' ru='привет' />, <Message eng='hi' ru='здарова' />]

            let newArray = oldArray.map(
                el => (<Message eng={el.eng} ru={el.ru} /> ) )

                Таким образом мы маппим(соотносим, преобразовываем) массив одних объектов на массив других объектов.



    Зарефакторим наш код.

        const Dialogs = (props) => {

            let dialogsData = [
                { id: 1, name: "Dmitriy" },
                { id: 2, name: "Andrey" },
                { id: 3, name: "Valera" },
                { id: 4, name: "Sveta" },
                { id: 5, name: "Viktor" }
            ];

            let dialogsElements = dialogsData.map(el => (
                <DialogItem name={el.name} id={el.id} />
            ));

            let messagesData = [
                { id: 1, msg: "Hi" },
                { id: 2, msg: "Yo" },
                { id: 3, msg: "What's up?" },
                { id: 4, msg: "Hi" },
                { id: 5, msg: "Yo" }
            ];

            let messagesElements = messagesData.map(el => (
                <Message msg={el.msg} />
            ));


            return (
                <main className="dialogs">
                <div className="dialogsItems">
                    {dialogsElements}
                </div>
                <div className="messages">
                {messagesElements}
                </div>
                </main>
            );
        }

        
        И Посты

        const MyPosts = () => {

            let postsData = [
                { id: 1, post: "yo", likesCount: 12 },
                { id: 2, post: "It's my fist post.", likesCount: 11 },
                { id: 3, post: "0", likesCount: 50 },
            ];

            let postsElements = postsData.map(el => <Post msg={el.post} likesCount={el.likesCount} />)

            return (
                <div className="form__new-post">
                <div className="new-post__title">New Post
                    <textarea></textarea>
                    <button>Add Post</button>
                </div>
                {postsElements}
                </div>
            );
            }

            const Post = (props) => {
            console.log(props);
            return (
                <div className="post">
                <img src="https://th.bing.com/th/id/R.bf5e1eba30b53dffbc6a0353361855d4?rik=7duhy3rpO8d7MQ&riu=http%3a%2f%2feskipaper.com%2fimages%2favatar-3.jpg&ehk=YnIJUh9Lgb92QMa1swP9zHGNKXU66it9IG4vR41p6I4%3d&risl=&pid=ImgRaw&r=0" />
                <div className="post__message">{props.msg}</div>
                <div className="likes">Likes: {props.likesCount}</div>
                </div>
            );
        }

*/}


{/*    ====    26. Структура проекта, еще раз про UI - BLL     ====

    В index.js отрисовываем компонент App, все его содержимое  оборачиваем в BrowserRouter для контроля за кликами по ссылкам и
        их загрузки без перезагрузки страницы. В BrowserRouter - компоненты Header, Navbar и в тегах Route Dialogs и Profile.
        В Profile отрисовываются компоненты ProfileInfo и MyPosts, они находятся в сових папках в папке компонента в котором
        используются. Внутри MyPosts в папке находится компонент Post. В Dialogs присутствуют  DialogItem и Message, но мы их
        пока не выносили в отдельные файлы и папки - этим и займемся. 
        
    //*! При работе с проектом(своим или когда разбираемся с чужим) автор рекоммендует делать схему проекта чтобі потом быстро
        разобраться в нем через время при необходимости.

    Создаи папки и в них файлы jsx стили оставим в главном файле Dialogs.module.css, потому что там не много стилей и разбивать не
        целесообразно и для работоспособности кода испортируем этот ксс модуль в новые созданные jsx файлы DialogItem и Message,
        экспортируем их содержимое и делаем импорт компонент в Dialogs.jsx.


    //*! Реакт отрисовывает компоненты для UI на основании компонентов которые принимают в себя props - данные приходящие из BLL. 
        БЛЛ конвертирует данные с сервера в данные которые хранит в себе и отправляет их в компоненты, в роли BLL выступает Redux.
        Как только в Redux изменяются данные, Реакт перерисовывает компоненты для которых эти данные изменились, в тоже время из
        UI в БЛЛ постоянно отправляются комманды(например - пользователь нажал кнопку чтобы удалить такой-то пост, сделай это).

        В нашей структуре пока получается что данные лежат в самом компоненте MyPosts и Dialogs, это нужно будет исправить путем
        вынесения данных за компоненты, ближайший файл который не является компонентом - index.js, в нем начинает отрисовываться
        компонент App, но сам файл по сути компонентом не является, для начала поступим так. 
        
        //todo Из-за Route мы самостоятельно не сможем поднять данные в index.js(потому что используем не тег компонента, а просто
        его название и никаки не можем добавить аттрибут в этот тег), поэтому наша задача поднять их на 1 уроевень компонента выше.

*/}


{/*    ====    27. Component vs render, прокидываем props через Route     ====

    Для того чтобы вынести данные и потом прокинуть их через пропсы компонентов в Route нужно чтобы в роуте отрисовывался тег
        компонента. Сейчас там такой код

            <Route path="/dialogs" component={Dialogs}/>
            <Route path="/profile" component={Profile}/>


    Но есть еще один способ записать роут, написать render вместо component и передать анонимную ф-ю которую вызовет render, и
        уже эта ф-я вернет тег компонента :

        <Route path="/dialogs" render={ () => <Dialogs /> }/>
        <Route path="/profile" render={ () => <Profile /> }/>

        //*! эти способы взаимоисключающие.


    Можно также вынести эту ф-ю в отдельную переменную и потом подставить по первому способу

        let FunctionDialog = () => <Dialogs />

        <Route path="/dialogs" component={ FunctionDialog }/>
        <Route path="/profile" render={ () => <Profile /> }/>


    //*! Второй способ заработал и с component, но автор рекомендует использовать только с render

        <Route path="/dialogs" component={ () => <Dialogs /> }/>
        <Route path="/profile" component={ () => <Profile /> }/>

    

    Чтобы прокинуть props который пришел в App дальше нужно его разбить на части и закинуть в Dialogs что-то одно, а в Profile
        что-то другое(нужные массивы).

*/}


{/*    ====    28. Выносим данные в index.js     ====

    Будем переносить данные по одному уровню вверх чтобы было наляднее(понятнее логика) и не запутаться.


    Для начала посмотрим как вынести данные на уровень выше из MyPosts в Profile. Выносим массив с данными в компонент Profile
        а в методе c map добавляем слово props. А в Profile в саму ф-ю вставляем массив postsData и передаем его в тег компонента
        MyPosts.
        
        const Profile = () => {
        
            let postsData = [
                { id: 1, post: "yo", likesCount: 12 },
                { id: 2, post: "It's my fist post.", likesCount: 11 },
                { id: 3, post: "0", likesCount: 50 },
            ];

            return (
                <main className="content">
                <ProfileInfo />
                <MyPosts postsData={postsData}/>
                </main>
            );
        }


        const MyPosts = (props) => {

            let postsElements = props.postsData.map(el => <Post msg={el.post} likesCount={el.likesCount} />);

            return (
                <div className="form__new-post">
                <div className="new-post__title">New Post
                    <textarea></textarea>
                    <button>Add Post</button>
                </div>
                {postsElements}
                </div>
            );
        }


    Вынесем данные в App.js. Добавляем в Profile прием props и объект props для передачи в компонент. В Апп вставляем массив с
        данными и для тега Profile передаем массив по названию.

        const Profile = (props) => {
        
            let postsData = [
                { id: 1, post: "yo", likesCount: 12 },
                { id: 2, post: "It's my fist post.", likesCount: 11 },
                { id: 3, post: "0", likesCount: 50 },
            ];

            return (
                <main className="content">
                <ProfileInfo />
                <MyPosts postsData={props.postsData}/>
                </main>
            );
        }

        const App = () => {

            let postsData = [
                { id: 1, post: "yo", likesCount: 12 },
                { id: 2, post: "It's my fist post.", likesCount: 11 },
                { id: 3, post: "0", likesCount: 50 },
            ];
            
            return (
            <div className="app-wrapper">
                {Header()}
                {Navbar()}
                <main className="app-wrapper-content">
                <Dialogs /> 
                <Profile postsData={postsData}/>  = //*! <Route path="/profile" render={ () => <Profile postsData={postsData}/> }/>
                </main>                                                      для приложения
            </div>
            );
        }

    
    Для App выносим также, вставляем данные ДО рендера, а потом в теге Апп передаем массив <App postsData={postsData}/>



    По аналогии вынесем данные из Dialogs.

        const Dialogs = (props) => {

            let dialogsElements = props.dialogsData.map(el => (
                <DialogItem name={el.name} id={el.id} />
            ));

            let messagesElements = props.messagesData.map(el => (
                <Message msg={el.msg} />
            ));


            return (
                <main className="dialogs">
                <div className="dialogsItems">
                    {dialogsElements}
                </div>
                <div className="messages">
                    {messagesElements}
                </div>
                </main>
            );
        }


        const App = () => {

            let postsData = [
                { id: 1, post: "yo", likesCount: 12 },
                { id: 2, post: "It's my fist post.", likesCount: 11 },
                { id: 3, post: "0", likesCount: 50 },
            ];

            let messagesData = [
                { id: 1, msg: "Hi" },
                { id: 2, msg: "Yo" },
                { id: 3, msg: "What's up?" },
                { id: 4, msg: "Hi" },
                { id: 5, msg: "Yo" }
            ];

            let dialogsData = [
                { id: 1, name: "Dmitriy" },
                { id: 2, name: "Andrey" },
                { id: 3, name: "Valera" },
                { id: 4, name: "Sveta" },
                { id: 5, name: "Viktor" }
            ];

            
            return (
            <div className="app-wrapper">
                {Header()}
                {Navbar()}
                <main className="app-wrapper-content">
                <Dialogs messagesData={messagesData} dialogsData={dialogsData} />   //*! <Route path=".....
                <Profile postsData={postsData}/>
                </main>
                </div>
                );
        }


    Дальше перенесем в Апп  <App postsData={postsData} messagesData={messagesData} dialogsData={dialogsData} />


    Теперь данный у нас отделены от компонентов.

*/}


{/*    ====    29. Упаковываем данные в state     ====

    Для сохранения принципе single responcibility(один файл - одна задача, одна ф-я - одна задача) из файла App.js вынесем все наши
        массивы с данными в отдельный файл State.js . Из него данные будут импортироваться(так ак Апп не компонент и через props
        не получиться) через import в App.js. Чтобы не делать кучу импортов упакуем все массивы в один объект state с названиями
        свойств как переменные, и значениями свойств - массивами. А дальше прокинем state по  цепочке но в Route отдадим нужные
        свойства определенным коспонентам, а не целый state(чтобы не передавать лишнее, будет излишнее знание о системе - нарушается
        инкапсуляция).

        Почему не импортируем state напрямую в компонент, а прокидываем через props - потому что мы хотим сохранить чистые ф-и,
        то есть чтобы ф-я работала только с тем что в нее приходит из вне(ну и так будет снова же много лишней информации),
        чтобы система была контролируема, предсказуема, тестируемая - нужно избавиться от глобальных вещей(как этот импорт всей 
        базы данных, данные не должны быть глобальными).


        Создаем в components папку - redux и в ней state.js в него переместим все наши данные

            let state = {
                postsData:[
                    { id: 1, post: "yo", likesCount: 12 },
                    { id: 2, post: "It's my fist post.", likesCount: 11 },
                    { id: 3, post: "0", likesCount: 50 }],
                messagesData: [
                    { id: 1, msg: "Hi" },
                    { id: 2, msg: "Yo" },
                    { id: 3, msg: "What's up?" },
                    { id: 4, msg: "Hi" },
                    { id: 5, msg: "Yo" }],
                dialogsData: [
                    { id: 1, name: "Dmitriy" },
                    { id: 2, name: "Andrey" },
                    { id: 3, name: "Valera" },
                    { id: 4, name: "Sveta" },
                    { id: 5, name: "Viktor" }]
            };

            export default state;


        Теперь этот объект импортируем в index.js и передаем его в тег App не по отдельности, а полностью :

            import state from './redux/state'

            <App appState={state}/>


        Теперь в props App приходит объект appState и путь к массиву удлинняется на это название:

        const App = (props) => {
            return (
            <div className="app-wrapper">
                {Header()}
                {Navbar()}
                <main className="app-wrapper-content">
                <Dialogs messagesData={props.appState.messagesData} dialogsData={props.appState.dialogsData} />
                <Profile postsData={props.appState.postsData}/>
                </main>
                </div>
                );
        }
        

    Все данные для всех страниц будут храниться в этом одном объекте state. Для того чтобы как-то сгруппировать эти массивы в 
        объекте state будем делать подобъекты, например dialogsData и messagesData относятся к одному компоненту Dialogs. Создадим
        в state свойства profilePage и dialogsPage, которые в свою очередь являются объектами и в них перенесем наши массивы.
        Теперь один подобъект будет обслуживать одну страницу. Для доступа к этим подобъектам нужно добавить в путь для props
        в теги Profile и Dialogs имена подобъектов.

        let state = {
            profilePage: {
                postsData: [
                    { id: 1, post: "yo", likesCount: 12 },
                    { id: 2, post: "It's my fist post.", likesCount: 11 },
                    { id: 3, post: "0", likesCount: 50 }]
            },
            dialogsPage: {
                dialogsData: [
                    { id: 1, name: "Dmitriy" },
                    { id: 2, name: "Andrey" },
                    { id: 3, name: "Valera" },
                    { id: 4, name: "Sveta" },
                    { id: 5, name: "Viktor" }],
                messagesData: [
                    { id: 1, msg: "Hi" },
                    { id: 2, msg: "Yo" },
                    { id: 3, msg: "What's up?" },
                    { id: 4, msg: "Hi" },
                    { id: 5, msg: "Yo" }]
            }
        };


        function App(props) {
            return (
                <BrowserRouter>
                    <div className='app-wrapper'>
                        <Header />
                        <Navbar />
                        <div className='app-wrapper-content'>
                            <Routes>
                                <Route path="/profile" element={<Profile postsData={props.appState.profilePage.postsData} />} />
                                <Route path="/dialogs" element={<Dialogs messagesData={props.appState.dialogsPage.messagesData}
                                                                     dialogsData={props.appState.dialogsPage.dialogsData} />} />
                            </Routes>
                        </div>
                    </div>
                </BrowserRouter>
            );
        }


    Можно еще улучшить, сократим передачу для dialogsPage передав целый подобъект в компонент Dialogs, а там уже раскрыв его, также сделаем для Profile.

        <Route path="/profile" element={<Profile state={props.appState.profilePage} />} />
        <Route path="/dialogs" element={<Dialogs state={props.appState.dialogsPage} />} />


        const Profile = (props) => {
            return(
                <main>
                    <ProfileInfo />
                    <MyPosts postsData={props.state.postsData}/>
                </main>
            );
        }


        const Dialogs = (props) => {

            let dialogsElements = props.state.dialogsData.map(el => (
                <DialogItem name={el.name} id={el.id} />
            ));

            let messagesElements = props.state.messagesData.map(el => (
                <Message msg={el.msg} />
            ));


    У автора в консоли выводятся ошибки связанные с ключами, поговорим о них в следующих видео.

    //todo сделать в сайдбаре секцию друзей(3 штуки аватарка+имя) и эти данные хранить в state,
        в Dialogs сделать аватарки для друзей и еще одну секцию сообщений напротив этих сообщ.
        перед сообщениями также добавить аватарки, и эти сообщения привязвть к разным частям
        страницы.

*/}


{/*    ====    30. Остановочка, react за час №2     ====

    Закрепляем то что изучили.

*/}


{/*    ====    31. onClick, ref, VirtualDOM     ====

    Добавляем логику на сайт(изменения при нажатии кнопок). 
    
    Разделим ее на 2 части потому что UI отлавливаем действия пользователя, но компоненты не имеют право вносить изменения в state: 
        1) научимся взаимодействовать с пользователем с кнопками, элементами и данными введенными в эти элем;
        2) склеим наш state - изменения которые произошли от действий пользователя с изменениями в state.


    Для того чтобы можно было кликнуть на элемент нужно в него добавить событие onClick. Добавим его к кнопке в MyPosts и при 
        нажатии будет запускаться анонимная стрелочная ф-я которая выполнит код внутри:

        <button onClick={ ()=> {alert('Hello')}  } >Add Post</button>

        эта ф-я выполняется только после нажатия - коллбек ф-я(ф-я которую мы сами не вызываем, а передаем для вызова другому эл.)


    Вынесем эту ф-ю(логику) вне JSX разметки и передадим в нее только название ф-и:

        let addPost = ()=> {alert('Hello')};

        return (
            <div className="form__new-post">
            <div className="new-post__title">New Post
                <textarea></textarea>
                <button onClick={ addPost } >Add Post</button>
            </div>
            {postsElements}
            </div>
        );
        


    Теперь нам нужно чтобы UI собрал данные из формы и по клику кнопки отправил эти данные чтобы они как-то попали в state.
        //*! Так как мы работаем с VirtualDOM в реакте, то не должны обращаться к DOM на прямую, это будет не правильно и может
        повлечь замедление работы системы, то есть мы не можем просто назначить для <textarea></textarea> айди и обратившись к
        нему взять его value и передать, это будет не правильно еще и потому что мы не знаем в какой момент времени элемент с
        <textarea></textarea> будет существовать в DOM.



    В реакте для обращения к элементу <textarea></textarea> мы создадим для него ссылку, и укажем ее название в теге <textarea>
        чтобы между ними создалась связь:
        
        let newPostElement = React.createRef();

        <textarea ref={newPostElement}></textarea>


        Теперь можем обратиться по ссылке(newPostElement) к этому нативному ХТМЛ элементу(current) и взять его содержимое(value):

        let newPostElement = React.createRef();

        let addPost = () => {
            let text = newPostElement.current.value;
            alert(text);
        };

        return (
            <div className="form__new-post">
            <div className="new-post__title">New Post
                <textarea ref={newPostElement}></textarea>
                <button onClick={ addPost } >Add Post</button>
            </div>
            {postsElements}
            </div>
        );

        //*! реакт рекомендует не использовать часто ref(потому что мы по сути тоже минуя реакт обращаемся напрямую к DOM), но так
        как это первый подход с которым мы познакомимся, то пока будем использовать его. Если считывать как у нас в примере 
        значением, мы не меняем ничего в DOM то еще ладно, но если нужно изменить то ref не стоит использовать для этой цели.


    Теперь нужно это значение передать в state profilePage создать там новый пост с новым айди следующем по нумерации и с числом
        лайков likesCount - 0, поэтому столько работы мы не можем возложить на компонент в котором считали значение, а то нарушится
        принцип single responcibility. Также отрисовка компонентов и прокидывание props у нас происходит 1 раз при загрузке 
        страницы и нам нужно заново запустить прокидывание props с новыми значениями чтобы заново произошла перерисовка.

*/}


{/*    ====    32. прокидываем callback через props     ====

    Чтобы изменять данные в state файле в объекте с данными, ф-я по изменению этих данных тоже должна находиться в этом файле.
        Простой пример добавления строки в массив users объекта state ф-й addUser:

        let state = {
            users:['Dima', 'Alex']
        }

        let addUser = (userName) => {
            state.users.push(userName);
        }


    Чтобы вызвать такую ф-ю при нажатии кнопки нужно ее прокинуть как и state через props. Так как ф-я это тоже объект, мы это
        можем сделать, экспортировав ее без не по дефолту(//? а по имени, именная?).



    В state.js добавим ф-ю addPost, она нарушает концепцию "чистой ф-и" потому что параметры которые она принимает не будут к
        ней приходить откуда то, а будут искаться в этом же файле. Но так как это происходит в одном файле то это допустимо
        (куда ни шло). Эта ф-я будет пушить в нужный массив новый объект, тут же создаем структуру объекта(id пока пишем 5 пока
        не важно).

        let addPost = (postMsg) => {
            let newPost ={
                id:5,
                post: postMsg,
                likesCount: 0
            };

            state.profilePage.postsData.push(newPost);
        }


        Для экспорта без дефолта можно сразу перед объявлением переменно писать export, импортировать такую ф-ю нужно иначе, через
        фигурные скобки, в index.js :

        import {addPost} from './state'


    Из index.js будем прокидывать ф-ю через props:

        const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(
            <React.StrictMode>
                <App appState={ state } addPost={ addPost } />
            </React.StrictMode>
        );


    Также дальше прокидываем в Апп и далее в MyPosts через Profile:

         <MyPosts postsData={props.state.postsData} addPost={props.addPost} />


    B уже в MyPosts используем ее - props.addPost(text):

        let addPost = () => {
            let text = newPostElement.current.value;
    //todo  props.addPost(text);
        };

        return (
            <div className="form__new-post">
            <div className="new-post__title">New Post
                <textarea ref={newPostElement}></textarea>
                <button onClick={ addPost } >Add Post</button>
            </div>
            {postsElements}
            </div>
        );


    Теперь после нажатия на кнопку новый пост не видим на странице, хотя добавился в state, потому что нужно запустить render заново.

*/}


{/*    ====    33. Отрисовка поста (зачатки FLUX)      ====

    Теперь после нажатия на кнопку новый пост не видим на странице, хотя добавился в state, потому что нужно запустить render 
        заново. И так может быть много раз, а если нам нужно это использовать минимум несколько раз обернем эти действия в 
        ф-ю в index.js rerenderEntireTree(пререрисовать всё дерево) - пока будем перерисовывать все дерево когда изменится state, 
        поэтому в ф-ю rerenderEntireTree вставим ф-ю ренедера всего App, и после объявления этой ф-и её нужно первый раз запустить
        чтобы произошел первый render:

        let rerenderEntireTree = () => {
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(
            <React.StrictMode>
                <App appState={state}/>
            </React.StrictMode>
            );
        }

        rerenderEntireTree();



    Теперь можем запускать ф-ю перерисовки в файле state так как он хранит state и знает когда state изменится. Хотелось бы 
        //*! импортировать rerenderEntireTree из index.js в state, но так делать нельзя потому что мы уже из state импортируем в 
        index.js.(//todo почему так нельзя делать???). 
        Чтобы это обойти создаем новый файл render.js в него помещаем ф-ю rerenderEntireTree и импортируем её в index.js
        и в state.js. Теперь в файлах такой код:


        state.js - импортируем {rerenderEntireTree} и в параметрах передаем ей state

            let addPost = (postMsg) => {
                let newPost ={
                    id:5,
                    post: postMsg,
                    likesCount: 0
                };

                state.profilePage.postsData.push(newPost);
                rerenderEntireTree(state);
            }


        index.js - убираем лишний импорт(остается импорт {rerenderEntireTree} from render + state from redux)

            rerenderEntireTree(state);


        render.js(импорт реакт, реактДОМ,  индекс.ксс, Апп, {addPost} from state - импортируем тоже из стейта?,
            тогда смысл всего этого, получился тот же импорт только не самого стейта, хммм). addPost={addPost} 
            - мне пришлось тоже передать, со стейтом не передавался, даже при дефолтном экспорте

            export let rerenderEntireTree = (state) => {
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(
                <React.StrictMode>
                    <App appState={state} addPost={addPost} /> 
                </React.StrictMode>
                );
            }


    Теперь получается так что рендер происходит в render.js и эта ф-я импортируется в state и script, когда в стейт происходит
        добавление нового элемента вызывается ф-я rerenderEntireTree и ей передается новый стейт, также этот стейт импортируется
        в script и там ф-я рендера вызывается еще раз с новым стейтом, который по props передается в рендер благодаря чему и 
        формируется новая структура. В script происходит первый запуск рендера.



    Также добавим очистку поля ввода после нажатия кнопки:

        let addPost = () => {
            let text = newPostElement.current.value;
            props.addPost(text);
            newPostElement.current.value = '';
        };



    Flux - архитектура(подход к организации потока данных когда UI пересылает данные в BLL, а оттуда приходят новые данные на 
        сосновании которых нжно перерисоваыть структуру). Одна из ее реализаций - Redux.
        //*!  Прочитать как на самом деле это звучит.

    Сейчас у нас нарушена эта архитектура, потому что UI не должен меняться пока не изменяться данные BLL и не придут обратно, а у
        нас сейчас можно что-то напечатать в <textarea> получается UI изменился, а BLL не изменился, это исправим в следующем 
        уроке.

*/}