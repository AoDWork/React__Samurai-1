    //============================================  React Samurai 1.0   ===========================================================
    
    /* После прохождения курса автор общает знания реакта для позиции солидного джуна, слудеющий курс 2.0 сделает нас солидным
                мидлом, но это уже после того как произойдет трудоустройство. Курс находится на ютубе по ссылке
                        https://courses.prometheus.org.ua/courses/course-v1:LITS+114+2022_T2/about                       */


    
{/*    ====    01. Как проходить курс     ====

    Изучаем react + Redux потому что это самая популярная связка для трудоустройства(на 2020 год).


    На верстку забиваем, вестаем - "абы було", в уроках изобретамем свой redux(24-41) потом изучаем обычный(42), также изобретам свой
        connect(43-44) в redux, потом смотрим редаксовский(45). Делается это для того что бы знать как все происходит внутри, не 
        абстрагируясь от сложных вещей JS.

        44 - просто ознакомиться что он есть, не записывая, держать в голове что connect работает через contexy API и забить.

        Начиная с connect - так как оно должно быть в продакшене.
    
        Взаимодействие с сервером бесплатное до какого то лимита. Что бы было безлим нужно кинуть копеечку автору. Решение некторых
            трудностей с запросами есть на сайте на который делаем запросы.

        53 - классовые компоненты. В 2020м стало возможно пользоваться хуками, но тогда еще на них все не перешли потому что прогеры
            очень инертны, также будем это учить потому что в Angular классовые компоненты и нужно это понимать.
        
        82 - селекторы не раскрыта полностью тема. Более лучше будет раскрыта в путь самурая 2.0.

        95 - делаем свой пейджинатор, а не используем готовый в учебных целях.


    Ведем конспект.


    Работаем в VSCode или Web Shtorme.


    Каждую неделю пересматриваем 100 урок, для визуализации полной картины что мы будем учить в целом и где находимся сейчас, а также
        для запоминания терминов.
     

    После прохождения курса обязательно идем на собеседования, 4 проваливаем на 5м устраиваемся на работу. После каждого собеседования
        составляем список вопросов на которые на смог ответить и учить их.
    
*/}


{/*    ====    02. Для чего Nodejs фронтенду     ====

    Изначально JS был создан для того чтобы выполнятся в браузере и делать какие то действия с хтмл + ксс, теперь оно так и осталось.


    Позже для работы с файловой системой компьютера и базами данных была создана программа Nodejs. Код для Nodejs также пишеться на
        JS передается в Nodejs и там выполняется(при выполнении в Nodejs код не имеет доступа к сайтам, а в браузере наоборот - 
        имеет доступ к сайтам но не может работать с файловой системой компьютера и программами). 

        И гугл хром и Nodejs используют движок V8, браузер дополняет V8 своими компонентами API(например хтмл элементы, ДОМ модель,
        события), а программа написаная для Nodejs взаимодействует с ОС(программы, девайсы(вебка, микрофон)), файловой системой, 
        базой данных. И браузер и Nodejs понимает, интерпретирует+ компилирует JS.

    
    Для чего Nodejs(программа, платформа в которой выполняетс JS код) нужен фронтенд разработчику: работа с файловой системой, 
        базой данных, Nodejs можно установить в микроконтроллер и написать код на JS чтобы например обслаживать холодильник(показ
        температуры, сигнал когда открыта дверь).

        Для удобства разработки(автоматизации процесса) - мы пишем код для браузера, потом готовим его для загрузки в браузер:
        компилируем (например из sass в css), бандлы создаем, склеиваем все JS файлы, минифицируем их, склеиваем картинки в спрайты.
        То есть перед отправкой программы в браузер мы делаем много дополнительных задач. Также для удобства разработки хотим чтобы
        не сохранять код постоянно, а в браузере делать оьновление страницы, а чтобы это было автоматически. Сегодня мы даже можем
        писать на другом языке который превращается в JS код и потом запускается в браузере(например в React пишем на языке JSX
        который должен превратиться в понятный браузеру язык). 
        
        Для того чтобы у всей комманды был одинаковый процесс всего этого нужно использовать сторонние программы(модули, пакеты)
        которые написаны для Nodejs(на JS) и выполняются в нем, и через его менеджер пакетов(npm) можно их загружать и 
        устанавливать(удалять). NPM - как каталог который контролирует какие модули у него уже есть. Потом можно настроить эти 
        модули так чтобы все выполнялось автоматически. А NPX - менеджер для запуска этих модулей. Получается что в рабочей папке
        кроме JS кода лежат еше програмки которые наш код в нужный момент времени преобразуют, минифицируют, компилируют, проверяют
        на ошибки и т.д.

        
    Серверным JS Nodejs называют потому что одной из программ которую можно написать для Nodejs это программа которая будет хендлить
        аштитипи запросы (handle HTTP request) - она принимает хттп запросы от клиента(браузер) формировать респонс(ответ) и
        возвращать ответ. То есть мы можем написать программу которая и будет програмным ХТТП сервером и будет работать внутри
        Nodejs. На сегодня это самая популярная задача для которой используется Nodejs.
 
*/}


{/*    ====    03. Установка Nodejs    ====

    Заходим на сайт Nodejs и скачиваем последнюю версию(ОС определяется автоматически). Устанавливаем. Проверим чтобы значек нода
        был в установленных программах.

    Лучше использовать английскую виндоус, ну в крайнем случае не называть рабочие папки на русском языке и с пробелами и не делать 
        в имени пользователя виндовс пробелов и писать тоже на английском языке. Вместо пробелов используем дефисы - . Точку в этих
        названиях тоже лучше не ставить, используем или дефис или нижнее подчеркивание.

*/}


{/*    ====    04. Create-react-app    ====

    Теперь будем устанавливать и запускать React приложение. 
    

    Реакт создали программеры из Фейсбука и его там используют. Загуглим Create-react-app - первая ссылка ведет на GitHub, перейдя
        туда видим что это некий проект. Все модули написанные под Nodejs лежат на GitHub имеют открытый код и под той или иной
        лицензией могут использоваться для своих нужд.

    Create-react-app - это такая же программа.  С помощью NPX(надстройка над npm) мы ее запустим и эта программа установит в нашу
        рабочую папку кучу всего, потянет за собой кучу пакетов, всё настроит, подготовит, а нам останется только запустить.


        
    Ниже на GitHub этого проекта Create-react-app есть инструкция - Quick Overview. Есть 3 комманды которые нужно написать в 
        Node.js command prompt - это консольная программка(найти ее можно через поиск в пуске, она установилась вместе с Nodejs).


        Запускаем эту консольную программу, по умолчанию у автора она открылась по пути C:\Users\notePad.by, поэтому нужно перейти
        в папку где у нас будет проект например D:\React-Samurai\Project-1. Сначала выберем нужный диск где лежит папка с проектом, 
        для этого просто напишем D: и нажмем ентер, нас кинет на диск Д. Потом нужно прописать cd - change directory, а дальше 
        остальной путь к папке cd React-Samurai\Project-1 - жмем ентер и перешли в рабочую папку в этом консольном окне(при вводе
        названия папки можно нажимать tab и если такая папка есть в этой директории допишет полное ее имя, или можно просто
        скопировать путь из папки в виндовсе и вставить в консоль; чтобы подняться на папку выше cd .. (cd и двоеточие через пробел))

        Написать следующие строки можно и в терминале VScode. Открыв как open folder - рабочую папку Project-1, и перейдя в нее
        способом выше(если по умолчанию не перешло) в терминале VScode(сверху вкладка New terminal чтобы его открыть).



    Теперь находясь в консоли в рабочей папке проекта пишем эти консольные команды:

        npx create-react-app my-app  (my-app - название проекта, можно писать своё) - так как мы пишем npx то кроме установки
                                        всех необъодимых модулей произойдет еще и их настройка. Жмем ентер. 
                                        
        Создается папка с названием проекта в данном случае my-app и в нее будет происходить загрузка модулей. В файле
        package.json - храниться информация об этой папке проекта как о проекте(модуле, таком же как мы устанавливаем), чтобы
        можно было его запустить в Nodejs.

        Появилась папка node_modules - каждый проект который мы устанавливаем через npm содержит такую папку, в нее сохраняются
        все пакеты(модули которые нужны нам для работы react-app)


        Установка завершилась. Видим комманды которые можно написать в середине директории(папки) my-app:
            npm start       - starts the development server

            npm run build   - bundle the app into static files for production

            npm test        - starts the test runner

            npm run eject   - removes this tool and copies build dependencies, configuration files and scripts into the app
                                directory. If you do this, you can't go back.

            
        Рекомендуют начать с перехода в папку проекта(пакета/модуля потому что для запуска нужен файл package.json) и запуска его
        через нпм:
            cd my-app
            npm start

        Видим что нпм запустил локальный сервер(он умеет принимать хттп запросы и отправлять на них респонсы), он будет отдавать нам
            наш index.html и именно в нем будет вестись наша разработка сингл пейдж аппликейшена (single page application - spa)

*/}


{/*    ====    05. Single page application - spa    ====

    Spa - одностраничное приложение.


    Очень давно жизненный цикл страницы бал такой. Traditional Page Lifecycle. Например для личных сообщений.
    При заходе на страницу бразер посылал запрос серверу(Initial request), и он в ответ присылал хтмл файл. Потом когда мы обновляли
        сайт чтобы посмотреть появилось ли например новое сообщение на форуме, браузер делал снова запрос(Form POST) - и сервер снова
        присылал этот же хтмл полностью если там не было изменений или совсем немного измененный если там были какие-то изменения, а
        браузер перезагружал полсностью страницу чтобы получить свежую версию хтмл.

                        Initial request
                        ------------------------->

                        <------HTML----JS---------
            CLIENT      Form POST                     SERVER
                        ------------------------->

            reload       <------HTML---------------


        При этом пакет ХТМЛ был большой, а следом за ним шел файл с JS очень небольшой. Сообщения раньше были сгенерированы(зашиты)
        уже в ХТМЛ как теги.

    
    Spa - загружают страницу единожды. Файл ХТМЛ приходит почти пустой, а следом большой файл JS который уже отрисовывает весь сайт.
        
                        Initial request
                        ------------------------->

                        <------HTML----JS---------
            CLIENT      AJAX                          SERVER
                        ------------------------->

                        <------JSON---------------

        Теперь сообщения могут храниться или в файле JS(очень редко), но чаще всего после получения этих файлов браузер делает
        Ajax запрос на сервер, а тот возвращает json данные(все сообщения которые есть), а JS который ранее загрузился в браузер
        берет эти данные и без перезагрузки страницы генерирует на ходу ХТМЛ. При этом для того чтобы посмотреть есть ли новые
        сообщения не нужно перезагружать страницу, а в JS есть код который время от времени опрашивает сервер и если появилось
        новое сообщение, то присылается это одно сообщение(JSON файл с сообщениями???) и под это новое сообщение на сайте 
        генерируется новый хтмл тег. При таком подходе очень разгружается сервер, экономиться много траффика, ускоряется работа
        сайта.

        При Traditional Page Lifecycle для каждой страницы, например настройки или новостная лента или моя стена, для каждой такой
        страницы был отдельный адресс и по этому адресу загружалась хтмл страница. В Spa - всегда одна страница, не нужно путать с
        лендингом, в spa мало ХТМЛ(полупустой файл) + много JS скрипта который создает динамически нужную разметку, в том числе
        не только когда мы находимся на одной странице(например - сообщения) но и когда мы кликаем на ссылку перехода на другую
        страницу этого же сайта, адрес url меняется, но фактически на сервер не идет запрос на новый хтмл, а JS перехватывает
        изменение этого url делает нужный ajax запрос на сервак - для отображения новой страницы, возвращается json и наш JS
        вытирает(удаляет) страницу "сообщения" (хтмл контент) и рисует контент для новой страницы. Если некоторые элементы на
        этих страницах одинаковые, например хедер, футер, aside то они не перерисовываются. React, angular работают по этой же
        схеме. Получается что страница генерируется на стороне клиента, разгружая сервер, и сервер по сути выступает теперь в роли
        API(эй пи ай).

        При старом формате когда сервер работал с веб страницей он работал только с ХТМЛ, а теперь когда он работает со spa, а 
        это уже как полноценная программа - веб приложение с большим кодом логики, для которого теперь нужно с основном json файлы.
        Так как json формат универсальный то при запросе таких данных сервер может отдавать json как в веб приложение(spa) так и
        в мобильное приложение, хотя там другой UI(user interface - ю ай), просто по другому эти данные обрабатываются и по другому 
        рисуется интерфейс, при этом сервер становиться универсальным.

*/}


{/*    ====    06. index.js, app, JSX    ====

    Продолжаем с конца 4го урока, после запуска реакт-апп набором этих комманд в терминале по пути рабочей папки(где создалась папка
        с проектом my-app):

        cd my-app
        npm start

        Запустился локальный сервер и открыл страничку проекта в браузере. Так как мы пока ничего не меняли то по умолчанию 
        показывается страница приветствия(та самая spa страница) с крутящимся логотипом реакта.


    
    Рассмотрим какие файлы есть в папке проекта, что нам можно изменять чтобы изменялась страница. 
        
        package.json. Папка my-app считается проектом (модулем/пакетом) когда в ней присутствует package.json.

        Папка node_modules обязательно должна быть загружена до запуске проекта. npm анализирует содержимое package.json и загружает
        необходимые для работы модули в папку node_modules. Эту папку вручную не изменяем никогда. Позже посмотрим что в нейл лежит,
        а пока забываем про нее.

        Папка public. В этой папке лежит иконка реакта для приветственной страницы. Index.html - та самая хтмл(spa)Ю которая 
        единственная существует в нашем проекте(видим что файл практичеси пустой). manifest.json.

        Папка src. На приветственной странице видим текст - Edit src/App.js and save to reload(отредактируйте файл App.js в папке
        src и сохраните для перезагрузки страницы). Смотрим что лежит в папке src: App.css, App.js, App.test.js, index.css, 
        index.js, logo.svg. 



    Заходим в App.js и видим что тут есть разметка которая и отображается сейчас на странице. Попробуем изменить текст сообщения
        например слово Edit поменять на my-app, сохраняем файл, видим что в браузере мигнула страница - видим что текст изменился
        и нам не пришлось обновлять страницу в ручную.


        Но постойте, мы редактируем хтмл теги в JS файле и этот хтмл код даже не взят в кавычки, как так. Видим что разметка эта
        находится в 

            class App extends Component { render(){ return(хтмл разметка); } } 
            
            - в следующих видео разберем что такое класс и екстендс, а сейчас разберем что происходит.


        Разработчики реакта создали язык JSX который позволяет писать хтмл внутри джаваскрипта. По факту этот хтмл это джаваскрипт,
        просто на таком синтаксисе привычнее писать человеку, а для работы в браузере этот синтаксис JSX перекомпилируется в JS. 


        Упростим разметку: 
            удалим все содержимое хтмл разметки кроме родительского дива с className="App"
            удалим строку import logo from './logo.svg';
            предполагая что мы не знаем что такое класс - заменим код на такой:

                const App = () => {  return(<divclassName="App">Simple HTML</div>); } 

                создадим переменную App и присвоим ей стрелочную ф-ю которая возвращает хтмл разметку. Автор рекомендует почитать 
                про ключевые слова создания переменных var, let, const и стрелочные ф-и, потому что тут он подробно останавливаться
                на этом не будет.


        Сохраняем файл и видим что теперь страница у нас с белым фоном(потому что слетели ксс стили так как мы удалили почти
            всю разметку) по центру(потому что стили для контейнера работают, а он был отцентрирован по центру) сверху видим надпись
            из нашего дива в разметке - Simple HTML.

        То есть содержимое файла апп.дс попадает внутрь страницы которую мы видим - разберем в следующих видео.


        Снова модифицируем код, добавим список, но забудем добавить закрывающий тег:
            
            <ul>
                <li>Some text
            </ul>

            Наш редактор кода подчеркивает красными всю разметку, и после сохранения кода, в браузере вместо страницы отобразится
            ошибка Failed to compile  - ошибка компилирования и пишет на такой то строке ожидает закрывающий тег <li>. Так 
            получается потому что это не хтмл разметка по сути(если мы в хтмл забудем закрывающий тег то браузер все равно попробует
            отобразить страницу, добавив тег за нас), а это код JS который выполнить возможно потому что он не валидный, и компилятор
            нам выдает ошибку потому что не может преобразовать наш код в JS код.


        Обратим внимание что вместо class в тегах хтмл мы пишем className по той причине что слово класс в JS коде в который будет
            преобразован этот код зарезервировано за классами.


        Допишем наш список:

            <ul>
                <li>HTML</li>
                <li>CSS</li>
                <li>JS</li>
                <li>React</li>
            </ul>

            видим что он отобразился на странице, но нам хотелось бы задать внешний вид. Смотрим в начало апп.дж файла и там есть
            строки начинающиеся с import и одна строка содержит: 

            import './App.css';

            этот файл лежит в той же папке что и наш файл - ./ и называется App.css и мы его ипортируем(добавляем в апп.дс ). 
            Зайдем в  App.css и видим стили которые были написаны для привественной страницы, удалим все эти стили и пропишем стили
            для нашего списка:

            ul li { list-style-type: georgian; }

            видим что внешний вид списка изменился(сместился влево и точку заменились на символы georgian).


        То есть сама концепция тут другая, мы работаем не в хтмл и туда добавляем ксс и JS файлы, а работаем в JS и туда импортируем
            ксс файл.


        В разметке всегда должен быть ОДИН корневой(родительский) элемент(див), а все остальное мы помещаем внутрь него.(в видео
            добавили еще див выше нашего с классНейм - апп - получилась ошибка, потом эти два дива обернули еще в тег див без
            дополнительных аттрибутов и всё заработало, то есть не обязательно что бы див с классом апп был родительским для всей
            разметки).

*/}


{/*    ====    07. Компонента    ====

    Если в кратце Компонента - это ф-я возвращающая разметку JSX( может работать и выполнять разный код, но по итогу return(ретурном)
        все равно должна вернуть разметку JSX).

    В нашем апп.дс const App и есть эта компонента, потому что ей присвоена ф-я которая возвращает разметку JSX.


    Примеры ф-й 

        function Welcome() {                - ф-я объявлена через ключевое слово function
            return <h1>Hello, there</h1>;
        }

        const Welcome = function () {       - анонимная(без названия) ф-я объявлена через function присвоенная переменной
            return <h1>Hello, there</h1>;
        }

        const Welcome = () => {             - стрелочная ф-я присвоенная переменной
            return <h1>Hello, there</h1>;
        }


        Если код находится на строке return то скобки можно не ставить: 
        
        return <h1>Hello, there</h1>;

        Если не на строке с return то нужно ставить скобки, но лучше по умолчанию ставить скобки:

        return(
            <h1>Hello, there</h1>;
            );


    Чтобы использовать ф-ю в обычном JS ее нужно вызвать (дальше по коду) - Welcome();.

    В реакте при создании ф-ии у нас появляется новый тег - в данном случае который можно вставить куда то на страницу,
        а реакт сам ее вызовет.

         <Welome />
        

    То есть теперь компонента получается - тег.
    
    *! На теперешний момент 08.2022 
    
        <Welome />  - так вставляется класс - class Welome extends React.Component {

        {Welome()}  - так ф-я(компонента)

        {Welome()}  - так переменная с колбеком??? const moves = history.map((step, move) => {



    Посмотрим наш пример, тут у нас есть const App найдем куда вставляется созданный тег этой ф-ии. В вскоде нажимаем ctrl+shift+F
        это поиск во всех файлах проекта и вбиваем в поиск <App нашло 2 результата App.test.js(этот файл не смотрим) и index.js.
        
        Помним что главный файл хтмл называется index.html и он у нас лежит в папке public, откроем его и видим что в body есть
        пустой div с id="root". Как раз внутри этого тега и будет отрисовываться всё то что мы пишем на реакте.

        Откроем index.js. Видим что тоже есть много import строк, а далее видим ф-ю(обїект???) ReactDOM у которой есть метод render.
            render(переводится - отрисовать), этот метод отрисовывает созданный в App.js тег <App />. И отрисовывается он в елементе
            который мы находим по айди Root - document.getElementById('root').

            ReactDOM.render(<App />, document.getElementById('root'));



    Для закрепления создадим еще одну компоненту.

        const Header = () => {
            return (
                <div>
                    <a>Home</a>
                    <a>News</a>
                    <a>Messages</a>
                </div>
            );
        }
        
        Она в коде есть но на странице не видна потому что не вызывалась и не была вставлена в хтмл. Что бы пока не заморачиваться
            с import вставим компоненту Header в хтмл разметку компоненты App:

            <div><Header /></div>

            теперь когда рисуется App компонента в ее хтмл коде встречается компонента Header и идет обращение к этой компоненте
            (вызывается ф-я Header она возвращает свою разметку которую отрисовывает в разметке App вместо тега <Header />)

            <div>
                <div><Header /></div>
                <div className="App">
                    <ul>
                        <li>HTML</li>
                        <li>CSS</li>
                        <li>JS</li>
                        <li>React</li>
                    </ul>
                </div>
            </div>


        Выглядит както не логично, у нас есть Header. а потом пошли какие-то liшки. Вынесем весь код для списка в отдельную 
            компоненту Technologies и просто поместим ее в компоненту App которая будет все отрисовывать. Удалим класснейм потому 
            что он нам не нужен, он нужен был для стилей которые были в приветственной странице. Также удалим дивы вокруг хедера так 
            как можно и без них - они лишние.

            const App = () => {
                return (
                    <div>
                        <Header />
                        <Technologies />
                    </div>
                );
            }

            const Header = () => {
                return (
                    <div>
                        <a>Home</a>
                        <a>News</a>
                        <a>Messages</a>
                    </div>
                );
            }

            const Technologies = () => {
                return (
                    <div>
                        <ul>
                            <li>HTML</li>
                            <li>CSS</li>
                            <li>JS</li>
                            <li>React</li>
                        </ul>
                    </div>
                );
            }

            Теперь наша компонента App которая отрисовывается состоит из двух компонент которые мы подключили тегами в нее. Код стал
            более читабельным, осмысленным(логическим) и семантически правильным.

*/}


{/*    ====    08. import, export - теория    ====

    Так как компонент будет очень много, и они могут в себе содержать еще компоненты, то мы их разобьем на разные файлы для лучшей
        читабельности. Но для того чтобы оно потом работало вместе нужно

    ПРИМЕР.
    Есть 4 файла
        main.js     - одна ф-я которая вызывается - openAllMaps();
        maps.js     - let openAllMaps = ()=>{openGoogle(); openYandex();}
        google.js   - подключается к гугл карте и показывает ее. В ней одна ф-я(компонента) - openGoogle
        yandex.js   - подключается к яндекс карте и показывает ее. В ней одна ф-я(компонента) - openYandex


        Автор утверждает что создав таким образом глобальные переменные в JS коде, они будут видны в других файлах(если так как
            сейчас написано - нет не будут) и поэтому при работе с ними могут возникнуть проблемы, например если две переменные с
            одинаковым именем то одна может затереть другую и будет использована только одна.


            Реакт же использует модульность(модульный подход) - все const, let которые объявлены в одном фале, остаются видимы 
            только в этом файле, что позволяет избежать таких проблем. Для связи таких файлов используем import. Например сделаем
            импорт в файле main.js ф-и openGoogle из google.js по относительному пути к файлу в который испортируем.

            import openGoogle from './google.js';  - этот файл лежит в той же папке где и файл в который импортируем(./) 
            import openYandex from './../yandex.js'; - этот файл лежит на уровень вложенности выше(../)
            

            А в main.js теперь нужно импортировать openAllMaps из maps.js.

            import openAllMaps from './maps';     - расширение файла можно не указывать


            Чтобы import работал нужно в файле который отдает компоненту ее экспортировать - export. То есть в файле google.js:

            export default openGoogle;


            Есть несколько видов импорта/экспорта мы пока будем работать с таким. Когда мы делаем экспорт по дефолту(default) мы
            из файла можем экспортировать что то одно.
            
        *! Рекомендует прочитать про модуль амд - modules AMD require.js после просмотра этого видео или перед собеседованием.



    Посмотрим на наш файл App.js. Видим что есть:
    
        import './App.css'; - испортируются стили из ксс файла, поэтому нету from

        import React, { Component } from 'react';  - тут видим что испорт идет не из файла, а из модуля реакт который лежит в 
                                                    папке node_modules поэтому нету пути к файлу.


    Смотрим в index.js , тут мы отрисовываем компоненту апп, но она в другом файле, значите ее нужно импортировать:

        import App from './App';

*/}


{/*    ====    09. import, export наших компонент    ====

    Создаем файлы для Header Technologies и переносим туда код по принадлежности, в этих файлах прописываем:

        export default Header/Technologies


    а в App.js пропишем импорты:

        import Header from './Header.js';
        import Technologies from './Technologies.js';


    Сохраняем. Запускаем проект и нам выкидывает ошибку 'React' must be in scope when using JSX, что означает что в новых файлах для
        того чтобы использовать JSX(наша верстка в компонентах) нужно импортировать реакт в эти файлы.

        import React from 'react';  - (, { Component } - это мы удалили потому что class не используем, а используем ф-ю компоненту).

*/}


{/*    ====    10. default опасность, плагин auto import    ====

    В Апп.дс закомментируем строку ипорта Header и сам тег Header в хтмл разметке. Смотрим на сайт - хедер пропал, показывается
        только Technologies.


    Теперь в import Technologies заменим файл из которого импортируется на Header.
    
        import Technologies from './Header.js';

        Смотрим на сайт, а вместо наших технологий отрисовывается Header хотя мы импортировали Technologies, такое поведение
        получается из-за дефолта(default) - при этом нету привязки к конкретному имени экспорта, и при импорте то что экспортировали
        называется как записано в импорте, но так как мы все равно будем его использовать нужно быть очень внимательными при
        импорте.



    При импорте будет использовано очень много файлов и у них могут быть сложные пути, чтобы нам облегчить этот процесс можно 
        поставить в VSCode плагин - "Auto Import", после установки нужно нажать кнопку для перезагрузки VSCode. Он работает не
        так круто как в Web Storm, но теперь когда мы начинаем писать тег с компонентой которую нужно импортировать, высвечивается
        подсказка - Auto Import - клацнув по ней в верхней части кода добавляется импорт этой компоненты из файла. 

        Сначала плагин может не работать, нужно или время для скана или создать в новом файле новую компоненту и тогда запустится
        скан, и плагин будет работать. Но нужно все равно проверять из какого файла идет импорт.

*/}


{/*    ====    11. Соц. сеть. Шаг 1(вёрстка, grid)     ====

    Все компоненты нужно называть с большой буквы чтобы измежать совпадений с названиями тегов ХТМЛ.


    Начнем с верстки макета, у нас будет 3 блока Хедер, боковая меню, и контент справа от сайдбара под хедером.

    Верстать будем на grid(только появившемся на то время). Так как автор сам учил в видео гриды он решил начать делать проект в
        одном файле.  В главный див накидаем теги которые будут отвечать за секции, а потом их уже заполним.

        return (
            <div>
                <header><img src="https://th.bing.com/th/id/OIP.PBVmERenoA81uh26kHU04QHaHa?pid=ImgDet&rs=1" /></header>
                <nav>Menu navigation</nav>
                <main>Main Content</main>
            </div>
        );

        Видим что появился большой логотип и надписи Menu navigation и Main Content все располагается одно под одним потому что
        элементы блочные.

    Для родительского эл. задаим класс app-wrapper, также добави классы для всех элементов.

        return (
            <div className="app-wrapper">
                <header className="header"><img src="https://th.bing.com/th/id/OIP.PBVmERenoA81uh26kHU04QHaHa?pid=ImgDet&rs=1" /></header>
                <nav classname="nav">Menu navigation</nav>
                <main className="content">Main Content</main>
            </div>
        );

        теперь можем обратиться к ним из ксс файла и задать ксс свойства. Для app-wrapper задать display: grid; и количество колонок,
        а для элементов размеры и имена для грид эреа темплейт.

        .app-wrapper{
            display: grid;

            grid-template-areas: 
            "header header"
            "nav content";
            
            grid-template-columns: 2fr 10fr;
            grid-template-rows: 60px 1fr;

        }

        .header{
            grid-area: header;
            background: rgb(1, 30, 37);
        }

        .header img{
            max-width: 50px;
        }

        .nav {
            grid-area: nav;
            background: rgb(252, 13, 13);
        }

        .content{
            grid-area: content;
            background: rgb(19, 72, 218);
        }

        почему то цвет фона у .nav наследовался от body, пришлось записать просто как nav


    Добавим меню в сайдбар.

        <nav classname="nav">
          <ul>
            <li><a href="#">Profile</a></li>
            <li><a href="#">Messages</a></li>
            <li><a href="#">News</a></li>
            <li><a href="#">Music</a></li>
            <li><a href="#">Settings</a></li>
          </ul>
        </nav>
        
    
    В контенте у нас должна быть хедер картинка на всю ширину, ниже аватарка, справа от аватарки данные пользователя(имя, данные),
        ниже будет блок - надпись My Posts + ниже поле для ввода, а еще ниже будут сообщения. Grid использовали для общего макета
        сайта, для расстановки элементов в content будем пользоваться другими технологиями например flexbox. Автор каждый блок 
        оборачивает в div чтобы обозначить блоки которые будут, и не заморачиваться с версткой. Пока оставили схематическую верстку
        без причёсывания в ксс.


    Рекомендует изучить grid потому что мы хотим не просто владеть инструментом реакт, а быть трендовыми фронтенд разрабочиками.
    
*/}


{/*    ====    12. Соц. сеть. Шаг 2(разбивка на компоненты)     ====

    Разобьем проект на компоненты и выделим подкомпоненты. Создадим для них папку components в папке src. 
    
    Для хедера создаем файл Header.jsx - такое расширение чтобы сразу было видно что это компонент, а не просто JS сервис, файл или
        логика. Прописываем import React from 'react'; далее создаем наш компонент - ф-ю Header и помещаем туда верстку для хедера 
        из файла Апп. Прописываем export default Header;. А в файле Апп вместо разметки хедера ставим тег <Header /> (сейчас тег 
        выглядит так { Header() } ), и прописываем - import Header from './components/Header'

    Тоже самое делаем с Navbara.

    Так как у нас страницы контента будут разные: Profile, Messages, News, Music, под каждую файл назовем соответствующе, потому
        что разметка у них будет отличаться. Та разметка которая у нас есть сейчас будет относиться к Profile. Так и назовем файл и
        компонент в нем.

*/}


{/*    ====    13. git-репозиторий     ====

    Автор создал репозиторий на гитхабе, можно его клонировать себе. Для этого в папку куда будем клонировать, открываем для нее 
        терминал умтановленного гита(git Bash here - выбираем из списка после клика правой кнопкой в папке куда будем клонировать
        репозиторий), и в нем пишем git clone adress(вместо адресса вставляем хттпс адресс к репозиторию) После клонирования у нас 
        отсутствует папка с модулями, потому что он большая и заливать ее на гитхаб не стоит(будет долго обновляться проект как 
        минимум), она прописана в файле гитигнор чтобы когда у нас будет папка с модулями она не отправилась на заливку. 

    Так как мы смотрим уже когда в репозитории весь проект готов, нужно откатиться на предыдущую версию соответствующую коду в
        конкретном уроке. Это можно сделать открыв в папке проекта git Bash here терминал(консоль) и пишем комманду
        gitk --all&   жмем ентер, открывается графический интерфейсВ котором есть коммиты с номерами уроков. Чтобы откатится к
        определенному коммиту нужно на него кликнуть и под окном с коммитом отобразиться для него код SHA ID, его копируем при
        помощи ctrд + insert(ctrl+C - не работает), возвращаемся в консоль и пишем git checkout copied_ID(вместо copied_ID надо
        при помощи shift + insert, вставить скопированный айди) - жмем ентер. 
        
        Может выскочить ошибка если уже немного поигралис репозиторием на счет того что сделанные изменения нужно или закоммитить 
        или удалить. Автор предлагает удалить файл package-lock потом повторно ввести комманду и мы ереключимся на нужный коммит. 
        Ни в коем случае не нужно трогать код, просто смотреть его, а то будут проблемы при переключении на следующие коммиты. 
        Если всетаки мы сделали какие то изменения нужно их удалить пишем git status - красным покажется в каком файл изменения
        далее пишем git checkout src/App.js( git checkout + путь к измененному файлу), изменения удаляться и можно снова прыгать
        по коммитам. 

    Откроем склонированную папку проекта в ВСкоде, запустим терминал и если прописать npm start то проект не стартанет так как нету
        модулей. Что бы их установить пропишем npm install при этом npm  посмотрив в package.json какие модули нужно установить для
        данного проекта и установит их автоматически в папку node_modules.

    Если мы будем устанавливать дополнительные модули, то чтобы они у нас потом тоже автоматически подгружались нужно после их
        установки делать save(npm save - наверное, автор не сказал как правильно пишеться), при этом в package.json добавиться 
        зависимость для этого модуля.

*/}


{/*    ====    14. css modules     ====

    Мы должны знать БЭМ методологию, хотя бы основные понятия, потому что будем придерживаться похожей концепции, но реализовывать
        будем не самостоятельно, а это будет автоматически делать Create React app.

    К картинке лого мы обращались в ксс файле через вложенность .header img{ , если так не сделать то стили для просто img{ 
        применятся ко всем картинкам на проекте. Если бы мы делали по БЭМ нам нужно было бы написать класс .header__img{ и его
        прцепить к картинке, в этом тоже есть свой недостаток, нужно лезть в верстку того элемента и прописывать там классНейм.
        А нам хочется чтобы названия классов были какими то простыми, чтобы не писать длинные классы и модули позволяют нам этого
        добиться.

    Рассмотрим на примере Навбара, присвоим каждой лишке класс item, это короткое название для класса, но оно может часто 
        встречаться в проекте и нам бы хотелось чтобы мы об этом не думали и поэтому также как мы разнесли код JS по файлам
        также разнесем и ксс код по своим файлам с такими же названиями в папке src.
            
        <ul>
            <li className="item"><a href="#">Profile</a></li>
            <li className="item"><a href="#">Messages</a></li>
            <li className="item"><a href="#">News</a></li>
            <li className="item"><a href="#">Music</a></li>
            <li className="item"><a href="#">Settings</a></li>
        </ul>

        В каждый файл компонента jsx теперь пропишем импорт соответственного файла ксс, например в Header.jsx пропишем 
            import './Header.css' .


    Для постов допусти тоже задали класс айтем  

        <div className="item">
            Post 1
        </div>
        <div className="item">
            Post 2
        </div>

        в ксс навбар присвоим айтемам навбара цвет черный и видим что item в Portfolio тоже сменили цвет на черный

        .item{
            color: black;
        }

    Почему так происходит, загляним во вкладку Network(сеть) панели разработчиков, у автора там нету никаких ксс файлов(у меня есть
        так как я подключал в файле индекс.хтмл эти все ксс файлы) но есть такой файл как bundle.js - это тот файл в который
        превращаются(собираются) все наши jsx файлы и Апп.дс тоже. Все ксс файлы которые импортируются таким образом добавляются
        через JS код в head index.html файла и они получаются все равно связаны и становятся глобальными, тоесть нету инкапсуляции.
        
        Инкапсуляции можно достичь добавили module в название файла ксс, тоесть Navbar.module.css , теперь этот файл ведет себя 
        иначе, и работать с ним нам надо иначе, теперь импорт будет выглядеть таким образом

            import classes from './Navbar.module.css';  (classes - можно называть как нравиться)

        верстка сломалась, смотрим в head документа и видим что теперь вместо item у нас есть Navbar_item__3qaF3 и если мы в верстке
        заменим item на Navbar_item__3qaF3 то стили к нему применятся. Но это еще более неудобно, и что бы так не делать мы будем
        работать с импортируемым ОБЪЕКТОМ classes. У него есть свойства "ключ" : "значение" - ключи будут - названия стилей которые
        мы писали в ксс файле, тоесть классы - .nav, .item, только без точки, а значением будет как раз автоматически сгенерированые
        классы - Navbar_item__3qaF3. И теперь в разметку нужно присваивать объект:

            <div className={classes.nav}


    Для глобальных классов например для body мы App.css в модуль НЕ превращаем. Можно оставить и для других файлов ксс обычные
        стили если нам не трудно придумывать уникальные имена для тегов. Если внутри модульного ксс будет вложенность .header img{
        то программа header переделает в новый нужный тег и сохранит путь к этой картинке таким образом. Медиазапросы тоже
        подхватываются.


    При такой модульности не стоит называть классы через дефис item-nav, из-за допустимых названий свойств объекта в  JS, потому что
        тогда к ним нужно обращаться прописывая кавычки и квадратные скобки, а это не удобно. Лучше слитно, или камел кейсом, 
        или через нижнее подчеркивание.

        <div className={classes["item-nav"]}

    
    Если хотим дать тегу два стиля например <div className="item active" мы бы в ксс написали если у тега два класса тогда цвет будет
        золотой и цвет активной ссылки был бы золотым  -  .item .acive{color:gold;}.  А теперь часть этой строки с классами у нас
        сидит в значении свойства объекта, то теперь нам нужно использовать бектики для вставки в строку двух значений свойств 
        объекта, а свойство active - появиться в объекте потому что в реакт прочитает модульный ксс и увидит что в записи 
        .item .acive{ - два класса и оба их добавит.

        <div className="item active"

        <div className={`${classes.item} ${classes.active}`}


    Чтобы увидеть что лежит в объекте можно его вывести в консоль в том же файле jsx куда он импортируется.


    Если нам нужны будут стили для общих элементов мы рассмотрим это в следующих видео.

*/}


{/*    ====    15. Структура папок, новые компоненты, улучшаем css     ====

    Компонентов в проекте будет очень много и если будем их складывать все просто в папку components то очень быстро будет трудно 
        искать нужные файлы, поэтому структурируем файлы. Если у нас есть несколько файлов относящихся к какому то компоненту то
        делаем папку с названием этих компонентов и складывает туда файлы. Например в папке components делаем папку Header и туда
        складываем Header.jsx + Header.module.css , при этом конечно ломаются пути импорта и нужно будет их обновить. При
        перетаскивании в ВСкоде файлов в новые папки, он предлагает обновить импорты (хотя может это делает плагин move TS или 
        сами модули Реакта).


    Теперь нужно поработать с компонентом Profile, разбить его на подкомпоненты создадим компонент My Posts и для него компонент
        post который будет отвечать за один пост(сообщение). Для этого в Profile создаем папку My Posts а в ней папку Post. 
        
        В My Posts скопируем файлы Profilе.jsx и Profile.module.css и переименуем их в MyPosts.jsx и MyPosts.module.css. 
        
        В MyPosts.jsx переназначим импорт для  MyPosts.module.css и сменим название компонента на MyPosts и удаляем все теги до тегов
        с постами, также переназовем экспорт под название компонента. 
        
        В MyPosts.module.css оставляем только класс item потому что класс content относится к вышестоящей разметке которой в 
        MyPosts.jsx нету. 
        
        А из Profile.module.css наоборот удалим item. А из Profilе.jsx удалим разметку с постами и добавим на ее место тег 
        компонента <MyPosts /> и соответственно нужно  проконтролировать добавление import на этот компонент.


    В разметке MyPosts.jsx видим что дивы с постами выглядят одинаково но с разным текстом, так что можно вынести в отдельный 
        комопнент. Предварительно добавим еще картинку пользователя написавшего пост <img>, этот аватар будет у каждого поста, для 
        него нужно будет писать класс, а там еще добавяться кнопки лайк/дизлайк и в итоге когда постов будет много это будет
        огромная работа по копированию. Чтобы такого избежать мы и выносим общий вид(разметку) поста в отдельный компонент, он
        будет строиться по общим правилам но изменять свои свойства типа текста и аватара пользователя.

        Снова переносим более глобальный(полный) компонент MyPosts в дочернюю папку Post, изменяем файлам соответсвенно названия.
    
        В  Post.jsx изменяем импорт под ксс модуль, название компонента и удаляем лишнюю разметку - оставляем 1 пост, меняем название
        экспорта.

        В MyPosts.module.css удаляем стили для класса item и всё что связано с тегом пост.

        В MyPosts.jsx - удаляем верстку с постами и добавим несколько тегами <Post />, также смотрим чтобы был импорт из Post

    
    Теперь можем менять внешний вид всех постов сразу работая в одном файле.


    Но текст у постов одинаковый, а должен быть разный текст который изменялся бы от принятых данных. Это мы рассмотрим в следующих
        уроках.

*/}