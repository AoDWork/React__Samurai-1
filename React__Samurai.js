    //============================================  React Samurai 1.0   ===========================================================
    
    /* После прохождения курса автор общает знания реакта для позиции солидного джуна, следующий курс 2.0 сделает нас солидным
                мидлом, но это уже после того как произойдет трудоустройство. Курс находится на ютубе по ссылке
                        https://courses.prometheus.org.ua/courses/course-v1:LITS+114+2022_T2/about                       */


    
{/*    ====    01. Как проходить курс     ====

    Изучаем react + Redux потому что это самая популярная связка для трудоустройства(на 2020 год).


    На верстку забиваем, вестаем - "абы було", в уроках изобретаем свой redux(24-41) потом изучаем обычный(42), также изобретам свой
        connect(43-44) в redux, потом смотрим редаксовский(45). Делается это для того что бы знать как все происходит внутри, не 
        абстрагируясь от сложных вещей JS.

        44 - просто ознакомиться что он есть, не записывая, держать в голове что connect работает через context API и забить.

        Начиная с connect - так как оно должно быть в продакшене.
    
        Взаимодействие с сервером бесплатное до какого то лимита. Что бы было безлим нужно кинуть копеечку автору. Решение некторых
            трудностей с запросами есть на сайте на который делаем запросы.

        53 - классовые компоненты. В 2020м стало возможно пользоваться хуками, но тогда еще на них все не перешли потому что прогеры
            очень инертны, также будем это учить потому что в Angular классовые компоненты и нужно это понимать.
        
        82 - селекторы не раскрыта полностью тема. Более лучше будет раскрыта в путь самурая 2.0.

        95 - делаем свой пейджинатор, а не используем готовый в учебных целях.


    Ведем конспект.


    Работаем в VSCode или Web Shtorme.


    Каждую неделю пересматриваем 100 урок, для визуализации полной картины что мы будем учить в целом и где находимся сейчас, а также
        для запоминания терминов.
     

    После прохождения курса обязательно идем на собеседования, 4 проваливаем на 5м устраиваемся на работу. После каждого собеседования
        составляем список вопросов на которые на смог ответить и учить их.
    
*/}


{/*    ====    02. Для чего Nodejs фронтенду     ====

    Изначально JS был создан для того чтобы выполнятся в браузере и делать какие то действия с хтмл + ксс, теперь оно так и осталось.


    Позже для работы с файловой системой компьютера и базами данных была создана программа Nodejs. Код для Nodejs также пишеться на
        JS передается в Nodejs и там выполняется(при выполнении в Nodejs код не имеет доступа к сайтам, а в браузере наоборот - 
        имеет доступ к сайтам но не может работать с файловой системой компьютера и программами). 

        И гугл хром и Nodejs используют движок V8, браузер дополняет V8 своими компонентами API(например хтмл элементы, ДОМ модель,
        события), а программа написаная для Nodejs взаимодействует с ОС(программы, девайсы(вебка, микрофон)), файловой системой, 
        базой данных. И браузер и Nodejs понимает, интерпретирует+ компилирует JS.

    
    Для чего Nodejs(программа, платформа в которой выполняетс JS код) нужен фронтенд разработчику: работа с файловой системой, 
        базой данных, Nodejs можно установить в микроконтроллер и написать код на JS чтобы например обслаживать холодильник(показ
        температуры, сигнал когда открыта дверь).

        Для удобства разработки(автоматизации процесса) - мы пишем код для браузера, потом готовим его для загрузки в браузер:
        компилируем (например из sass в css), бандлы создаем, склеиваем все JS файлы, минифицируем их, склеиваем картинки в спрайты.
        То есть перед отправкой программы в браузер мы делаем много дополнительных задач. Также для удобства разработки хотим чтобы
        не сохранять код постоянно, а в браузере делать оьновление страницы, а чтобы это было автоматически. Сегодня мы даже можем
        писать на другом языке который превращается в JS код и потом запускается в браузере(например в React пишем на языке JSX
        который должен превратиться в понятный браузеру язык). 
        
        Для того чтобы у всей комманды был одинаковый процесс всего этого нужно использовать сторонние программы(модули, пакеты)
        которые написаны для Nodejs(на JS) и выполняются в нем, и через его менеджер пакетов(npm) можно их загружать и 
        устанавливать(удалять). NPM - как каталог который контролирует какие модули у него уже есть. Потом можно настроить эти 
        модули так чтобы все выполнялось автоматически. А NPX - менеджер для запуска этих модулей. Получается что в рабочей папке
        кроме JS кода лежат еше програмки которые наш код в нужный момент времени преобразуют, минифицируют, компилируют, проверяют
        на ошибки и т.д.

        
    Серверным JS Nodejs называют потому что одной из программ которую можно написать для Nodejs это программа которая будет хендлить
        аштитипи запросы (handle HTTP request) - она принимает хттп запросы от клиента(браузер) формировать респонс(ответ) и
        возвращать ответ. То есть мы можем написать программу которая и будет програмным ХТТП сервером и будет работать внутри
        Nodejs. На сегодня это самая популярная задача для которой используется Nodejs.
 
*/}


{/*    ====    03. Установка Nodejs    ====

    Заходим на сайт Nodejs и скачиваем последнюю версию(ОС определяется автоматически). Устанавливаем. Проверим чтобы значек нода
        был в установленных программах.

    Лучше использовать английскую виндоус, ну в крайнем случае не называть рабочие папки на русском языке и с пробелами и не делать 
        в имени пользователя виндовс пробелов и писать тоже на английском языке. Вместо пробелов используем дефисы - . Точку в этих
        названиях тоже лучше не ставить, используем или дефис или нижнее подчеркивание.

*/}


{/*    ====    04. Create-react-app    ====

    Теперь будем устанавливать и запускать React приложение. 
    

    Реакт создали программеры из Фейсбука и его там используют. Загуглим Create-react-app - первая ссылка ведет на GitHub, перейдя
        туда видим что это некий проект. Все модули написанные под Nodejs лежат на GitHub имеют открытый код и под той или иной
        лицензией могут использоваться для своих нужд.

    Create-react-app - это такая же программа.  С помощью NPX(надстройка над npm) мы ее запустим и эта программа установит в нашу
        рабочую папку кучу всего, потянет за собой кучу пакетов, всё настроит, подготовит, а нам останется только запустить.


        
    Ниже на GitHub этого проекта Create-react-app есть инструкция - Quick Overview. Есть 3 комманды которые нужно написать в 
        Node.js command prompt - это консольная программка(найти ее можно через поиск в пуске, она установилась вместе с Nodejs).


        Запускаем эту консольную программу, по умолчанию у автора она открылась по пути C:\Users\notePad.by, поэтому нужно перейти
        в папку где у нас будет проект например D:\React-Samurai\Project-1. Сначала выберем нужный диск где лежит папка с проектом, 
        для этого просто напишем D: и нажмем ентер, нас кинет на диск Д. Потом нужно прописать cd - change directory, а дальше 
        остальной путь к папке cd React-Samurai\Project-1 - жмем ентер и перешли в рабочую папку в этом консольном окне(при вводе
        названия папки можно нажимать tab и если такая папка есть в этой директории допишет полное ее имя, или можно просто
        скопировать путь из папки в виндовсе и вставить в консоль; чтобы подняться на папку выше cd .. (cd и двоеточие через пробел))

        Написать следующие строки можно и в терминале VScode. Открыв как open folder - рабочую папку Project-1, и перейдя в нее
        способом выше(если по умолчанию не перешло) в терминале VScode(сверху вкладка New terminal чтобы его открыть).



    Теперь находясь в консоли в рабочей папке проекта пишем эти консольные команды:

        npx create-react-app my-app  (my-app - название проекта, можно писать своё) - так как мы пишем npx то кроме установки
                                        всех необъодимых модулей произойдет еще и их настройка. Жмем ентер. 
                                        
        Создается папка с названием проекта в данном случае my-app и в нее будет происходить загрузка модулей. В файле
        package.json - храниться информация об этой папке проекта как о проекте(модуле, таком же как мы устанавливаем), чтобы
        можно было его запустить в Nodejs.

        Появилась папка node_modules - каждый проект который мы устанавливаем через npm содержит такую папку, в нее сохраняются
        все пакеты(модули которые нужны нам для работы react-app)


        Установка завершилась. Видим комманды которые можно написать в середине директории(папки) my-app:
            npm start       - starts the development server

            npm run build   - bundle the app into static files for production

            npm test        - starts the test runner

            npm run eject   - removes this tool and copies build dependencies, configuration files and scripts into the app
                                directory. If you do this, you can't go back.

            
        Рекомендуют начать с перехода в папку проекта(пакета/модуля потому что для запуска нужен файл package.json) и запуска его
        через нпм:
            cd my-app
            npm start

        Видим что нпм запустил локальный сервер(он умеет принимать хттп запросы и отправлять на них респонсы), он будет отдавать нам
            наш index.html и именно в нем будет вестись наша разработка сингл пейдж аппликейшена (single page application - spa)

*/}


{/*    ====    05. Single page application - spa    ====

    Spa - одностраничное приложение.


    Очень давно жизненный цикл страницы бал такой. Traditional Page Lifecycle. Например для личных сообщений.
    При заходе на страницу бразер посылал запрос серверу(Initial request), и он в ответ присылал хтмл файл. Потом когда мы обновляли
        сайт чтобы посмотреть появилось ли например новое сообщение на форуме, браузер делал снова запрос(Form POST) - и сервер снова
        присылал этот же хтмл полностью если там не было изменений или совсем немного измененный если там были какие-то изменения, а
        браузер перезагружал полсностью страницу чтобы получить свежую версию хтмл.

                        Initial request
                        ------------------------->

                        <------HTML----JS---------
            CLIENT      Form POST                     SERVER
                        ------------------------->

            reload       <------HTML---------------


        При этом пакет ХТМЛ был большой, а следом за ним шел файл с JS очень небольшой. Сообщения раньше были сгенерированы(зашиты)
        уже в ХТМЛ как теги.

    
    Spa - загружают страницу единожды. Файл ХТМЛ приходит почти пустой, а следом большой файл JS который уже отрисовывает весь сайт.
        
                        Initial request
                        ------------------------->

                        <------HTML----JS---------
            CLIENT      AJAX                          SERVER
                        ------------------------->

                        <------JSON---------------

        Теперь сообщения могут храниться или в файле JS(очень редко), но чаще всего после получения этих файлов браузер делает
        Ajax запрос на сервер, а тот возвращает json данные(все сообщения которые есть), а JS который ранее загрузился в браузер
        берет эти данные и без перезагрузки страницы генерирует на ходу ХТМЛ. При этом для того чтобы посмотреть есть ли новые
        сообщения не нужно перезагружать страницу, а в JS есть код который время от времени опрашивает сервер и если появилось
        новое сообщение, то присылается это одно сообщение(JSON файл с сообщениями???) и под это новое сообщение на сайте 
        генерируется новый хтмл тег. При таком подходе очень разгружается сервер, экономиться много траффика, ускоряется работа
        сайта.

        При Traditional Page Lifecycle для каждой страницы, например настройки или новостная лента или моя стена, для каждой такой
        страницы был отдельный адресс и по этому адресу загружалась хтмл страница. В Spa - всегда одна страница, не нужно путать с
        лендингом, в spa мало ХТМЛ(полупустой файл) + много JS скрипта который создает динамически нужную разметку, в том числе
        не только когда мы находимся на одной странице(например - сообщения) но и когда мы кликаем на ссылку перехода на другую
        страницу этого же сайта, адрес url меняется, но фактически на сервер не идет запрос на новый хтмл, а JS перехватывает
        изменение этого url делает нужный ajax запрос на сервак - для отображения новой страницы, возвращается json и наш JS
        вытирает(удаляет) страницу "сообщения" (хтмл контент) и рисует контент для новой страницы. Если некоторые элементы на
        этих страницах одинаковые, например хедер, футер, aside то они не перерисовываются. React, angular работают по этой же
        схеме. Получается что страница генерируется на стороне клиента, разгружая сервер, и сервер по сути выступает теперь в роли
        API(эй пи ай).

        При старом формате когда сервер работал с веб страницей он работал только с ХТМЛ, а теперь когда он работает со spa, а 
        это уже как полноценная программа - веб приложение с большим кодом логики, для которого теперь нужно с основном json файлы.
        Так как json формат универсальный то при запросе таких данных сервер может отдавать json как в веб приложение(spa) так и
        в мобильное приложение, хотя там другой UI(user interface - ю ай), просто по другому эти данные обрабатываются и по другому 
        рисуется интерфейс, при этом сервер становиться универсальным.

*/}


{/*    ====    06. Index.js, app, JSX    ====

    Продолжаем с конца 4го урока, после запуска реакт-апп набором этих комманд в терминале по пути рабочей папки(где создалась папка
        с проектом my-app):

        cd my-app
        npm start

        Запустился локальный сервер и открыл страничку проекта в браузере. Так как мы пока ничего не меняли то по умолчанию 
        показывается страница приветствия(та самая spa страница) с крутящимся логотипом реакта.


    
    Рассмотрим какие файлы есть в папке проекта, что нам можно изменять чтобы изменялась страница. 
        
        package.json. Папка my-app считается проектом (модулем/пакетом) когда в ней присутствует package.json.

        Папка node_modules обязательно должна быть загружена до запуске проекта. npm анализирует содержимое package.json и загружает
        необходимые для работы модули в папку node_modules. Эту папку вручную не изменяем никогда. Позже посмотрим что в нейл лежит,
        а пока забываем про нее.

        Папка public. В этой папке лежит иконка реакта для приветственной страницы. Index.html - та самая хтмл(spa)Ю которая 
        единственная существует в нашем проекте(видим что файл практичеси пустой). manifest.json.

        Папка src. На приветственной странице видим текст - Edit src/App.js and save to reload(отредактируйте файл App.js в папке
        src и сохраните для перезагрузки страницы). Смотрим что лежит в папке src: App.css, App.js, App.test.js, index.css, 
        index.js, logo.svg. 



    Заходим в App.js и видим что тут есть разметка которая и отображается сейчас на странице. Попробуем изменить текст сообщения
        например слово Edit поменять на my-app, сохраняем файл, видим что в браузере мигнула страница - видим что текст изменился
        и нам не пришлось обновлять страницу в ручную.


        Но постойте, мы редактируем хтмл теги в JS файле и этот хтмл код даже не взят в кавычки, как так. Видим что разметка эта
        находится в 

            class App extends Component { render(){ return(хтмл разметка); } } 
            
            - в следующих видео разберем что такое класс и екстендс, а сейчас разберем что происходит.


        Разработчики реакта создали язык JSX который позволяет писать хтмл внутри джаваскрипта. По факту этот хтмл это джаваскрипт,
        просто на таком синтаксисе привычнее писать человеку, а для работы в браузере этот синтаксис JSX перекомпилируется в JS. 


        Упростим разметку: 
            удалим все содержимое хтмл разметки кроме родительского дива с className="App"
            удалим строку import logo from './logo.svg';
            предполагая что мы не знаем что такое класс - заменим код на такой:

                const App = () => {  return(<divclassName="App">Simple HTML</div>); } 

                создадим переменную App и присвоим ей стрелочную ф-ю которая возвращает хтмл разметку. Автор рекомендует почитать 
                про ключевые слова создания переменных var, let, const и стрелочные ф-и, потому что тут он подробно останавливаться
                на этом не будет.


        Сохраняем файл и видим что теперь страница у нас с белым фоном(потому что слетели ксс стили так как мы удалили почти
            всю разметку) по центру(потому что стили для контейнера работают, а он был отцентрирован по центру) сверху видим надпись
            из нашего дива в разметке - Simple HTML.

        То есть содержимое файла апп.дс попадает внутрь страницы которую мы видим - разберем в следующих видео.


        Снова модифицируем код, добавим список, но забудем добавить закрывающий тег:
            
            <ul>
                <li>Some text
            </ul>

            Наш редактор кода подчеркивает красными всю разметку, и после сохранения кода, в браузере вместо страницы отобразится
            ошибка Failed to compile  - ошибка компилирования и пишет на такой то строке ожидает закрывающий тег <li>. Так 
            получается потому что это не хтмл разметка по сути(если мы в хтмл забудем закрывающий тег то браузер все равно попробует
            отобразить страницу, добавив тег за нас), а это код JS который выполнить возможно потому что он не валидный, и компилятор
            нам выдает ошибку потому что не может преобразовать наш код в JS код.


        Обратим внимание что вместо class в тегах хтмл мы пишем className по той причине что слово класс в JS коде в который будет
            преобразован этот код зарезервировано за классами.


        Допишем наш список:

            <ul>
                <li>HTML</li>
                <li>CSS</li>
                <li>JS</li>
                <li>React</li>
            </ul>

            видим что он отобразился на странице, но нам хотелось бы задать внешний вид. Смотрим в начало апп.дж файла и там есть
            строки начинающиеся с import и одна строка содержит: 

            import './App.css';

            этот файл лежит в той же папке что и наш файл - ./ и называется App.css и мы его ипортируем(добавляем в апп.дс ). 
            Зайдем в  App.css и видим стили которые были написаны для привественной страницы, удалим все эти стили и пропишем стили
            для нашего списка:

            ul li { list-style-type: georgian; }

            видим что внешний вид списка изменился(сместился влево и точку заменились на символы georgian).


        То есть сама концепция тут другая, мы работаем не в хтмл и туда добавляем ксс и JS файлы, а работаем в JS и туда импортируем
            ксс файл.


        В разметке всегда должен быть ОДИН корневой(родительский) элемент(див), а все остальное мы помещаем внутрь него.(в видео
            добавили еще див выше нашего с классНейм - апп - получилась ошибка, потом эти два дива обернули еще в тег див без
            дополнительных аттрибутов и всё заработало, то есть не обязательно что бы див с классом апп был родительским для всей
            разметки).

*/}


{/*    ====    07. Компонент    ====

    Если в кратце Компонент - это ф-я возвращающая разметку JSX( может работать и выполнять разный код, но по итогу return(ретурном)
        все равно должна вернуть разметку JSX).

    В нашем апп.дс const App и есть эта компонент, потому что ей присвоена ф-я которая возвращает разметку JSX.


    Примеры ф-й 

        function Welcome() {                - ф-я объявлена через ключевое слово function
            return <h1>Hello, there</h1>;
        }

        const Welcome = function () {       - анонимная(без названия) ф-я объявлена через function присвоенная переменной
            return <h1>Hello, there</h1>;
        }

        const Welcome = () => {             - стрелочная ф-я присвоенная переменной
            return <h1>Hello, there</h1>;
        }


        Если код находится на строке return то скобки можно не ставить: 
        
        return <h1>Hello, there</h1>;

        Если не на строке с return то нужно ставить скобки, но лучше по умолчанию ставить скобки:

        return(
            <h1>Hello, there</h1>;
            );


    Чтобы использовать ф-ю в обычном JS ее нужно вызвать (дальше по коду) - Welcome();.

    В реакте при создании ф-ии у нас появляется новый тег - в данном случае который можно вставить куда то на страницу,
        а реакт сам ее вызовет.

         <Welcome />
        

    То есть теперь компонент получается - тег.

    
    Посмотрим наш пример, тут у нас есть const App найдем куда вставляется созданный тег этой ф-ии. В вскоде нажимаем ctrl+shift+F
        это поиск во всех файлах проекта и вбиваем в поиск <App нашло 2 результата App.test.js(этот файл не смотрим) и index.js.
        
        Помним что главный файл хтмл называется index.html и он у нас лежит в папке public, откроем его и видим что в body есть
        пустой div с id="root". Как раз внутри этого тега и будет отрисовываться всё то что мы пишем на реакте.

        Откроем index.js. Видим что тоже есть много import строк, а далее видим ф-ю(обїект???) ReactDOM у которой есть метод render.
            render(переводится - отрисовать), этот метод отрисовывает созданный в App.js тег <App />. И отрисовывается он в елементе
            который мы находим по айди Root - document.getElementById('root').

            ReactDOM.render(<App />, document.getElementById('root'));



    Для закрепления создадим еще одну компоненту.

        const Header = () => {
            return (
                <div>
                    <a>Home</a>
                    <a>News</a>
                    <a>Messages</a>
                </div>
            );
        }
        
        Она в коде есть но на странице не видна потому что не вызывалась и не была вставлена в хтмл. Что бы пока не заморачиваться
            с import вставим компоненту Header в хтмл разметку компоненты App:

            <div><Header /></div>

            теперь когда рисуется App компонент в ее хтмл коде встречается компонент Header и идет обращение к этой компоненте
            (вызывается ф-я Header она возвращает свою разметку которую отрисовывает в разметке App вместо тега <Header />)

            <div>
                <div><Header /></div>
                <div className="App">
                    <ul>
                        <li>HTML</li>
                        <li>CSS</li>
                        <li>JS</li>
                        <li>React</li>
                    </ul>
                </div>
            </div>


        Выглядит както не логично, у нас есть Header. а потом пошли какие-то liшки. Вынесем весь код для списка в отдельную 
            компоненту Technologies и просто поместим ее в компоненту App которая будет все отрисовывать. Удалим класснейм потому 
            что он нам не нужен, он нужен был для стилей которые были в приветственной странице. Также удалим дивы вокруг хедера так 
            как можно и без них - они лишние.

            const App = () => {
                return (
                    <div>
                        <Header />
                        <Technologies />
                    </div>
                );
            }

            const Header = () => {
                return (
                    <div>
                        <a>Home</a>
                        <a>News</a>
                        <a>Messages</a>
                    </div>
                );
            }

            const Technologies = () => {
                return (
                    <div>
                        <ul>
                            <li>HTML</li>
                            <li>CSS</li>
                            <li>JS</li>
                            <li>React</li>
                        </ul>
                    </div>
                );
            }

            Теперь наш компонент App которая отрисовывается состоит из двух компонент которые мы подключили тегами в нее. Код стал
            более читабельным, осмысленным(логическим) и семантически правильным.

*/}


{/*    ====    08. Import, export - теория    ====

    Так как компонентов будет очень много, и они могут в себе содержать еще компоненты, то мы их разобьем на разные файлы для лучшей
        читабельности. Но для того чтобы оно потом работало вместе нужно

    ПРИМЕР.
    Есть 4 файла
        main.js     - одна ф-я которая вызывается - openAllMaps();
        maps.js     - let openAllMaps = ()=>{openGoogle(); openYandex();}
        google.js   - подключается к гугл карте и показывает ее. В ней одна ф-я(компонент) - openGoogle
        yandex.js   - подключается к яндекс карте и показывает ее. В ней одна ф-я(компонент) - openYandex


        Автор утверждает что создав таким образом глобальные переменные в JS коде, они будут видны в других файлах(если так как
            сейчас написано - нет не будут, разве что будут експортированы) и поэтому при работе с ними могут возникнуть проблемы,
            например если две переменные с одинаковым именем то одна может затереть другую и будет использована только одна.


            Реакт же использует модульность(модульный подход) - все const, let которые объявлены в одном фале, остаются видимы 
            только в этом файле, что позволяет избежать таких проблем. Для связи таких файлов используем import. Например сделаем
            импорт в файле main.js ф-и openGoogle из google.js по относительному пути к файлу в который испортируем.

            import openGoogle from './google.js';  - этот файл лежит в той же папке где и файл в который импортируем(./) 
            import openYandex from './../yandex.js'; - этот файл лежит на уровень вложенности выше(../)
            

            А в main.js теперь нужно импортировать openAllMaps из maps.js.

            import openAllMaps from './maps';     - расширение файла можно не указывать


            Чтобы import работал нужно в файле который отдает компоненту ее экспортировать - export. То есть в файле google.js:

            export default openGoogle;


            Есть несколько видов импорта/экспорта мы пока будем работать с таким. Когда мы делаем экспорт по дефолту(default) мы
            из файла можем экспортировать что то одно.
            
        // *! Рекомендует прочитать про модуль амд - modules AMD require.js после просмотра этого видео или перед собеседованием.



    Посмотрим на наш файл App.js. Видим что есть:
    
        import './App.css'; - испортируются стили из ксс файла, поэтому нету from

        import React, { Component } from 'react';  - тут видим что испорт идет не из файла, а из модуля реакт который лежит в 
                                                    папке node_modules поэтому нету пути к файлу.


    Смотрим в index.js , тут мы отрисовываем компоненту апп, но она в другом файле, значите ее нужно импортировать:

        import App from './App';

*/}


{/*    ====    09. Import, export наших компонент    ====

    Создаем файлы для Header Technologies и переносим туда код по принадлежности, в этих файлах прописываем:

        export default Header/Technologies


    а в App.js пропишем импорты:

        import Header from './Header.js';
        import Technologies from './Technologies.js';


    Сохраняем. Запускаем проект и нам выкидывает ошибку 'React' must be in scope when using JSX, что означает что в новых файлах для
        того чтобы использовать JSX(наша верстка в компонентах) нужно импортировать реакт в эти файлы.

        import React from 'react';  - (, { Component } - это мы удалили потому что class не используем, а используем ф-ю компоненту).

*/}


{/*    ====    10. Default опасность, плагин auto import    ====

    В Апп.дс закомментируем строку ипорта Header и сам тег Header в хтмл разметке. Смотрим на сайт - хедер пропал, показывается
        только Technologies.


    Теперь в import Technologies заменим файл из которого импортируется на Header.
    
        import Technologies from './Header.js';

        Смотрим на сайт, а вместо наших технологий отрисовывается Header хотя мы импортировали Technologies, такое поведение
        получается из-за дефолта(default) - при этом нету привязки к конкретному имени экспорта, и при импорте то что экспортировали
        называется как записано в импорте, но так как мы все равно будем его использовать нужно быть очень внимательными при
        импорте.



    При импорте будет использовано очень много файлов и у них могут быть сложные пути, чтобы нам облегчить этот процесс можно 
        поставить в VSCode плагин - "Auto Import", после установки нужно нажать кнопку для перезагрузки VSCode. Он работает не
        так круто как в Web Storm, но теперь когда мы начинаем писать тег с компонентой которую нужно импортировать, высвечивается
        подсказка - Auto Import - клацнув по ней в верхней части кода добавляется импорт этой компоненты из файла. 

        Сначала плагин может не работать, нужно или время для скана или создать в новом файле новую компоненту и тогда запустится
        скан, и плагин будет работать. Но нужно все равно проверять из какого файла идет импорт.

*/}


{/*    ====    11. Соц. сеть. Шаг 1(вёрстка, grid)     ====

    Все компоненты нужно называть с большой буквы чтобы измежать совпадений с названиями тегов ХТМЛ.


    Начнем с верстки макета, у нас будет 3 блока Хедер, боковая меню, и контент справа от сайдбара под хедером.

    Верстать будем на grid(только появившемся на то время). Так как автор сам учил в видео гриды он решил начать делать проект в
        одном файле.  В главный див накидаем теги которые будут отвечать за секции, а потом их уже заполним.

        return (
            <div>
                <header><img src="https://th.bing.com/th/id/OIP.PBVmERenoA81uh26kHU04QHaHa?pid=ImgDet&rs=1" /></header>
                <nav>Menu navigation</nav>
                <main>Main Content</main>
            </div>
        );

        Видим что появился большой логотип и надписи Menu navigation и Main Content все располагается одно под одним потому что
        элементы блочные.

    Для родительского эл. задаим класс app-wrapper, также добави классы для всех элементов.

        return (
            <div className="app-wrapper">
                <header className="header"><img src="https://th.bing.com/th/id/OIP.PBVmERenoA81uh26kHU04QHaHa?pid=ImgDet&rs=1" /></header>
                <nav classname="nav">Menu navigation</nav>
                <main className="content">Main Content</main>
            </div>
        );

        теперь можем обратиться к ним из ксс файла и задать ксс свойства. Для app-wrapper задать display: grid; и количество колонок,
        а для элементов размеры и имена для грид эреа темплейт.

        .app-wrapper{
            display: grid;

            grid-template-areas: 
            "header header"
            "nav content";
            
            grid-template-columns: 2fr 10fr;
            grid-template-rows: 60px 1fr;

        }

        .header{
            grid-area: header;
            background: rgb(1, 30, 37);
        }

        .header img{
            max-width: 50px;
        }

        .nav {
            grid-area: nav;
            background: rgb(252, 13, 13);
        }

        .content{
            grid-area: content;
            background: rgb(19, 72, 218);
        }


    Добавим меню в сайдбар.

        <nav className="nav">
          <ul>
            <li><a href="#">Profile</a></li>
            <li><a href="#">Messages</a></li>
            <li><a href="#">News</a></li>
            <li><a href="#">Music</a></li>
            <li><a href="#">Settings</a></li>
          </ul>
        </nav>
        
    
    В контенте у нас должна быть хедер картинка на всю ширину, ниже аватарка, справа от аватарки данные пользователя(имя, данные),
        ниже будет блок - надпись My Posts + ниже поле для ввода, а еще ниже будут сообщения. Grid использовали для общего макета
        сайта, для расстановки элементов в content будем пользоваться другими технологиями например flexbox. Автор каждый блок 
        оборачивает в div чтобы обозначить блоки которые будут, и не заморачиваться с версткой. Пока оставили схематическую верстку
        без причёсывания в ксс.


    // todo изучить grid потому что мы хотим не просто владеть инструментом реакт, а быть трендовыми фронтенд разрабочиками.
    //*! Красивые дизайны для верстки на themeforest.net social template

*/}


{/*    ====    12. Соц. сеть. Шаг 2(разбивка на компоненты)     ====

    Разобьем проект на компоненты и выделим подкомпоненты. Создадим для них папку components в папке src. 
    
    Для хедера создаем файл Header.jsx - такое расширение чтобы сразу было видно что это компонент, а не просто JS сервис, файл или
        логика. Прописываем import React from 'react'; далее создаем наш компонент - ф-ю Header и помещаем туда верстку для хедера 
        из файла Апп. Прописываем export default Header;. А в файле Апп вместо разметки хедера ставим тег <Header /> (сейчас тег 
        выглядит так { Header() } ), и прописываем - import Header from './components/Header'

    Тоже самое делаем с Navbara.

    Так как у нас страницы контента будут разные: Profile, Messages, News, Music, под каждую файл назовем соответствующе, потому
        что разметка у них будет отличаться. Та разметка которая у нас есть сейчас будет относиться к Profile. Так и назовем файл и
        компонент в нем.

*/}


{/*    ====    13. Git-репозиторий     ====

    Автор создал репозиторий на гитхабе, можно его клонировать себе. Для этого в папку куда будем клонировать, открываем для нее 
        терминал умтановленного гита(git Bash here - выбираем из списка после клика правой кнопкой в папке куда будем клонировать
        репозиторий), и в нем пишем git clone address(вместо адресса вставляем хттпс адресс к репозиторию) После клонирования у нас
        отсутствует папка с модулями, потому что он большая и заливать ее на гитхаб не стоит(будет долго обновляться проект как 
        минимум), она прописана в файле гитигнор чтобы когда у нас будет папка с модулями она не отправилась на заливку. 

    Так как мы смотрим уже когда в репозитории весь проект готов, нужно откатиться на предыдущую версию соответствующую коду в
        конкретном уроке. Это можно сделать открыв в папке проекта git Bash here терминал(консоль) и пишем комманду
        gitk --all&   жмем ентер, открывается графический интерфейсВ котором есть коммиты с номерами уроков. Чтобы откатится к
        определенному коммиту нужно на него кликнуть и под окном с коммитом отобразиться для него код SHA ID, его копируем при
        помощи ctr + insert(ctrl+C - не работает), возвращаемся в консоль и пишем git checkout copied_ID(вместо copied_ID надо
        при помощи shift + insert, вставить скопированный айди) - жмем ентер. 
        
        Может выскочить ошибка если уже немного поигралис репозиторием на счет того что сделанные изменения нужно или закоммитить 
        или удалить. Автор предлагает удалить файл package-lock потом повторно ввести комманду и мы ереключимся на нужный коммит. 
        Ни в коем случае не нужно трогать код, просто смотреть его, а то будут проблемы при переключении на следующие коммиты. 
        Если всетаки мы сделали какие то изменения нужно их удалить пишем git status - красным покажется в каком файл изменения
        далее пишем git checkout src/App.js( git checkout + путь к измененному файлу), изменения удаляться и можно снова прыгать
        по коммитам. 

    Откроем склонированную папку проекта в ВСкоде, запустим терминал и если прописать npm start то проект не стартанет так как нету
        модулей. Что бы их установить пропишем npm install при этом npm  посмотрив в package.json какие модули нужно установить для
        данного проекта и установит их автоматически в папку node_modules.

    Если мы будем устанавливать дополнительные модули, то чтобы они у нас потом тоже автоматически подгружались нужно после их
        установки делать save(npm i module.name -save ), при этом в package.json добавиться зависимость для этого модуля.

*/}


{/*    ====    14. Css modules     ====

    Мы должны знать БЭМ методологию, хотя бы основные понятия, потому что будем придерживаться похожей концепции, но реализовывать
        будем не самостоятельно, а это будет автоматически делать Create React app.

    К картинке лого мы обращались в ксс файле через вложенность .header img{ , если так не сделать то стили для просто img{ 
        применятся ко всем картинкам на проекте. Если бы мы делали по БЭМ нам нужно было бы написать класс .header__img{ и его
        прцепить к картинке, в этом тоже есть свой недостаток, нужно лезть в верстку того элемента и прописывать там классНейм.
        А нам хочется чтобы названия классов были какими то простыми, чтобы не писать длинные классы и модули позволяют нам этого
        добиться.

    Рассмотрим на примере Навбара, присвоим каждой лишке класс item, это короткое название для класса, но оно может часто 
        встречаться в проекте и нам бы хотелось чтобы мы об этом не думали и поэтому также как мы разнесли код JS по файлам
        также разнесем и ксс код по своим файлам с такими же названиями в папке src.
            
        <ul>
            <li className="item"><a href="#">Profile</a></li>
            <li className="item"><a href="#">Messages</a></li>
            <li className="item"><a href="#">News</a></li>
            <li className="item"><a href="#">Music</a></li>
            <li className="item"><a href="#">Settings</a></li>
        </ul>

        В каждый файл компонент jsx теперь пропишем импорт соответственного файла ксс, например в Header.jsx пропишем 
            import './Header.css' .


    Для постов допусти тоже задали класс айтем  

        <div className="item">
            Post 1
        </div>
        <div className="item">
            Post 2
        </div>

        в ксс навбар присвоим айтемам навбара цвет черный и видим что item в Portfolio тоже сменили цвет на черный

        .item{
            color: black;
        }

    Почему так происходит, загляним во вкладку Network(сеть) панели разработчиков, у автора там нету никаких ксс файлов(у меня есть
        так как я подключал в файле индекс.хтмл эти все ксс файлы) но есть такой файл как bundle.js - это тот файл в который
        превращаются(собираются) все наши jsx файлы и Апп.дс тоже. Все ксс файлы которые импортируются таким образом добавляются
        через JS код в head index.html файла и они получаются все равно связаны и становятся глобальными, тоесть нету инкапсуляции.
        
        Инкапсуляции можно достичь добавили module в название файла ксс, тоесть Navbar.module.css , теперь этот файл ведет себя 
        иначе, и работать с ним нам надо иначе, теперь импорт будет выглядеть таким образом

            import classes from './Navbar.module.css';  (classes - можно называть как нравиться)

        верстка сломалась, смотрим в head документа и видим что теперь вместо item у нас есть Navbar_item__3qaF3 и если мы в верстке
        заменим item на Navbar_item__3qaF3 то стили к нему применятся. Но это еще более неудобно, и что бы так не делать мы будем
        работать с импортируемым ОБЪЕКТОМ classes. У него есть свойства "ключ" : "значение" - ключи будут - названия стилей которые
        мы писали в ксс файле, тоесть классы - .nav, .item, только без точки, а значением будет как раз автоматически сгенерированые
        классы - Navbar_item__3qaF3. И теперь в разметку нужно присваивать объект:

            <div className={classes.nav}


    Для глобальных классов например для body мы App.css в модуль НЕ превращаем. Можно оставить и для других файлов ксс обычные
        стили если нам не трудно придумывать уникальные имена для тегов. Если внутри модульного ксс будет вложенность .header img{
        то программа header переделает в новый нужный тег и сохранит путь к этой картинке таким образом. Медиазапросы тоже
        подхватываются.


    При такой модульности не стоит называть классы через дефис item-nav, из-за допустимых названий свойств объекта в  JS, потому что
        тогда к ним нужно обращаться прописывая кавычки и квадратные скобки, а это не удобно. Лучше слитно, или камел кейсом, 
        или через нижнее подчеркивание.

        <div className={classes["item-nav"]}

    
    //*!Если хотим дать тегу два класса например <div className="item active" мы бы в ксс написали если у тега два класса тогда 
        цвет будет золотой и цвет активной ссылки был бы золотым  -  .item .active{color:gold;}.  А теперь часть этой строки с 
        классами у нас сидит в значении свойства объекта, то теперь нам нужно использовать бектики для вставки в строку двух 
        значений свойств объекта, а свойство active - появиться в объекте потому что в реакт прочитает модульный ксс и увидит что
        в записи .item .active{ - два класса и оба их добавит.

        <div className="item active"

        <div className={`${classes.item} ${classes.active}`}
        // ** или можно еще так {s.dialog + ' ' + s.active}


    Чтобы увидеть что лежит в объекте можно его вывести в консоль в том же файле jsx куда он импортируется.


    Если нам нужны будут стили для общих элементов мы рассмотрим это в следующих видео.

    //! При работе в окружении реакта имена классов автоматически переделывались в ВебШторме при импорте например:
        content-header - в jsx файле нужно изменять на contentHeader в файле модуля, потому что тире нельзя использовать.

*/}


{/*    ====    15. Структура папок, новые компоненты, улучшаем css     ====

    Компонентов в проекте будет очень много и если будем их складывать все просто в папку components то очень быстро будет трудно 
        искать нужные файлы, поэтому структурируем файлы. Если у нас есть несколько файлов относящихся к какому то компоненту то
        делаем папку с названием этих компонентов и складывает туда файлы. Например в папке components делаем папку Header и туда
        складываем Header.jsx + Header.module.css , при этом конечно ломаются пути импорта и нужно будет их обновить. При
        перетаскивании в ВСкоде файлов в новые папки, он предлагает обновить импорты (хотя может это делает плагин move TS или 
        сами модули Реакта).


    Теперь нужно поработать с компонентом Profile, разбить его на подкомпоненты создадим компонент My Posts и для него компонент
        post который будет отвечать за один пост(сообщение). Для этого в Profile создаем папку My Posts а в ней папку Post. 
        
        В My Posts скопируем файлы Profilе.jsx и Profile.module.css и переименуем их в MyPosts.jsx и MyPosts.module.css. 
        
        В MyPosts.jsx переназначим импорт для  MyPosts.module.css и сменим название компонента на MyPosts и удаляем все теги до тегов
        с постами, также переназовем экспорт под название компонента. 
        
        В MyPosts.module.css оставляем только класс item потому что класс content относится к вышестоящей разметке которой в 
        MyPosts.jsx нету. 
        
        А из Profile.module.css наоборот удалим item. А из Profilе.jsx удалим разметку с постами и добавим на ее место тег 
        компонента <MyPosts /> и соответственно нужно  проконтролировать добавление import на этот компонент.


    В разметке MyPosts.jsx видим что дивы с постами выглядят одинаково но с разным текстом, так что можно вынести в отдельный 
        комопнент. Предварительно добавим еще картинку пользователя написавшего пост <img>, этот аватар будет у каждого поста, для 
        него нужно будет писать класс, а там еще добавяться кнопки лайк/дизлайк и в итоге когда постов будет много это будет
        огромная работа по копированию. Чтобы такого избежать мы и выносим общий вид(разметку) поста в отдельный компонент, он
        будет строиться по общим правилам но изменять свои свойства типа текста и аватара пользователя.

        Снова переносим более глобальный(полный) компонент MyPosts в дочернюю папку Post, изменяем файлам соответсвенно названия.
    
        В  Post.jsx изменяем импорт под ксс модуль, название компонента и удаляем лишнюю разметку - оставляем 1 пост, меняем название
        экспорта.

        В MyPosts.module.css удаляем стили для класса item и всё что связано с тегом пост.

        В MyPosts.jsx - удаляем верстку с постами и добавим несколько тегами <Post />, также смотрим чтобы был импорт из Post

    
    Теперь можем менять внешний вид всех постов сразу работая в одном файле.


    Но текст у постов одинаковый, а должен быть разный текст который изменялся бы от принятых данных. Это мы рассмотрим в следующих
        уроках.

*/}


{/*    ====    16. Props     ====

    Нужно настроить наш компонент Post так чтобы он отображал свой текст для каждого поста для этого нужно использовать props.

    Каждый компонент(ф-я) может принимать параметры чтобы потом с ними работать внутри себя, и главный параметр у нас будет 
        ОБЪЕКТ - props, название можно придумать другое, но по соглашению в реакте используют именно props. Реакт когда вызывает
        компонент всегда передает в параметр этот объект.

        const Header = (props) => {
            return(
                <...>
                <...>
                <...>
                );
        }

        Например если у нас есть объект obj = { name: "Dima" } и при вызове ф-и в нее передадим этот объект Header(obj), то когда
        ф-я будет выполняться внутри себя она назовет этот объект props и будет обращаться к нему уже по этому имени props.name .
        

    // *! Тут мы сами вызвали компонент Header, но в реакте мы никогда не вызываем компонент напрямую, а  пишем тег <Header /> - 
        вызывает ф-ю реакт и именно он определяет какой объект передать в Header, props в компонент приходит всегда и по умолчанию
        это пустой объект, и какже нам передать в него нужный нам объект. По аналогии с тегами хтмл у которых есть аттрибуты и они
        настраивают эти теги, наш тег который мы пишем тоже можно настраивать аттрибутом.

            <Header name='Dima' /> - реакт создает объект у которого будет свойство name со значением 'Dima'

            <Header name='Dima' age='30'/> - { name:'Dima', age:'30' }


        и теперь можно эти значения использовать внутри ф-и

            const Header = (props) => {
                        return(
                            <span> {props.name}, {props.age} </span>
                            <...>
                            <...>
                            );
                    }


    Теперь сделаем 2 поста с разными сообщениями:

        <Post message='Yo' />

        <Post message="It's my fist post." />

        а в компоненте поста пропишем props - в параметры и в разметке обратимся к {props.message} - экранируя его {} - фигурными
        скобками потому что выполняем код JS в середине JSX, если не заэкранировать то увидели бы просто надпись props.message на
        сайте.

        const Post = (props)=> {
            return(
                <div className="post">
                    <img src="https://th.bing.com/th/id/R.bf5e1eba30b53dffbc6a0353361855d4?rik=7duhy3rpO8d7MQ&riu=http%3a%2f%2feskipaper.com%2fimages%2favatar-3.jpg&ehk=YnIJUh9Lgb92QMa1swP9zHGNKXU66it9IG4vR41p6I4%3d&risl=&pid=ImgRaw&r=0" />
                    <div className="post__message">{props.message}</div> 
                </div>
            );
        }
                
*/}


{/*    ====    17. Остановочка, react за час №1     ====

    Вспомним что мы уже прошли. На следующих уроках сделаем будем делать остальные вкладки.

*/}


{/*    ====    18. Страница Dialogues(Messages)     ====

    Автор перешел на WebStorm потому что ему он больше нравится и там больше настроеных возможностей из коробки.


    На этой странице в разметке будет тот же хедер, тот же сайдбар, но контент другой. Он будет состоять из двух колонок, в левой
        будут люди с которыми ведем переписку, а в правой будут сообщения от этого человека.


    Закоментируем в App.js тег с <Profile /> и вместо него создадим тег <Dialogs />. Создадим компонент для этого тега, в папке
        components создадим папку Dialogs, а в ней Dialogs.jsx и Dialogs.module.css.

        В Dialogs.jsx  импортируем реакт, импортируем ксс модуль, создаем ф-ю Dialogs и делаем экспорт.

            import React from "react";
            import style from "./Dialogs.module.css"

            const Dialogs = (props) => {
                return(
                    <main className={style.content}>
                        <div className="dialogs__users">ПОЛЬЗОВАТЕЛИ</div>
                        <div className="dialogs__users-msgs">СООБЩЕНИЯ</div>
                    </main>
                );
            }

        В Апп.дс добавим импорт - import Dialogs from "./components/Dialogs/Dialogs";

        Видим что стили для content не применились, это потому что в ./Dialogs.module.css нету стилей для этого блока, а в нем
            храниться название для разметки грида grid-area: content, и получается нам нужно этот код скопировать из ксс модуля
            для портфолио. Происходит дублирование кода, зачит можно этот тег вынести из всех этих страниц в верстку в Апп.дс
            чтобы в него вставлялись меняющиеся страницы.  Пропишем имя класса без модуля <main className="app-wrapper-content">
            и теперь модно перенисти этот код ксс в Апп.ксс чтобы верстка при смене страниц сохраняла свою структуру.

*/}


{/*    ====    19. Route, browser-router, маршрутизация     ====

    Сделаем ссылки в Navbar кликабельными. Изменяем название в href. //*! никогда НЕ ставить точку в этих путях(они будут
        подставляться в путь аддресса сайта, поэтому точек там быть не не должно):

            <li className={style.item}><a href="/profile">Profile</a></li>
            <li className={style.item}><a href="/dialogs">Messages/Dialogs</a></li>

            Видим что теперь по клику на ссылку в аддрессную строку к локалхосту подставлятся название которое мы написали
            http://localhost:3000/dialogs , но сам сайт пока не меняется, только мигает(обновляется???) потому что не
            прописали убрать стандартное поведение ссылки. Пока что при обновлении загружаются все файлы которые мы создавали
            ксс, jsx, все модули(позже это исправим чтобы приходил только тот модуль который нужен для показа друго страницы).


    Для того чтобы при клике на измененные ссылки показывалась та страница которую мы хотим, нужно работать с роутами(route)
        - маршртур, маршрутизация. Нам нужна система роутинга которая будет смотреть какой путь сейчас у сайта и реагировать
        на его изменение загрузкой соответствующего компонента. Для работы с роутами нужно установить дополнительный модуль
        через npm. Если пропишем просто в папке проекта то модуль скачается в нод_модулс и при загрузке проекта на Гит
        модуль не поедет с кодом и когда другой человек скачает проект и попробует его запустить он не будет работать, потому
        что у человека не будет установлен этот модуль. Значит надо при инсталяции модуля дописать -save чтобы модуль
        сохранился в package.json и при запуске npm install на другом комьютере по умолчанию подтянулся вмесе со стандартными.

        Прописываем:  npm i react-router-dom -save

        Пакет установился и в package.json видим что он добавился в dependencies - "react-router-dom": "^6.3.0",

        "dependencies": {
            "@testing-library/jest-dom": "^5.16.5",
            "@testing-library/react": "^13.3.0",
            "@testing-library/user-event": "^13.5.0",
            "react": "^18.2.0",
            "react-dom": "^18.2.0",
            "react-router-dom": "^6.3.0",
            "react-scripts": "5.0.1",
            "web-vitals": "^2.1.4"


    Теперь в Апп.дс на места где находятся Диалогс и Профайл прописываем тег компонента Роут <Route /> при этом в Вебшторме
        атоматически прописался импорт в Апп.дс  import {Route} from "react-router-dom"; у автора не прописался автоматом
        и в ВСКоде наверное тоже не пропишеться автоматом и подчеркивается красным. Автор в Вебшторме нажимает alt + Enter
        и открывается меню где предлагает импортировать из двух файлов:

            insert "import {Route} from "react-router-dom""
            insert  "import Route from "react-router-dom/es/Route""

        Он выбрал наикратчайший путь, то есть такой как у нас import {Route} from "react-router-dom" - теперь сделалась
        запись импорта и тег Роут перестал подвечиваться красным. Заполняем Роут соответствующими компонентами, только
        название потому что Роут уже в теге.

          <Route component={Dialogs}/>
          <Route component={Profile}/>


    При запуске проекта вывелась ошибка - не может использовать Роут вне Роутера. Это значит что нам нужно всю нашу разметку
        поместить в тег(вроде как есть 2 тега но мы выбрали один из них BrowserRouter), помещаем и нам этот тег подчеркивает
        красным, нужно его тоже импортировать из модуля который установили теперь импорт такой:

        import {BrowserRouter, Route} from "react-router-dom";

        а разметка такая:

        <BrowserRouter>
          <div className='app-wrapper'>
              <Header/>
              <Navbar/>
               <div className='app-wrapper-content'>
                  <Route component={Dialogs}/>
                  <Route component={Profile}/>
                </div>
           </div>
        </BrowserRouter>


    У автора загрузился сайт и отрисовалась и страница диалогов и страница профиля, у меня не загрузился, пришлось дополнительно
        обернуть Роут в Роуты и импортировать его тоже и сайт отрисовался, но без контента, только хедер и боковуха, а при
        клике по ссылкам пишет в консоли - No routes matched location "/profile"

        import {BrowserRouter, Route, Routes} from "react-router-dom";

        function App() {
          return (
              <BrowserRouter>
                  <div className='app-wrapper'>
                      <Header/>
                      <Navbar/>
                      <div className='app-wrapper-content'>
                          <Routes>
                          <Route component={Dialogs}/>
                          <Route component={Profile}/>
                          </Routes>
                      </div>
                  </div>
              </BrowserRouter>
             );
            }

    Автор добавляет path="/dialogs" для диалогов и профайл для Профайла в тег Роут.

      <Route path="/dialogs" component={Dialogs}/>
      <Route path="/profile" component={Profile}/>

        У него все заработало, у меня выводит ошибку Matched leaf route at location "/dialogs" does not have an element.
        This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.


    //*! Заработало при такой конфигурации, так происходит потому что модуль обновился и теперь Route пишеться с element,
        и вставляется сам тег компонента, поэтому дальше по программе render в Route не понадобиться, также в новой версии
        удален switch поэтому он не импортируется из модуля а вместо него используется Route.

        import {BrowserRouter as Router, Routes, Route, Link, useRouteMatch, useParams} from "react-router-dom";

        function App() {
          return (
              <Router>
                  <div className='app-wrapper'>
                      <Header/>
                      <Navbar/>
                      <div className='app-wrapper-content'>
                          <Routes>
                              <Route path="/dialogs" element={<Dialogs />} />
                              <Route path="/profile" element={<Profile />} />
                          </Routes>
                      </div>
                  </div>
              </Router>
          );
        }

*/}


{/*    ====    20. NavLink     ====

    Сделали что при клике на ссылку происходит переключение контента, но страница перезагружается, из-за этого тратится траффик и
        получается моргание страницы и это получается веб сайт, а не SPA. Это стандартное поведение ссылки <a></a>, значит вместо
        нее будем использовать теги NavLink для этого его нужно импортировать из react-router-dom, а вместо href используется to. 

        import {NavLink} from "react-router-dom"

        <NavLink to='/profile'>Profile</NavLink>

        теперь по клике на ссылку страница не перезагружается, но меняется путь в адрессной строке и происходит обновление 
        контента.


    Если посмотрим в верстку сайта то видим что по прежнему эти ссылки являются тегами <a></a>, перезагрузки страницы не происходит
        потому что тег NavLink возвращает тег <a> и вешает на него евент лисенер в котором подменяет адресс обращаясь(c помощью)
        к history API, и помещает в этот eventListener - preventDefault - отмена стандартного поведения ссылки.

        //todo почитать про  history API


    Ссылки после нажатия становяться фиолетовыми и по умолчанию имеют подчеркивание, сделаем чтобы они были как обычный текст, для
        этого в Navbar.module.css пропишем стиль:

        .item a{
            color: white;
            text-decoration: none;
        }

        
    Еще сделаем выбраную(активную) ссылку золотым цветом(если у ссылки а в класе .item будет присутсвовать класс .active):

        .item a.active{
            color:gold;
        }

        NavLink автоматически присваивает возвращаемой ссылке класс - active, но так как у нас из модуля приходит не просто
        active, а с добавленными словами, нам нужно изменить стандартное поведение NavLink, чтобы он присваивал такой же класс
        как в модулях, для этого передадим ему этот класс из модуля как к другим тегам.

        <NavLink to='/profile' activeClassName={s.active} >Profile</NavLink>

*/}


{/*    ====    21. Верстаем страницу диалогов     ====

    Нужно сделать 2 колонки. В Dialogs.jsx создаем две дивки, в одной будут Диалоги(почему не пользователи, потому что может
        появиться кнопочка - удалить беседу, и мы же не пользователя удаляем, а диалог), а вторая колонка - сообщения.

        Видим что все в куче, нужно прописать стили в Dialogs.module.css перенести их как объект из модуля в верстку:

        const Dialogs = (props) => {
            return (
                <main className={s.dialogs}>
                <div className={s.dialogsItems}>
                    <div className={s.dialog + ' ' + s.active}>Dmitriy</div>
                    <div className={s.dialog}>Andrey</div>
                    <div className={s.dialog}>Valera</div>
                    <div className={s.dialog}>Sveta</div>
                    <div className={s.dialog}>Viktor</div>
                </div>
                <div className={s.messages}>
                    <div className={s.message}>Hi</div>
                    <div className={s.message}>Yo</div>
                    <div className={s.message}>What's up?</div>
                </div>
                </main>
            );
        }


        css file:

        .dialogs {
            display: grid;
            grid-template-columns: 2fr 8fr;

        }

        .dialogsItems {
            padding: 20px;
        }

        .dialogsItems .active {
            color: gold;
        }

        .dialog {
        margin-bottom: 10px;    
        }

        .messages {
            padding: 20px;
        }

        .messages .message {
            margin-bottom: 10px;
        }


    На следующем уроке сделаем чтобы при нажатии на dialog происходила подгрузка содержимого беседы, логика будет как с кликами по
        ссылкам для смены контента.

*/}


{/*    ====    22. Route exact     ====

    Обернем имя пользователя с которым диалог в NavLink чтобы они генерили путь в адрессной строке и им можно было делится с
        кем-то чтобы у него сайт подстроился также, также по этому пути будет показываться сообщения с этим человеком. Импортируем
        НавЛинк из модуля.

        import {NavLink} from "react-router-dom"

        const Dialogs = (props) => {
            return (
                <main className={s.dialogs}>
                <div className={s.dialogsItems}>
                    <div className={s.dialog + ' ' + s.active}>
                        <NavLink to='/dialogs/1'>Dmitriy</NavLink>
                    </div>
                    <div className={s.dialog}>
                        <NavLink to='/dialogs/2'>Andrey</NavLink>
                    </div>
                    <div className={s.dialog}>
                        <NavLink to='/dialogs/3'>Valera</NavLink>
                    </div>
                    <div className={s.dialog}>
                        <NavLink to='/dialogs/4'>Sveta</NavLink>
                    </div>
                    <div className={s.dialog}>
                        <NavLink to='/dialogs/5'>Viktor</NavLink>
                    </div>
                </div>
                <div className={s.messages}>
                    <div className={s.message}>Hi</div>
                    <div className={s.message}>Yo</div>
                    <div className={s.message}>What's up?</div>
                </div>
                </main>
            );
        }


    //*!Так как в нашем пути /dialogs/5 - присутствует часть пути /dialogs - для Route Dialogs из App.js, то контент не 
        перезагружается а остается прежним, тоесть Route проверяет путь на нужный кусок пути. Можно задать чтобы Route
        проверял весь путь не частичное совпадение, а полное совпадение, тоесть Dialogs отобразится только когда путь будет
        полностью совпадать:

        <Route exact path="/dialogs" component={Dialogs}/>

        Пока оставим без exact.


    Не обязательно при смене url создавать новый Route, не обязательно нам должен показываться компонент новый. В нашем случае
        при клике на пользователя мы хотим показывать другие сообщения, а не компоненты(я так понял он хочет сделать несколько
        сообщений-дивов, а уже их содержимое менять в зависимости от props).

*/}


{/*    ====    23. Props для диалогов     ====

    Создадим подкомпоненты Dialog и Message в Dialogs.jsx и пока оставим в это файле потому что они больше нигде не используются,
        но если нужно будет их использовать в других компонентах или неужобно будет работать с этим фалом потому что много кода
        тогда вынесем в отдельные файлы. Напишем их гибкими с props.

        const DialogItem = (props) => {
            return(
                <div className={s.dialog}>
                    <NavLink to={"/dialogs/" + props.id}>{props.name}</NavLink>
                </div>
            );
        }

        const Message = (props) => {
            return(
                 <div className={s.message}>{props.msg}</div>
            );
        }


         const Dialogs = (props) => {
            return (
                <main className={s.dialogs}>
                    <div className={s.dialogsItems}>
                        <DialogItem name="Dmitriy" id="1" />
                        <DialogItem name="Andrey" id="2" />
                        <DialogItem name="Valera" id="3" />
                        <DialogItem name="Sveta" id="4" />
                        <DialogItem name="Viktor" id="5" />
                    </div>
                    <div className={s.messages}>
                        <Message msg="Hi" />
                        <Message msg="Yo" />
                        <Message msg="What's up?" />
                    </div>
                </main>
            );
        }



    Теперь зарефакторм страницу Profile. Вынесем в отдельный компонент остальной код вместе с большой картинкой, и оставим только
        тег компонента. Создадим импорт. В файле компонента сделаем экспорт и импорт из ксс модуля.

        const Profile = () => {
            return (
                <main className="content">
                <ProfileInfo />
                <MyPosts />
                </main>
            );
            }

        const ProfileInfo = () => {
            return (
                <div>
                <div>
                    <img className="content__header" src="https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RE4wwuO?ver=1fc3" />
                </div>
                <div className="form__user">
                    <img className="user-avatar" src="https://images.archive-digger.com/taboola/image/fetch/f_jpg%2Cq_auto%2Ch_225%2Cw_300%2Cc_fill%2Cg_faces:auto%2Ce_sharpen/https%3A%2F%2Fi.imgur.com%2FhDNiJvY.png" />
                    <div className="user-description">Description</div>
                </div>
                </div>
            );
        }

*/}


{/*    ====    24. UI - BLL, выносим данные в сторону     ====

    В компоненте Dialogs идет много дублирования и props мы передаем прямо в тегах, в реальном проекте эти данные приходяд с 
        сервера по запросу. Смотрим на DialogItem и видим что его props сгруппированы, тоесть две пары ключ-значение. Значит
        можносказать что нам нужен объект под каждого пользователя, их будет много поэтому сделаем для них массив. 

         <DialogItem name="Dmitriy" id="1" />


         создадим его прямо тут в середине компонента Dialogs перед return.

         const Dialogs = (props) => {

            let dialogsData = [
                {id: 1, name: "Dmitriy"},
                {id: 2, name: "Andrey"},
                {id: 3, name: "Valera"},
                {id: 4, name: "Sveta"},
                {id: 5, name: "Viktor"}
                ];

            return (
                <main className="dialogs">
                    <div className="dialogsItems">
                        <DialogItem name={dialogsData[0].name} id={dialogsData[0].id}/>
                        <DialogItem name={dialogsData[1].name} id={dialogsData[1].id}/>
                        <DialogItem name={dialogsData[2].name} id={dialogsData[2].id}/>
                    </div>
                    <div className="messages">
                        <Message msg="Hi" />
                        <Message msg="Yo" />
                        <Message msg="What's up?" />
                    </div>
                </main>
            );
        }

        //! классы для тегов изменены чтобы работало в файле на работе без реакт-апп

        Таким образом мы разграничим данные BLL(Business Logic Layer) и пользовательский интерфейс UI.


    Чтобы не добавлять теги вручную, мы можем с помощью метода map для массивов сгенерировать столько тегов сколько будет
        объектов в массиве, этот метод рассмотрим в следующем уроке. 
        
    //*! Эти диалоги как и сообщения , как и пользователи или какая-то информация - это сущности(какие-то записи в базе данных).

    А пока подготовимся к следующему уроку и сделаем тоже самое для  message. Мы могли бы для них сделать массив строк, но мы 
        понимаем что сообщение это не только строка, это еще и дата когда оно отправлено, отправитель, ссылка на авататарку, айди по
        которому его можно удалить - тоесть все равно это ОБЪЕКТ. Пока это у нас строка, но нужно всегда закладывать на перед
        возможные свойства и предусмотреть.

        Тут же в Dialogs копируем массив dialogsData и переделываем его в messagesData, id в этих массивах будут одинаковые, но
        это не повлияет на работоспособность потому что это разные массивы, и под одним айди в них храняться разные данные.
        Пока мы айди задаем сами, но потом они будут приходить с сервера, заменим в верстке код чтобы читать из этого массива.

        let messagesData = [
            { id: 1, msg: "Hi" },
            { id: 2, msg: "Yo" },
            { id: 3, msg: "What's up?" },
            { id: 4, msg: "Hi" },
            { id: 5, msg: "Yo" }
        ];

        return (
            <main className="dialogs">
            <div className="dialogsItems">
                <DialogItem name={dialogsData[0].name} id={dialogsData[0].id} />
                <DialogItem name={dialogsData[1].name} id={dialogsData[1].id} />
                <DialogItem name={dialogsData[2].name} id={dialogsData[2].id} />
            </div>
            <div className="messages">
                <Message msg={messagesData[0].msg} />
                <Message msg={messagesData[1].msg} />
                <Message msg={messagesData[2].msg} />
            </div>
            </main>
        );
    }

       
    Сделаем также с постами в MyPost.jsx

        const MyPosts = () => {

            let postsData = [
                { id: 1, post: "yo", likesCount:12 },
                { id: 2, post: "It's my fist post.", likesCount:11 },
                { id: 3, post: "0", likesCount:13 },
            ];

            return (
                <div className="form__new-post">
                <div className="new-post__title">New Post
                    <textarea></textarea>
                    <button>Add Post</button>
                </div>
                <Post msg={postsData[0].post}  likesCount={postsData[0].likesCount}/>
                <Post msg={postsData[1].post} likesCount={postsData[1].likesCount}/>
                <Post msg={postsData[2].post} likesCount={postsData[2].likesCount}/>
                </div>
            );
            }

            const Post = (props) => {
            console.log(props);
            return (
                <div className="post">
                <img src="https://th.bing.com/th/id/R.bf5e1eba30b53dffbc6a0353361855d4?rik=7duhy3rpO8d7MQ&riu=http%3a%2f%2feskipaper.com%2fimages%2favatar-3.jpg&ehk=YnIJUh9Lgb92QMa1swP9zHGNKXU66it9IG4vR41p6I4%3d&risl=&pid=ImgRaw&r=0" />
                <div className="post__message">{props.msg}</div>
                <div className="likes">Likes: {props.likesCount}</div>
                </div>
            );
        }

*/}


{/*    ====    25. Метод массива map     ====

    Если мы закомментируем код и вместо него напишем просто массив строк в фигурных скобках, то компилятор их просто 
        распкрое, потому что массив нельзя отобразить в виде хтмл элемента, и отобразит строки.
        
        return (
        <main className="dialogs">
            <div className="dialogsItems">

                {
                ['sdsdsd', 'sdsdsda', 'sdsdasaaaa']
                }

                // <DialogItem name={dialogsData[0].name} id={dialogsData[0].id} />
                //<DialogItem name={dialogsData[1].name} id={dialogsData[1].id} />
                //<DialogItem name={dialogsData[2].name} id={dialogsData[2].id} />
            </div>

    Если вместо строк будут объекты - выдаст ошибку, потому что объект он никак не сможет отобразить. Но если вместо строк
        в массив вставить реакт компонент, то реакт раскроет массив и отобразит этот компонент.

         <main className="dialogs">
            <div className="dialogsItems">

                {
                    [<DialogItem name={dialogsData[0].name} id={dialogsData[0].id} />,
                    <DialogItem name={dialogsData[1].name} id={dialogsData[1].id} />,
                    <DialogItem name={dialogsData[2].name} id={dialogsData[2].id} />]
                }


    Таким образом можем вынести этот массив вне  return ф-и в dialogsElements , а вместо него оставим ссылку, будет
        работать также.

        let dialogsElements = [
        <DialogItem name={dialogsData[0].name} id={dialogsData[0].id} />,
        <DialogItem name={dialogsData[1].name} id={dialogsData[1].id} />,
        <DialogItem name={dialogsData[2].name} id={dialogsData[2].id} />
        ]


        return (
            <main className="dialogs">
            <div className="dialogsItems">

                {dialogsElements}

        Отсюда вывод - что можно отбразить массив который мы сами сформируем на основе массива с объектами с данными,
        и тогда количество тегов будет не статическое, а такое же сколько объектов в пришедшем массиве с объектами
        dialogsData. Такое преобразование будем делать с помощью метода массива map.


    map - преобразовывает массив одних эл. в массив других. Новый массив по длинне будет такмим же как и изначальный.
        map возвращает НОВЫЙ массив, принимает стрелочную ф-ю(//? колбек) аргументы: el, ind, arr.
        Она вызывается столько раз сколько элементов в массиве, в середине нее и происходят нужные нам преобразования.
        //! Если стрелочная ф-я только возвращает что-то(перед return нету кода) то можно убрать фигурные скобки и
        слово return, если аргумент только 1 например обязательный аргумент - el(эл. который мы перебираем) - можно
        убрать скобки вокруг него, также его можно назвать как нам вздумается(по специфике массива).

        Тут из массива имен определяются мужские и женские и для мужских в новый массив заносятся 1, женских - 0.
            
            ['Evgen', 'Aleksandr', 'Olya', 'Yana']                      [1, 1, 0, 0]

            let newArray = oldArray.map((el)=>{         let newArray = oldArray.map(name => isMale(name) ? 1 : 0)
                return isMale(el) ? 1 : 0;
            })


        Тут из массива имен получаем массив эл. li с этими именами в середине.

            ['Evgen', 'Aleksandr', 'Olya', 'Yana'] превратится в  
            ['<li>Evgen</li>', '<li>Aleksandr</li>', '<li>Olya</li>', '<li>Yana</li>']

            let newArray = oldArray.map(name => {       let newArray = oldArray.map(name => `<li>${name}</li>`
                return "<li>"" + name + "</li>';
            })


        Тут из массива слов получаем массив с объектами. Тут если хотим убрать ретурн и написать все в одну строку
            так как раньше сделать не получиться потому что браузер будет думать что оставшиеся фигурны скобки
            это не тело объекта, а тело ф-ии, поэтому объект нужно взять в скобки.

            ['blabla', 'hello', 'hi']       
            [{eng:'blabla', ru:'блабла'}, {eng:'hello', ru:'привет'}, {eng:'hi', ru:'здарова'}]

            let newArray = oldArray.map( word => {       let newArray = oldArray.map(word => (
                return {                                        {
                    eng: word,                                    eng: word,
                    ru: translateIntoRu(word)                     ru: translateIntoRu(word)
                };                                              }
            });                                              ) );


        Чаще всего для реакта будем использовать преобразование массива с объктами в массив с JSX елементами

            [{eng:'blabla', ru:'блабла'}, {eng:'hello', ru:'привет'}, {eng:'hi', ru:'здарова'}]

        [<Message eng='blabla' ru='блабла' />, <Message eng='hello' ru='привет' />, <Message eng='hi' ru='здарова' />]

            let newArray = oldArray.map(
                el => (<Message eng={el.eng} ru={el.ru} /> ) )

                Таким образом мы маппим(соотносим, преобразовываем) массив одних объектов на массив других объектов.



    Зарефакторим наш код.

        const Dialogs = (props) => {

            let dialogsData = [
                { id: 1, name: "Dmitriy" },
                { id: 2, name: "Andrey" },
                { id: 3, name: "Valera" },
                { id: 4, name: "Sveta" },
                { id: 5, name: "Viktor" }
            ];

            let dialogsElements = dialogsData.map(el => (
                <DialogItem name={el.name} id={el.id} />
            ));

            let messagesData = [
                { id: 1, msg: "Hi" },
                { id: 2, msg: "Yo" },
                { id: 3, msg: "What's up?" },
                { id: 4, msg: "Hi" },
                { id: 5, msg: "Yo" }
            ];

            let messagesElements = messagesData.map(el => (
                <Message msg={el.msg} />
            ));


            return (
                <main className="dialogs">
                <div className="dialogsItems">
                    {dialogsElements}
                </div>
                <div className="messages">
                {messagesElements}
                </div>
                </main>
            );
        }

        
        И Посты

        const MyPosts = () => {

            let postsData = [
                { id: 1, post: "yo", likesCount: 12 },
                { id: 2, post: "It's my fist post.", likesCount: 11 },
                { id: 3, post: "0", likesCount: 50 },
            ];

            let postsElements = postsData.map(el => <Post msg={el.post} likesCount={el.likesCount} />)

            return (
                <div className="form__new-post">
                <div className="new-post__title">New Post
                    <textarea></textarea>
                    <button>Add Post</button>
                </div>
                {postsElements}
                </div>
            );
            }

            const Post = (props) => {
            console.log(props);
            return (
                <div className="post">
                <img src="https://th.bing.com/th/id/R.bf5e1eba30b53dffbc6a0353361855d4?rik=7duhy3rpO8d7MQ&riu=http%3a%2f%2feskipaper.com%2fimages%2favatar-3.jpg&ehk=YnIJUh9Lgb92QMa1swP9zHGNKXU66it9IG4vR41p6I4%3d&risl=&pid=ImgRaw&r=0" />
                <div className="post__message">{props.msg}</div>
                <div className="likes">Likes: {props.likesCount}</div>
                </div>
            );
        }

*/}


{/*    ====    26. Структура проекта, еще раз про UI - BLL     ====

    В index.js отрисовываем компонент App, все его содержимое  оборачиваем в BrowserRouter для контроля за кликами по ссылкам и
        их загрузки без перезагрузки страницы. В BrowserRouter - компоненты Header, Navbar и в тегах Route Dialogs и Profile.
        В Profile отрисовываются компоненты ProfileInfo и MyPosts, они находятся в сових папках в папке компонента в котором
        используются. Внутри MyPosts в папке находится компонент Post. В Dialogs присутствуют  DialogItem и Message, но мы их
        пока не выносили в отдельные файлы и папки - этим и займемся. 
        
    //*! При работе с проектом(своим или когда разбираемся с чужим) автор рекоммендует делать схему проекта чтобы потом быстро
        разобраться в нем через время при необходимости.

    Создадим папки и в них файлы jsx стили оставим в главном файле Dialogs.module.css, потому что там не много стилей и разбивать не
        целесообразно и для работоспособности кода испортируем этот ксс модуль в новые созданные jsx файлы DialogItem и Message,
        экспортируем их содержимое и делаем импорт компонент в Dialogs.jsx.


    //*! Реакт отрисовывает компоненты для UI на основании компонентов которые принимают в себя props - данные приходящие из BLL. 
        БЛЛ конвертирует данные с сервера в данные которые хранит в себе и отправляет их в компоненты, в роли BLL выступает Redux.
        Как только в Redux изменяются данные, Реакт перерисовывает компоненты для которых эти данные изменились, в тоже время из
        UI в БЛЛ постоянно отправляются комманды(например - пользователь нажал кнопку чтобы удалить такой-то пост, сделай это).

        В нашей структуре пока получается что данные лежат в самом компоненте MyPosts и Dialogs, это нужно будет исправить путем
        вынесения данных за компоненты, ближайший файл который не является компонентом - index.js, в нем начинает отрисовываться
        компонент App, но сам файл по сути компонентом не является, для начала поступим так. 
        
        //todo Из-за Route мы самостоятельно не сможем поднять данные в index.js(потому что используем не тег компонента, а просто
        его название и никаки не можем добавить аттрибут в этот тег), поэтому наша задача поднять их на 1 уроевень компонента выше.

*/}


{/*    ====    27. Component vs render, прокидываем props через Route     ====

    Для того чтобы вынести данные и потом прокинуть их через пропсы компонентов в Route нужно чтобы в роуте отрисовывался тег
        компонента. Сейчас там такой код

            <Route path="/dialogs" component={Dialogs}/>
            <Route path="/profile" component={Profile}/>


    Но есть еще один способ записать роут, написать render вместо component и передать анонимную ф-ю которую вызовет render, и
        уже эта ф-я вернет тег компонента :

        <Route path="/dialogs" render={ () => <Dialogs /> }/>
        <Route path="/profile" render={ () => <Profile /> }/>

        //*! эти способы взаимоисключающие.


    Можно также вынести эту ф-ю в отдельную переменную и потом подставить по первому способу

        let FunctionDialog = () => <Dialogs />

        <Route path="/dialogs" component={ FunctionDialog }/>
        <Route path="/profile" render={ () => <Profile /> }/>


    //*! Второй способ заработал и с component, но автор рекомендует использовать только с render

        <Route path="/dialogs" component={ () => <Dialogs /> }/>
        <Route path="/profile" component={ () => <Profile /> }/>

    

    Чтобы прокинуть props который пришел в App дальше нужно его разбить на части и закинуть в Dialogs что-то одно, а в Profile
        что-то другое(нужные массивы).

*/}


{/*    ====    28. Выносим данные в index.js     ====

    Будем переносить данные по одному уровню вверх чтобы было наляднее(понятнее логика) и не запутаться.


    Для начала посмотрим как вынести данные на уровень выше из MyPosts в Profile. Выносим массив с данными в компонент Profile
        а в методе c map добавляем слово props. А в Profile в саму ф-ю вставляем массив postsData и передаем его в тег компонента
        MyPosts.
        
        const Profile = () => {
        
            let postsData = [
                { id: 1, post: "yo", likesCount: 12 },
                { id: 2, post: "It's my fist post.", likesCount: 11 },
                { id: 3, post: "0", likesCount: 50 },
            ];

            return (
                <main className="content">
                <ProfileInfo />
                <MyPosts postsData={postsData}/>
                </main>
            );
        }


        const MyPosts = (props) => {

            let postsElements = props.postsData.map(el => <Post msg={el.post} likesCount={el.likesCount} />);

            return (
                <div className="form__new-post">
                <div className="new-post__title">New Post
                    <textarea></textarea>
                    <button>Add Post</button>
                </div>
                {postsElements}
                </div>
            );
        }


    Вынесем данные в App.js. Добавляем в Profile прием props и объект props для передачи в компонент. В Апп вставляем массив с
        данными и для тега Profile передаем массив по названию.

        const Profile = (props) => {
        
            let postsData = [
                { id: 1, post: "yo", likesCount: 12 },
                { id: 2, post: "It's my fist post.", likesCount: 11 },
                { id: 3, post: "0", likesCount: 50 },
            ];

            return (
                <main className="content">
                <ProfileInfo />
                <MyPosts postsData={props.postsData}/>
                </main>
            );
        }

        const App = () => {

            let postsData = [
                { id: 1, post: "yo", likesCount: 12 },
                { id: 2, post: "It's my fist post.", likesCount: 11 },
                { id: 3, post: "0", likesCount: 50 },
            ];
            
            return (
            <div className="app-wrapper">
                {Header()}
                {Navbar()}
                <main className="app-wrapper-content">
                <Dialogs /> 
                <Profile postsData={postsData}/>  = //*! <Route path="/profile" render={ () => <Profile postsData={postsData}/> }/>
                </main>                                                      для приложения
            </div>
            );
        }

    
    Для App выносим также, вставляем данные ДО рендера, а потом в теге Апп передаем массив <App postsData={postsData}/>



    По аналогии вынесем данные из Dialogs.

        const Dialogs = (props) => {

            let dialogsElements = props.dialogsData.map(el => (
                <DialogItem name={el.name} id={el.id} />
            ));

            let messagesElements = props.messagesData.map(el => (
                <Message msg={el.msg} />
            ));


            return (
                <main className="dialogs">
                <div className="dialogsItems">
                    {dialogsElements}
                </div>
                <div className="messages">
                    {messagesElements}
                </div>
                </main>
            );
        }


        const App = () => {

            let postsData = [
                { id: 1, post: "yo", likesCount: 12 },
                { id: 2, post: "It's my fist post.", likesCount: 11 },
                { id: 3, post: "0", likesCount: 50 },
            ];

            let messagesData = [
                { id: 1, msg: "Hi" },
                { id: 2, msg: "Yo" },
                { id: 3, msg: "What's up?" },
                { id: 4, msg: "Hi" },
                { id: 5, msg: "Yo" }
            ];

            let dialogsData = [
                { id: 1, name: "Dmitriy" },
                { id: 2, name: "Andrey" },
                { id: 3, name: "Valera" },
                { id: 4, name: "Sveta" },
                { id: 5, name: "Viktor" }
            ];

            
            return (
            <div className="app-wrapper">
                {Header()}
                {Navbar()}
                <main className="app-wrapper-content">
                <Dialogs messagesData={messagesData} dialogsData={dialogsData} />   //*! <Route path=".....
                <Profile postsData={postsData}/>
                </main>
                </div>
                );
        }


    Дальше перенесем в Апп  <App postsData={postsData} messagesData={messagesData} dialogsData={dialogsData} />


    Теперь данный у нас отделены от компонентов.

*/}


{/*    ====    29. Упаковываем данные в state     ====

    Для сохранения принципе single responcibility(один файл - одна задача, одна ф-я - одна задача) из файла App.js вынесем все наши
        массивы с данными в отдельный файл State.js . Из него данные будут импортироваться(так ак Апп не компонент и через props
        не получиться) через import в App.js. Чтобы не делать кучу импортов упакуем все массивы в один объект state с названиями
        свойств как переменные, и значениями свойств - массивами. А дальше прокинем state по  цепочке но в Route отдадим нужные
        свойства определенным коспонентам, а не целый state(чтобы не передавать лишнее, будет излишнее знание о системе - нарушается
        инкапсуляция).

        Почему не импортируем state напрямую в компонент, а прокидываем через props - потому что мы хотим сохранить чистые ф-и,
        то есть чтобы ф-я работала только с тем что в нее приходит из вне(ну и так будет снова же много лишней информации),
        чтобы система была контролируема, предсказуема, тестируемая - нужно избавиться от глобальных вещей(как этот импорт всей 
        базы данных, данные не должны быть глобальными).


        Создаем в components папку - redux и в ней state.js в него переместим все наши данные

            let state = {
                postsData:[
                    { id: 1, post: "yo", likesCount: 12 },
                    { id: 2, post: "It's my fist post.", likesCount: 11 },
                    { id: 3, post: "0", likesCount: 50 }],
                messagesData: [
                    { id: 1, msg: "Hi" },
                    { id: 2, msg: "Yo" },
                    { id: 3, msg: "What's up?" },
                    { id: 4, msg: "Hi" },
                    { id: 5, msg: "Yo" }],
                dialogsData: [
                    { id: 1, name: "Dmitriy" },
                    { id: 2, name: "Andrey" },
                    { id: 3, name: "Valera" },
                    { id: 4, name: "Sveta" },
                    { id: 5, name: "Viktor" }]
            };

            export default state;


        Теперь этот объект импортируем в index.js и передаем его в тег App не по отдельности, а полностью :

            import state from './redux/state'

            <App appState={state}/>


        Теперь в props App приходит объект appState и путь к массиву удлинняется на это название:

        const App = (props) => {
            return (
            <div className="app-wrapper">
                {Header()}
                {Navbar()}
                <main className="app-wrapper-content">
                <Dialogs messagesData={props.appState.messagesData} dialogsData={props.appState.dialogsData} />
                <Profile postsData={props.appState.postsData}/>
                </main>
                </div>
                );
        }
        

    Все данные для всех страниц будут храниться в этом одном объекте state. Для того чтобы как-то сгруппировать эти массивы в 
        объекте state будем делать подобъекты, например dialogsData и messagesData относятся к одному компоненту Dialogs. Создадим
        в state свойства profilePage и dialogsPage, которые в свою очередь являются объектами и в них перенесем наши массивы.
        Теперь один подобъект будет обслуживать одну страницу. Для доступа к этим подобъектам нужно добавить в путь для props
        в теги Profile и Dialogs имена подобъектов.

        let state = {
            profilePage: {
                postsData: [
                    { id: 1, post: "yo", likesCount: 12 },
                    { id: 2, post: "It's my fist post.", likesCount: 11 },
                    { id: 3, post: "0", likesCount: 50 }]
            },
            dialogsPage: {
                dialogsData: [
                    { id: 1, name: "Dmitriy" },
                    { id: 2, name: "Andrey" },
                    { id: 3, name: "Valera" },
                    { id: 4, name: "Sveta" },
                    { id: 5, name: "Viktor" }],
                messagesData: [
                    { id: 1, msg: "Hi" },
                    { id: 2, msg: "Yo" },
                    { id: 3, msg: "What's up?" },
                    { id: 4, msg: "Hi" },
                    { id: 5, msg: "Yo" }]
            }
        };


        function App(props) {
            return (
                <BrowserRouter>
                    <div className='app-wrapper'>
                        <Header />
                        <Navbar />
                        <div className='app-wrapper-content'>
                            <Routes>
                                <Route path="/profile" element={<Profile postsData={props.appState.profilePage.postsData} />} />
                                <Route path="/dialogs" element={<Dialogs messagesData={props.appState.dialogsPage.messagesData}
                                                                     dialogsData={props.appState.dialogsPage.dialogsData} />} />
                            </Routes>
                        </div>
                    </div>
                </BrowserRouter>
            );
        }


    Можно еще улучшить, сократим передачу для dialogsPage передав целый подобъект в компонент Dialogs, а там уже раскрыв его, также сделаем для Profile.

        <Route path="/profile" element={<Profile state={props.appState.profilePage} />} />
        <Route path="/dialogs" element={<Dialogs state={props.appState.dialogsPage} />} />


        const Profile = (props) => {
            return(
                <main>
                    <ProfileInfo />
                    <MyPosts postsData={props.state.postsData}/>
                </main>
            );
        }


        const Dialogs = (props) => {

            let dialogsElements = props.state.dialogsData.map(el => (
                <DialogItem name={el.name} id={el.id} />
            ));

            let messagesElements = props.state.messagesData.map(el => (
                <Message msg={el.msg} />
            ));


    У автора в консоли выводятся ошибки связанные с ключами, поговорим о них в следующих видео.

    //todo сделать в сайдбаре секцию друзей(3 штуки аватарка+имя) и эти данные хранить в state,
        в Dialogs сделать аватарки для друзей и еще одну секцию сообщений напротив этих сообщ.
        перед сообщениями также добавить аватарки, и эти сообщения привязвть к разным частям
        страницы.

*/}


{/*    ====    30. Остановочка, react за час №2     ====

    Закрепляем то что изучили.

*/}


{/*    ====    31. onClick, ref, VirtualDOM     ====

    Добавляем логику на сайт(изменения при нажатии кнопок). 
    
    Разделим ее на 2 части потому что UI отлавливаем действия пользователя, но компоненты не имеют право вносить изменения в state: 
        1) научимся взаимодействовать с пользователем с кнопками, элементами и данными введенными в эти элем;
        2) склеим наш state - изменения которые произошли от действий пользователя с изменениями в state.


    Для того чтобы можно было кликнуть на элемент нужно в него добавить событие onClick. Добавим его к кнопке в MyPosts и при 
        нажатии будет запускаться анонимная стрелочная ф-я которая выполнит код внутри:

        <button onClick={ ()=> {alert('Hello')}  } >Add Post</button>

        эта ф-я выполняется только после нажатия - коллбек ф-я(ф-я которую мы сами не вызываем, а передаем для вызова другому эл.)


    Вынесем эту ф-ю(логику) вне JSX разметки и передадим в нее только название ф-и:

        let addPost = ()=> {alert('Hello')};

        return (
            <div className="form__new-post">
            <div className="new-post__title">New Post
                <textarea></textarea>
                <button onClick={ addPost } >Add Post</button>
            </div>
            {postsElements}
            </div>
        );
        


    Теперь нам нужно чтобы UI собрал данные из формы и по клику кнопки отправил эти данные чтобы они как-то попали в state.
        //*! Так как мы работаем с VirtualDOM в реакте, то не должны обращаться к DOM на прямую, это будет не правильно и может
        повлечь замедление работы системы, то есть мы не можем просто назначить для <textarea></textarea> айди и обратившись к
        нему взять его value и передать, это будет не правильно еще и потому что мы не знаем в какой момент времени элемент с
        <textarea></textarea> будет существовать в DOM.



    В реакте для обращения к элементу <textarea></textarea> мы создадим для него ссылку, и укажем ее название в теге <textarea>
        чтобы между ними создалась связь:
        
        let newPostElement = React.createRef();

        <textarea ref={newPostElement}></textarea>


        Теперь можем обратиться по ссылке(newPostElement) к этому нативному ХТМЛ элементу(current) и взять его содержимое(value):

        let newPostElement = React.createRef();

        let addPost = () => {
            let text = newPostElement.current.value;
            alert(text);
        };

        return (
            <div className="form__new-post">
            <div className="new-post__title">New Post
                <textarea ref={newPostElement}></textarea>
                <button onClick={ addPost } >Add Post</button>
            </div>
            {postsElements}
            </div>
        );

        //*! реакт рекомендует не использовать часто ref(потому что мы по сути тоже минуя реакт обращаемся напрямую к DOM), но так
        как это первый подход с которым мы познакомимся, то пока будем использовать его. Если считывать как у нас в примере 
        значением, мы не меняем ничего в DOM то еще ладно, но если нужно изменить то ref не стоит использовать для этой цели.


    Теперь нужно это значение передать в state profilePage создать там новый пост с новым айди следующем по нумерации и с числом
        лайков likesCount - 0, поэтому столько работы мы не можем возложить на компонент в котором считали значение, а то нарушится
        принцип single responcibility. Также отрисовка компонентов и прокидывание props у нас происходит 1 раз при загрузке 
        страницы и нам нужно заново запустить прокидывание props с новыми значениями чтобы заново произошла перерисовка.

*/}


{/*    ====    32. прокидываем callback через props     ====

    Чтобы изменять данные в state файле в объекте с данными, ф-я по изменению этих данных тоже должна находиться в этом файле.
        Простой пример добавления строки в массив users объекта state ф-й addUser:

        let state = {
            users:['Dima', 'Alex']
        }

        let addUser = (userName) => {
            state.users.push(userName);
        }


    Чтобы вызвать такую ф-ю при нажатии кнопки нужно ее прокинуть как и state через props. Так как ф-я это тоже объект, мы это
        можем сделать, экспортировав ее без не по дефолту(//? а по имени, именная?).



    В state.js добавим ф-ю addPost, она нарушает концепцию "чистой ф-и" потому что параметры которые она принимает не будут к
        ней приходить откуда то, а будут искаться в этом же файле. Но так как это происходит в одном файле то это допустимо
        (куда ни шло). Эта ф-я будет пушить в нужный массив новый объект, тут же создаем структуру объекта(id пока пишем 5 пока
        не важно).

        let addPost = (postMsg) => {
            let newPost ={
                id:5,
                post: postMsg,
                likesCount: 0
            };

            state.profilePage.postsData.push(newPost);
        }


        Для экспорта без дефолта можно сразу перед объявлением переменно писать export, импортировать такую ф-ю нужно иначе, через
        фигурные скобки, в index.js :

        import {addPost} from './state'


    Из index.js будем прокидывать ф-ю через props:

        const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(
            <React.StrictMode>
                <App appState={ state } addPost={ addPost } />
            </React.StrictMode>
        );


    Также дальше прокидываем в Апп и далее в MyPosts через Profile:

         <MyPosts postsData={props.state.postsData} addPost={props.addPost} />


    B уже в MyPosts используем ее - props.addPost(text):

        let addPost = () => {
            let text = newPostElement.current.value;
    //todo  props.addPost(text);
        };

        return (
            <div className="form__new-post">
            <div className="new-post__title">New Post
                <textarea ref={newPostElement}></textarea>
                <button onClick={ addPost } >Add Post</button>
            </div>
            {postsElements}
            </div>
        );


    Теперь после нажатия на кнопку новый пост не видим на странице, хотя добавился в state, потому что нужно запустить render заново.

*/}


{/*    ====    33. Отрисовка поста (зачатки FLUX)      ====

    Теперь после нажатия на кнопку новый пост не видим на странице, хотя добавился в state, потому что нужно запустить render 
        заново. И так может быть много раз, а если нам нужно это использовать минимум несколько раз обернем эти действия в 
        ф-ю в index.js rerenderEntireTree(пререрисовать всё дерево) - пока будем перерисовывать все дерево когда изменится state, 
        поэтому в ф-ю rerenderEntireTree вставим ф-ю ренедера всего App, и после объявления этой ф-и её нужно первый раз запустить
        чтобы произошел первый render:

        let rerenderEntireTree = () => {
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(
            <React.StrictMode>
                <App appState={state}/>
            </React.StrictMode>
            );
        }

        rerenderEntireTree();



    Теперь можем запускать ф-ю перерисовки в файле state так как он хранит state и знает когда state изменится. Хотелось бы 
        //*! импортировать rerenderEntireTree из index.js в state, но так делать нельзя потому что мы уже из state импортируем в 
        index.js.(//todo почему так нельзя делать???). 
        Чтобы это обойти создаем новый файл render.js в него помещаем ф-ю rerenderEntireTree и импортируем её в index.js
        и в state.js. Теперь в файлах такой код:


        state.js - импортируем {rerenderEntireTree} и в параметрах передаем ей state

            let addPost = (postMsg) => {
                let newPost ={
                    id:5,
                    post: postMsg,
                    likesCount: 0
                };

                state.profilePage.postsData.push(newPost);
                rerenderEntireTree(state);
            }


        index.js - убираем лишний импорт(остается импорт {rerenderEntireTree} from render + state from redux)

            rerenderEntireTree(state);


        render.js(импорт реакт, реактДОМ,  индекс.ксс, Апп, {addPost} from state - импортируем тоже из стейта?,
            тогда смысл всего этого, получился тот же импорт только не самого стейта, хммм). 

            export let rerenderEntireTree = (state) => {
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(
                <React.StrictMode>
                    <App appState={state} addPost={addPost} /> 
                </React.StrictMode>
                );
            }


    Теперь получается так что рендер происходит в render.js и эта ф-я импортируется в state и script, когда в стейт происходит
        добавление нового элемента вызывается ф-я rerenderEntireTree и ей передается новый стейт, также этот стейт импортируется
        в script и там ф-я рендера вызывается еще раз с новым стейтом, который по props передается в рендер благодаря чему и 
        формируется новая структура. В script происходит первый запуск рендера.



    Также добавим очистку поля ввода после нажатия кнопки:

        let addPost = () => {
            let text = newPostElement.current.value;
            props.addPost(text);
            newPostElement.current.value = '';
        };



    Flux - архитектура(подход к организации потока данных когда UI пересылает данные в BLL, а оттуда приходят новые данные на 
        сосновании которых нжно перерисоваыть структуру). Одна из ее реализаций - Redux.
        //*!  Прочитать как на самом деле это звучит.

    Сейчас у нас нарушена эта архитектура, потому что UI не должен меняться пока не изменяться данные BLL и не придут обратно, а у
        нас сейчас можно что-то напечатать в <textarea> получается UI изменился, а BLL не изменился, это исправим в следующем 
        уроке.

*/}


{/*    ====    34. FLUX круговорот на каждый символ      ====

    //*! Мы используем свой state пока что как менеджмент данных, это не тот стандартный setState реакта.

    Для небольших проектов можно использовать Локальный state например в App.js как часть классового компонента. Плючы при таком 
        методе - можно использовать setState, нам бы не нужно было заморачиваться с перерендером структуры, созданием render.js
        и прокидыванием стейта из другого файла - такой подход используется в обучающих или небольших проектах. Но при таком
        подходе если данных будет много, нужно будет дробить их и оборачивать кучей ф-й чтобы было понятно что мы обновляем,
        соответственно в Апп будет очень много кода для изменения state который к ней не относится.
        

    Второй подход - можно сделать локальные стейты почти для каждого компонента. Плюсы - быстрое построение приложения. Минусы -
        трудность с поддержкой - трудно и долго выискивать ошибку в случае краша приложения.


    Так как мы делаем - выносим все данные и ф-ии для их обработки в отдельный файл - это принцип Redux(принцип функционального
        программирования).


    Таких системи подходов state managment очень много(локальный стейт, Redux, MobX, ...) у всех есть свои плюсы и минусы и
        нужно зная эти ньюансы выбрать подход для конкретного приложения(некоторые могут выбирать ориентируясь на то что им больше
        нравится или на то с чем больше работали).



    Мы сконцентрируемся на Redux он реализовывает Flux архитектуру(круговорот данных от UI в BLL и наоборот).

    Сделаем так чтобы нельзя было написать даже символ в поле <textarea> без изменения в state и перерендывания. В MyPosts
        изменим <textarea ref={newPostElement}></textarea> так чтобы он был самозакрывающимся и допищем ему фиксированное 
        значение аттрибута value. 

            extarea ref={newPostElement} value='React samurai' />

        Теперь видим это значение на странице в текстовом поле и не можем ничего написать другого. А в консоле выскочила ошибка
        что мы использовали value без onChange обработчика - так отренедерится поле "только для чтения", и если поле должно
        изменяться нужно использовать defaultValue. Или установить onChange или readOnly.


        Добавим обработчик onChange в текстэрэа, пока пустой, видим что ошибка пропала, но в поле текст не изменяется.:

            let onPostChange = () => {

            };

            return (
            <div className={style.form__newPost}>
                <div className={style.newPost__title}>New Post
                <textarea ref={newPostElement} onChange={ onPostChange }></textarea>


        Чтобы оно изменялось от state пропишем:

            < ref={newPostElement} onChange={ onPostChange } value={props.newPostText} />


        В state в profilePage добавим свойство newPostText, оно будет передаваться вместе со state внутри profilePage

            profilePage: {
                postsData: [
                    { id: 1, post: "yo", likesCount: 12 },
                    { id: 2, post: "It's my fist post.", likesCount: 11 },
                    { id: 3, post: "0", likesCount: 50 }],
                newPostText: 'React samurai'
            },


        В Апп переименуем state который отправляем для Profile на profilePage - чтобы знать что мы отправляем только часть state,
            далее нам нужно переименовать в Profile путь из props

            <Route path="/profile"  element={<Profile profilePage={props.appState.profilePage} 
                                                addPost={props.addPost} />} />


        В Profile переименовываем путь props - props.profilePage.postsData и добавляем newPostText как props для MyPosts

            const Profile = (props) => {
                return(
                    <main>
                        <ProfileInfo />
                        <MyPosts postsData={props.profilePage.postsData}
                                newPostText={props.profilePage.newPostText}
                                addPost={props.addPost}/>
                    </main>
                );
            }


    Теперь текст в поле на сайте будет - React samurai - те данные которые пришли в форму по props, изменить их пока нельзя
        на сайте потому что у нас нету механизма отправки value в state, а так как данные там не изменятся то props нам не
        дает напечатать то что мы хотим. Воспользуемся тем же методом принятия value и отправки его в state как и при клике
        на кнопку, только изменим ф-ю которая будет обрабатывать принятие данных, а ссылка на значение поля у нас уже есть
        и тогда в state произойдет изменение, сработает ререндер и вы увидим символ который напечатали.
        

        В state создаем и сразу экспортируем ф-ю которая будет присваивать приходящее к нам значение - свойству объекта newPostText

            export let updateNewPostText = (newText) => {
                state.profilePage.newPostText = newText;
                rerenderEntireTree(state);
            }

            теперь ее нужно по пропсам прокинуть в MyPosts

        
        В render импортируем ф-ю и добавляем в props для Апп. //*! Всётаки цикл импорт-экспорт между файлами в данном случае 
           //*! render и state остался, в следующих уроках мы это пофиксим.

            import React from 'react';
            import ReactDOM from 'react-dom/client';
            import './index.css';
            import App from './App';
            import { addPost } from './Components/redux/state';
            import { updateNewPostText } from './Components/redux/state';


            export let rerenderEntireTree = (state) => {
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(
                    <React.StrictMode>
                    <App appState={state} addPost={addPost} updateNewPostText={updateNewPostText}/>
                    </React.StrictMode>
                );
            }


        В Апп прокинем ф-ю дальше в Profile

            <Route path="/profile"  element={<Profile profilePage={props.appState.profilePage}
                                                updateNewPostText={props.updateNewPostText} 
                                                addPost={props.addPost} />} />


        В Profile прокидываем дальше в MyPosts

            const Profile = (props) => {
                return(
                    <main>
                        <ProfileInfo />
                        <MyPosts postsData={props.profilePage.postsData}
                                newPostText={props.profilePage.newPostText}
                                updateNewPostText={props.updateNewPostText} 
                                addPost={props.addPost}/>
                    </main>
                );
            }


        В MyPosts теперь можно вызывать эту ф-ю и передавать ей значение поля для занесения его в state

            let onPostChange = () => {
                let text = newPostElement.current.value;
                props.updateNewPostText(text);
            };


        Теперь в поле впечатываются символы и при клике на кнопку, добавляется пост с этим текстом но теперь при этом не 
        обнуляется текст в окне, потому что он теперь хранится в state. Нужно добавить в ф-ю клика кнопки вместо старого 
        зануления вызов ф-ии updateNewPostText с пустой строкой.

            let addPost = () => {
                let text = newPostElement.current.value;
                props.addPost(text);
                props.updateNewPostText('');
            };


    Доработаем. В ф-и addPost мы пересылаем значение поля из UI но оно же у нас уже хранится в state в newPostText, поэтому
        его можно не отправлять из UI, а брать напрямую из state. Удаляем из addPost отправку данных.

        let addPost = () => {
            props.addPost();
            props.updateNewPostText('');
        };

        
    в state теперь нам тоже не нужно его получать как параметр ф-и

        export let addPost = () => {
            let newPost = {
                id:5,
                post: state.profilePage.newPostText,
                likesCount: 0
            }

            state.profilePage.postsData.push(newPost);
            rerenderEntireTree(state);
        }

    
    Доработаем. Сейчас у нас очистка поля после добавления поста происходит в UI, но если пользователь ввел слишком длинный пост,
        и его не пропустил BLL, то пост не добавится, а поле обнулится и пользователь будет недоволен. Можно передать очистку
        поля в BLL state.

        В MyPosts удаляем ф-ю зануления

           let addPost = () => {
                props.addPost();
            };


        В state теперь в ф-ю addPost добавим обнуление свойства newPostText

            export let addPost = () => {
                let newPost = {
                    id:5,
                    post: state.profilePage.newPostText,
                    likesCount: 0
                }

                state.profilePage.postsData.push(newPost);
                state.profilePage.newPostText = '';
                rerenderEntireTree(state);
            }

*/}


{/*    ====    35. callback, subscribe, observer      ====

    Так как автор немного запутался с круговоротом информации при переносе ф-и rerenderEntireTree в render, и у нас осталась 
        циклическая зависимость между файлами, избавимся от render, перенесем всё назад в index.js (удалим импорт из рендера,
        и експорт). 

        import React from 'react';
        import ReactDOM from 'react-dom/client';
        import './index.css';
        import App from './App';
        import state from './Components/redux/state'
        import { addPost } from './Components/redux/state';
        import { updateNewPostText } from './Components/redux/state';


        let rerenderEntireTree = (state) => {
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(
                <React.StrictMode>
                <App appState={state} addPost={addPost} updateNewPostText={updateNewPostText}/>
                </React.StrictMode>
            );
        }

        rerenderEntireTree(state);

        
    В state мы снова не можем импотировать эту ф-ю, но она нужна для того чтоб происходил ререндер, автор пока сделал локальную
        ф-ю с таким же названием в state, проект загрузился первый раз, но при клике на кнопку или вводе текста в поле ререндера
        не происходит, хотя в state данные отправляются.

        let rerenderEntireTree = () => {

        }


    Используем принцип колбека. В index мы импортируем компонент Апп и при его вызове в аттрибутах ему назад передаем нужную 
        информацию через props. Сделаем также и для state, создадим ф-ю subscribe которая будет принимать параметр observer 
        (ф-и которые н будем переопределять объявим с const вместо let)

            export const addPost = () => {
                let newPost = {
                    id:5,
                    post: state.profilePage.newPostText,
                    likesCount: 0
                }

                state.profilePage.postsData.push(newPost);
                state.profilePage.newPostText = '';
                rerenderEntireTree(state);
            }

            export const updateNewPostText = (newText) => {
                state.profilePage.newPostText = newText;
                rerenderEntireTree(state);
            }

            export const subscribe = (observer) => {
                
            }

        
        index. импортируем subscribe в индекс и запустив передадим ф-ю rerenderEntireTree как параметр, отдав ее как колбек в state

            import {subscribe} from './Components/redux/state';

            let rerenderEntireTree = (state) => {
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(
                <React.StrictMode>
                <App appState={state} addPost={addPost} updateNewPostText={updateNewPostText}/>
                </React.StrictMode>
            );
            }

            rerenderEntireTree(state);

            subscribe(rerenderEntireTree);


        Теперь в state можем применить эту ф-ю. Она приходит в ф-ю subscribe и становится параметром observer, значит можем 
        присвоить этот параметр переменной rerenderEntireTree которой мы ранее прописали ф-ю заглушку, и заглушка заменяется
        обычной ф-й rerenderEntireTree из index.


            export const subscribe = (observer) => {
                rerenderEntireTree = observer;
            }


    //*! При таком способе(ререндер всего приложения, и возможно из-за того что ререндерим форму каждый раз когда вводится символ) теряется фокус на 
        //*! форму, и после каждого введенного символа приходится снова кликать на форму выбирая ее в фокус.
    //todo observer - это паттерн, почитать про него.

*/}


{/*    ====    36. Зачем нам объекты (ООП поверхностно)     ====

    Рассмотрим базовый ООП принципы потому что реакт использует компоненты ООП. Наш объект state просто хранилище данных, а ооп
        объект имеет еще и методы(ф-и), к которым мы можем обратится и вызвать их:

        let man = {
            name: 'Dima',
            age: 31,
            sayName() {
                alert(this.name);
            }
        }

        console.log(man.name);
        man.sayName();

        при вызове man.sayName(); - метод обращается к свойству своего объекта по слову this, подразумевая "этот" объект.


    С объектом можно взаимодействовать через его интерфейс(это все его свойства и методы) и просто вызывая нужный метод не
        задумываться как он внутри реализован(он инкапсулирован - скрыты детали, скрыт от нас)

        let page = {
            title: 'Title',
            content: ``,
            render() {
                document.title = this.title;
                document.write(this.content);
            }
        }

        page.content = `<div>Some content</div>`;
        page.render();


    Часто мы хотим чтобы некоторые или все свойства были защищенные(к которым нельзя обратиться напрямую), была договоренность что
        такие свойста обозначали с нижним подчеркивание в начале имени и их не нужно использовать напрямую(хотя техническая
        возможность есть). Такие свойства и методы в отличие от приватных передаются по наследованию хотя не поддерживаются
        синтаксисом языка JS.

        Чтобы работать с таким свойством нужно использовать сеттеры и геттеры. Сеттер - метод который устанавливает принятое 
        значение какому-то свойству. Геттер - ф-я коотрая возвращает значение свойства. В примере нижу это не set и get методы
        языка JS, а названные так втором ф-ии которые эмулируют их поведение. Ф-ии использовать приоритетнее для последующего
        расширения объекта, в следующем посте можно про это все прочитать. При таком подходе с защищаенными свойствами у нас 
        больше возможности контролировать работу с этими свойствами(полный перечень плюсов ниже в посте).

        let page2 = {
            title: 'Title',
            _content: ``,
            setContent(value) {
                //логгирование
                // опасные значения
                this._content = value;
            },
            getContent() {
                return this._content;
            },
            render: function () {
                document.write(this._content);
            }
        }

        page2.setContent(`<div>Some content</div>`);
        console.log(page2.getContent() );
        page2.render();


    Рассмотрим объект store, у него есть защищенные ф-ии и набор данных к которым обращаться можно через обычный ф-ии(методы). В
        не объеденены данные и логика(ф-ии) которые с ними работают, как у нас в state, только у нас ф-ии наъодятся вне объекта.

        let store = {
            _subscriber() {
                console.log('no subscribers')
            },
            _state: {
                firstName: 'Jo',
                lastName: 'Smith'
            },
            getState() {
                return this._state;
            },
            subscribe(observer) {
                this._subscriber = observer;
            },
            setFirstName(value) {
                this._state.firstName = value;
                this._subscriber();
            }
        }

        Для пользователя взаимодействие выглядит так и он ничего не знает о внутреннем устройстве объекта store

        let state = store.getState();
        store.setFirstName('John');
        state = store.getState();

        store.subscribe( () => {
            let state = store.getState();
            renderPage(state);
        } );

        store.setFirstName('York');

*/}


{/* ЗАЩИЩЕННЫЕ vs ПРИВАТНЫЕ

В терминах ООП отделение внутреннего интерфейса от внешнего называется инкапсуляция.


Это даёт следующие выгоды:

Защита для пользователей, чтобы они не выстрелили себе в ногу
Представьте себе, что есть команда разработчиков, использующая кофеварку. Она была изготовлена компанией «Лучшие Кофеварки» и
работает нормально, но защитный кожух был снят. Внутренний интерфейс стал доступен извне.

Все разработчики культурны – они используют кофеварку по назначению. Но один из них, Джон, решил, что он самый умный, и сделал
 некоторые изменения во внутренностях кофеварки. После чего кофеварка вышла из строя через два дня.

Это, конечно, не вина Джона, а скорее человека, который снял защитный кожух и позволил Джону делать свои манипуляции.

То же самое в программировании. Если пользователь класса изменит вещи, не предназначенные для изменения извне – последствия
 непредсказуемы.


Поддерживаемость
Ситуация в программировании сложнее, чем с реальной кофеваркой, потому что мы не просто покупаем её один раз. Код постоянно
 подвергается разработке и улучшению.

Если мы чётко отделим внутренний интерфейс, то разработчик класса сможет свободно менять его внутренние свойства и методы, даже не
 информируя пользователей…

Если вы разработчик такого класса, то приятно знать, что приватные методы можно безопасно переименовывать, их параметры можно
 изменять и даже удалять, потому что от них не зависит никакой внешний код.

В новой версии вы можете полностью всё переписать, но пользователю будет легко обновиться, если внешний интерфейс остался такой же.


Сокрытие сложности
Люди обожают использовать простые вещи. По крайней мере, снаружи. Что внутри – это другое дело.

Программисты не являются исключением.

Всегда удобно, когда детали реализации скрыты, и доступен простой, хорошо документированный внешний интерфейс.

Для сокрытия внутреннего интерфейса мы используем защищённые или приватные свойства:

Защищённые поля имеют префикс _. Это хорошо известное соглашение, не поддерживаемое на уровне языка. Программисты должны обращаться
 к полю, начинающемуся с _, только из его класса и классов, унаследованных от него.

Приватные поля имеют префикс #. JavaScript гарантирует, что мы можем получить доступ к таким полям только внутри класса.

В настоящее время приватные поля не очень хорошо поддерживаются в браузерах, но можно использовать полифил.


Полная статья - https://learn.javascript.ru/private-protected-properties-methods

*/}


{/*    ====    37. Store, state, ООП, рефакторинг     ====

    Рефакторим state в Store так как в предыдущем уроке - собираем в один объект объект с данными + ф-ии и даьше будем прокидывать
        уже одним объектом до момента когда компонентам нужно будет передавать только те props которые им нужны. Таким образом
        //*! делаем подготовку к созданию своего Redux. Не используем реактовский setState(локальный стейт в классе) потому что в
        //*! больших приложениях он не используется, частично будем применять для сохранения локальных данных компонента.


    В state.js переносим всё в объект store. 
        Объект с данными state теперь будет свойством и мы его сделаем защищенным, не хотим чтобы из вне к нему был доступ. Для
        доступа к нему сделаем ф-ю гетер getState которая будет возвращать наш защищенный _state. rerenderEntireTree тоже сделаем
        защищенной и изменим название на _callSubscriber - уведомить подписчика(у нас один подписчик - ф-я rerenderEntireTree,
        которая приходит из index.js, так мы спроектировали систему):
        
        let store = {
            _state: {
                profilePage: {
                    postsData: [
                        { id: 1, post: "yo", likesCount: 12 },
                        { id: 2, post: "It's my fist post.", likesCount: 11 },
                        { id: 3, post: "0", likesCount: 50 }],
                    newPostText: 'React samurai'
                },
                dialogsPage: {
                    dialogsData: [
                        { id: 1, name: "Dmitriy" },
                        { id: 2, name: "Andrey" },
                        { id: 3, name: "Valera" },
                        { id: 4, name: "Sveta" },
                        { id: 5, name: "Viktor" }],
                    messagesData: [
                        { id: 1, msg: "Hi" },
                        { id: 2, msg: "Yo" },
                        { id: 3, msg: "What's up?" },
                        { id: 4, msg: "Hi" },
                        { id: 5, msg: "Yo" }]
                }
            },
            getState () {
                return this._state;
            },
            _callSubscriber () {

            },
            addPost ()  {
                let newPost = {
                    id: 5,
                    post: this._state.profilePage.newPostText,
                    likesCount: 0
                }
            
                this._state.profilePage.postsData.push(newPost);
                this._state.profilePage.newPostText = '';
                this._callSubscriber(this._state);
            },
            updateNewPostText (newText) {
                this._state.profilePage.newPostText = newText;
                this._callSubscriber(this._state);
            },
            subscribe (observer) {
                this._callSubscriber = observer;
            }
        }

        export default store;
        window.store = store; - чтобы можно было обратиться к объекту из браузера.


    В index.js теперь импортируем store и дальше из него извлекаем нужные свойства и методы, для получения state нужно ВЫЗВАТЬ метод
        getState:

        import React from 'react';
        import ReactDOM from 'react-dom/client';
        import './index.css';
        import App from './App';
        import store from './Components/redux/state'

        let rerenderEntireTree = (store) => {
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <React.StrictMode>
            <App appState={store.getState()} addPost={store.addPost} updateNewPostText={store.updateNewPostText}/>
            </React.StrictMode>
        );
        }

        rerenderEntireTree(store.getState());

        store.subscribe(rerenderEntireTree);

    
    После рефакторинга сайт отрендерился, но при добавлении поста выкидывает ошибку - не может прочесть свойство profilePage of
        undefined в state.js addPost - post: this._state.profilePage.newPostText. При дебаггинге видим что в getState - 
        this._state - тот объект который нам нужен, а в addPost в this._state - лежит другой объект в котором есть: addPost,
        newPostText, posts, updateNewPostText - понимаем что это не наше объект. 

        Так происходит потому что в индекс мы вызываем метод store.getState() - от имени store и его контекст сохраняется, а 
        остальные методы мы передаем для дальнейшего вызова, пройдя до ф-ии вызова видим что ф-я addPost вызывается в MyPosts
        от пропсов - props.addPost(); поэтому берет контекст просов и там не находит state. Чтобы такого не было нужно при
        первой передаче ф-ии addPost забайндить(привязать) ее(как и все подобные ф-ии) к объекту store - таким образом не
        важно кто будет вызывать ф-ю она будет работать с контекстом this - объекта store

            let rerenderEntireTree = (store) => {
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(
                    <React.StrictMode>
                    <App appState={store.getState()} addPost={store.addPost.bind(store)} 
                                                     updateNewPostText={store.updateNewPostText.bind(store)}/>
                    </React.StrictMode>
                );
            }

            //todo почитать про bind!!!


        //*! автор прописал state в принимаемых параметрах и вместо вызова ф-ии getState, как же мы получим _sate без такого 
        //*!вызова непонятно, и как будем передавать ф-ии из store, но у него все работает. 
            let rerenderEntireTree = (state) => {
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(
                    <React.StrictMode>
                    <App appState={state}

*/}


{/*    ====    38. dispatch и action     ====

    Сейчас у нас несколько ф-й которые мы прокидываем через пропсы в нужные компоненты, по мере увеличения приложения их будет
        очень много, чтобы не прокидывать их все, воспользуемся ф-й dispatch() - она решает и другие задачи, но в нашем случае
        используем ее чтобы минимизировать количество записей аттрибутов для пропсов компонентов.
        
        в state защищенные  свойства и методы сгруппируем, далее отделим пустыми строками addPost и updateNewPostText от других
        методов, потому что они изменяют  _state, добавим метод dispatch(переводится как отсылка, отправление) он будет принимать
        в параметр объект - action(действие), у этого объекта будет обязательное свойство type с текстом в котором будет написано 
        какое действие совершить, например "ADD-POST" благодаря которому dispatch будет знать какой метод запустить. Внутри 
        dispatch проводится сравнение значения action и при совпадении будем выполнять заданный код, то есть все методы (которые
        изменяют _state ???) перенесем в него и соответственно во внешний мир будем отдавать только этот метод(а getState?). Также
        если для работы запускаемого метода нужны дополнительные данные, передаем их как еще одно свойство объекта action. Так как
        в addPost ничего не передавалось его не меняем, а для updateNewPostText(newText) - передавался newText, значит в коде
        допишем ссылку на него как на свойство из объекта action.newText
            
            dispatch(action) {
                if (action.type === "ADD-POST") {
                    let newPost = {
                        id: 5,
                        post: this._state.profilePage.newPostText,
                        likesCount: 0
                    }

                    this._state.profilePage.postsData.push(newPost);
                    this._state.profilePage.newPostText = '';
                    this._callSubscriber(this._state);

                } else if (action.type === "UPDATE-NEW-POST-TEXT") {
                    this._state.profilePage.newPostText = action.newText;
                    this._callSubscriber(this._state);
                }
            }

            Можно было сделать эти методы приватные и из диспатча обращаться к ним через this и это правильнее, но пока мы учимся
            остави так(в будущем возможно изменим).


        в index отправляем по пропсам через аттрибут компонента App один единственный метод dispatch

            let rerenderEntireTree = (props) => {
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(
                    <React.StrictMode>
                    <App appState={props} dispatch={store.dispatch.bind(store)} />
                    </React.StrictMode>
                );
            }


        в App берем dispatch из пропсов и прокидываем дальше

            <Route path="/profile"  element={<Profile profilePage={props.appState.profilePage}
                                                dispatch={props.dispatch} />} />


        В Profile прокидываем в MyPosts

            <MyPosts postsData={props.profilePage.postsData}
                    newPostText={props.profilePage.newPostText}
                    dispatch={props.dispatch} />


        В MyPosts изменяем вызываемые ф-и(вызываем dispatch и передаем объекты с нужными свойствами)
            
            let addPost = () => {
                props.dispatch({ type: 'ADD-POST'});
            };

            let onPostChange = () => {
                let text = newPostElement.current.value;
                props.dispatch({ type: 'UPDATE-NEW-POST-TEXT', newText: text });
            };

*/}


{/*    ====    39. action creator, action type     ====

    Так как компоненты должны придерживаться сингл респонсибилити принципа нужно вынести создание action объекта из компонента и
        поместить эту логику в store, создадим ф-ю actionCreator(), которая будет генерировать нужный action объект и его будем
        просто передавать в dispatch в нужной ф-и.


    В MyPost мы прописывали action прямо в вызове ф-и dispatch - props.dispatch({ type: 'ADD-POST'}), пропишем ф-ю создания
        action для addPost. Она будет возвращать объект с нужным значением типа для этой ф-ии, и теперь в праметрах addPost
        сделаем вызов этой ф-и. Также сделаем и для onPostChange только еще передадим для updateNewPostTextActionCreator в
        параметры аргумент text.

        let addPostActionCreator = () => {
            return {
                type: 'ADD-POST'
            }
        }

        let updateNewPostTextActionCreator = (text) => {
            return { type: 'UPDATE-NEW-POST-TEXT', newText: text }
        }

        const MyPosts = (props) => {

            let postsElements = props.postsData.map((el, ind) => <Post key={ind} msg={el.post} likesCount={el.likesCount} />);
        
            let newPostElement = React.createRef();

            let addPost = () => {
            props.dispatch( addPostActionCreator() );
            };

            let onPostChange = () => {
            let text = newPostElement.current.value;
            props.dispatch( updateNewPostTextActionCreator(text) );
            };


    Перенесем эти экшнкриэйторы просто в state.js и експортируем их прямо в компонент которому они нужны, потому как это логика
        и она не должна находится в компоненте.

                } else if (action.type === "UPDATE-NEW-POST-TEXT") {
                    this._state.profilePage.newPostText = action.newText;
                    this._callSubscriber(this._state);
                }
            }
        }

        export const addPostActionCreator = () => {
            return {
                type: 'ADD-POST'
            }
        }

        export const updateNewPostTextActionCreator = (text) => {
            return { type: 'UPDATE-NEW-POST-TEXT', newText: text }
        }

        export default store;


    В MyPosts делаем их импорт:
    
        import { addPostActionCreator, updateNewPostTextActionCreator } from "../../redux/state";



    Так как у нас свойство type объекта action - строка и она не изменяется, для уменьшения возникновения ошибки при ее написании
        вынесем эти строки в отдельные переменные и будем использовать их, теперь нам будет доступен автокомплитер при написании
        этих переменных и даже если мы сделаем ошибка в названии такой переменной то код не скомпилируется и сразу укажет нам
        где ошибка. Поместим их в начале файла потому что уже в store они у нас используются.

        const ADD_POST = 'ADD-POST';
        const UPDATE_NEW_POST_TEXT = 'UPDATE-NEW-POST-TEXT';

        ...
        ...
        ...

                        } else if (action.type === UPDATE_NEW_POST_TEXT) {
                    this._state.profilePage.newPostText = action.newText;
                    this._callSubscriber(this._state);
                }
            }
        }


        export const addPostActionCreator = () => {
            return {
                type: ADD_POST
            }
        }

        export const updateNewPostTextActionCreator = (text) => {
            return { type: UPDATE_NEW_POST_TEXT, newText: text }
        }



    Зарефакторим эти ф-ии чтобы они стали меньше:

        export const addPostActionCreator = () => ({ type: ADD_POST })

*/}


{/*    ====    40. Практика - добавление сообщения     ====

    Добавим в Dialogs текстовое поле и кнопку для того чтобы добавлять сообщение. Сделаем по аналогии с Profile.


    В state в объект dialogsPage добавим свойство newMsgText:

            messagesData: [
                { id: 1, msg: "Hi" },
                { id: 2, msg: "Yo" },
                { id: 3, msg: "What's up?" },
                { id: 4, msg: "Hi" },
                { id: 5, msg: "Yo" }],
            newMsgBody: 'Type here'
        }


        создадим ф-ии для изменения состояния _state в dispatch, константы для имен type и ф-и Creator(слово action опустим):

        const ADD_POST = 'ADD-POST';
        const SEND_MSG = 'SEND-MSG';
        const UPDATE_NEW_POST_TEXT = 'UPDATE-NEW-POST-TEXT';
        const UPDATE_NEW_MSG_BODY = 'UPDATE-NEW-MSG-BODY';

        let store = {
            _state: {
                profilePage: {
                    postsData: [
                        { id: 1, post: "yo", likesCount: 12 },
                        { id: 2, post: "It's my fist post.", likesCount: 11 },
                        { id: 3, post: "0", likesCount: 50 }],
                    newPostText: 'React samurai'
                },
                dialogsPage: {
                    dialogsData: [
                        { id: 1, name: "Dmitriy" },
                        { id: 2, name: "Andrey" },
                        { id: 3, name: "Valera" },
                        { id: 4, name: "Sveta" },
                        { id: 5, name: "Viktor" }],
                    messagesData: [
                        { id: 1, msg: "Hi" },
                        { id: 2, msg: "Yo" },
                        { id: 3, msg: "What's up?" },
                        { id: 4, msg: "Hi" },
                        { id: 5, msg: "Yo" }],
                    newMsgBody: 'Type here'
                }
            },
            _callSubscriber() {

            },

            getState() {
                return this._state;
            },
            subscribe(observer) {
                this._callSubscriber = observer;
            },

            addPost() {
                let newPost = {
                    id: 5,
                    post: this._state.profilePage.newPostText,
                    likesCount: 0
                }

                this._state.profilePage.postsData.push(newPost);
                this._state.profilePage.newPostText = '';
                this._callSubscriber(this._state);
            },
            updateNewPostText(newText) {
                this._state.profilePage.newPostText = newText;
                this._callSubscriber(this._state);
            },

            dispatch(action) {
                if (action.type === ADD_POST) {
                    let newPost = {
                        id: 5,
                        post: this._state.profilePage.newPostText,
                        likesCount: 0
                    }

                    this._state.profilePage.postsData.push(newPost);
                    this._state.profilePage.newPostText = '';
                    this._callSubscriber(this._state);

                } else if (action.type === UPDATE_NEW_POST_TEXT) {
                    this._state.profilePage.newPostText = action.newText;
                    this._callSubscriber(this._state);

                } else if (action.type === UPDATE_NEW_MSG_BODY) {
                    this._state.dialogsPage.newMsgBody = action.msgBody;
                    this._callSubscriber(this._state);

                } else if (action.type === SEND_MSG) {
                    let newMsg = {
                        id: 6,
                        msg: this._state.dialogsPage.newMsgBody
                    };

                    this._state.dialogsPage.messagesData.push(newMsg);
                    this._state.dialogsPage.newMsgBody = '';
                    this._callSubscriber(this._state);
                }
            }
        }


        export const addPostActionCreator = () => ({ type: ADD_POST })

        export const updateNewPostTextActionCreator = (text) => {
            return { type: UPDATE_NEW_POST_TEXT, newText: text }
        }

        export const sendMsgCreator = () => ({ type: SEND_MSG })

        export const updateNewMsgBodyCreator = (msgBody) => {
            return { type: UPDATE_NEW_MSG_BODY, msgBody: msgBody }
        }

        export default store;



    В Апп передадим dispatch для Dialogs //? возможно нужно добавить store в пути:

        <Route path="/dialogs" element={<Dialogs state={props.appState.dialogsPage} 
                        dispatch={props.dispatch} />} />


    Проведем изменения в компоненте Dialogs импортируем ф-ии Creator и используем их. Не будем использовать ref, а получим value
        textarea через событие которое приходит в ф-ю которую вызывает textarea из самой же textarea(событие назовем "e" и у его
        target(текстэрэа) возьмем значение(value)):

        Автор решил передать в indexe весь store, дальше прокинул его в Апп также store={props.store} прямо в Dialog, там в
        переменную state присвоил store через геттер, и убрал везде обращение к props? так как мы теперь будем обращаться к 
        локальной переменной state: let state = props.store.getState().dialogsPage;  Я пока оставлю как есть. Тем более так
        он говорит хуже потому что не нужно давать компоненту лишнюю информацию, и он забыл забиндить dispatch в Dialogs.
        

        import React from "react";
        import { NavLink } from "react-router-dom";
        import { sendMsgCreator, updateNewMsgBodyCreator } from "../redux/state";
        import style from './Dialogs.module.css'


        const DialogItem = (props) => {
        return (
            <div className={style.dialog}>
            <NavLink to={"/dialogs/" + props.id}>{props.name}</NavLink>
            </div>
        );
        }

        const Message = (props) => {
        return (
            <div className={style.message}>{props.msg}</div>
        );
        }


        const Dialogs = (props) => {

        let dialogsElements = props.state.dialogsData.map(el => (
            <DialogItem name={el.name} id={el.id} />
        ));

        let messagesElements = props.state.messagesData.map(el => (
            <Message msg={el.msg} />
        ));

        let onSendMsgClick = () => {
            props.dispatch( sendMsgCreator() );
        }
        
        let onNewMsgChange = (e) => {
            let msgBody = e.target.value;
            props.dispatch( updateNewMsgBodyCreator(msgBody) );
        }


        return (
            <main className={style.dialogs}>
            <div className={style.dialogsItems}>
                {dialogsElements}
            </div>
            <div className={style.messages}>
                <div>{messagesElements}</div>
                <div><textarea placeholder='' value={props.newMsgBody} onChange={ onNewMsgChange } ></textarea></div>
                <div><button onClick={ onSendMsgClick } >Send</button></div>
            </div>
            </main>
        );
        }

        export default Dialogs;

*/}


{/*    ====    41. Практика - reducer(почти redux)     ====

    Методов в dispatch будет много и он будет большой, если у нас что-то большое мы его дробим на меньшие части. В этом помогут ф-и
        reducer - это чистая ф-я которая принимает state, action если нужно применяет action к этому state и возвращяет НОВЫЙ state,
        или возвращает state который был до этого не измененный если action не подошел.


    Как работает сейчас данные(action объект) приходят из UI(REACT) в dispatch, там его диспатчим, и конкретный action изменяет
        какую-то часть в state. Далее через call subscribe store уведомляет подписчиков о изменении, чтобы подписчики могли вызвать
        getState и получить актуальный state потому что он уже изменился.

        Логики в dispatch очень много, вынесем ее из dispatcha в reducerы. Их будет как минимум столько сколько составных частей в
        state(которые нужно изменять???). Каждый reducer принимает action. Когда диспатчится action он нужен по факту только одному
        reducerу, но store этого не знает, потому что reducerы будут находиться вне store, и store не знает кому нужен этот action
        будет отправлять его каждому reducerу по порядку. Еще reducerу нужна часть state которую нужено изменить, поэтому весь
        state туда не будет передаваться. После этого каждый reducer возвращает измененную часть state если применился action или
        прежнюю часть state которая приходила в reducer все это собирается в НОВЫЙ state и дальше идет уведомление подписчиков
        call subscriber, они запрашивают актуальный state через getState. 



    Создаем reducerы в отдельнчх файлах dialog-reducer.js и profile-reducer.js в папке redux, их будет столько сколько у нас
        подчастей state(dialogsPage и dialogsPage). Автор сделал еще sideber-reducer.js на будущее.

    
    В profile-reducer.js и dialog-reducer.js создаем ф-ии и в них копируем содержимое dispatch и удаляем ненужные для конкретного
        файла данные, также переносим константы для имен. Так как наш редюсер это ф-я и она принимает параметр state, то можно
        избавиться от обращени this. А так как каждому редюсеру будет передаваться только нужная ему часть state то можно упростить
        путь обращения, например:

        this._state.profilePage.postsData.push(newPost); => state.postsData.push(newPost);

        this - удаляется, а в параметр state приходит state.profilePage, поэтому этот путь сокращается до state.

        this._callSubscriber(this._state); - удаляем потому что редюсер делает только преобразования state


    Profile reducer:

        const ADD_POST = 'ADD-POST';
        const UPDATE_NEW_POST_TEXT = 'UPDATE-NEW-POST-TEXT';

        const profileReducer = (state, action) => {
            
            if (action.type === ADD_POST) {
                let newPost = {
                    id: 5,
                    post: state.newPostText,
                    likesCount: 0
                };

                state.postsData.push(newPost);
                state.newPostText = '';

            } else if (action.type === UPDATE_NEW_POST_TEXT) {
                state.newPostText = action.newText;
            } 

            return state;
        }

        export default profileReducer;


    Dialogs reducer:

        const SEND_MSG = 'SEND-MSG';
        const UPDATE_NEW_MSG_BODY = 'UPDATE-NEW-MSG-BODY';

        const dialogsReducer = (state, action) => {

            if (action.type === UPDATE_NEW_MSG_BODY) {
                state.newMsgBody = action.newMsgBody;
            } else if (action.type === SEND_MSG) {
                let newMsg =  state.newMsgBody
                
                state.newMsgBody = '';
                state.messagesData.push({ id: 6, newMsg});
            }

            return state;
        }

        export default dialogsReducer;


    редюсеры готовы, теперь ими нужно воспользоваться - импортируем их в state, вызываем и каждому отдаем соответствующий _state
        и action который пришел в dispatch, так как редюсер отдает нам измененный кусочек state который мы ему передали, то можно
        сразу присвоить его старому кусочку state(для обновления данных) и оставим вызов subscriber для обновления state

        this._state.profilePage = profileReducer(this._state.profilePage, action);


        import dialogsReducer from './dialogs-reducer';
        import profileReducer from './profile-reducer';


        let store = {
            _state: {
                profilePage: {
                    postsData: [
                        { id: 1, post: "yo", likesCount: 12 },
                        { id: 2, post: "It's my fist post.", likesCount: 11 },
                        { id: 3, post: "0", likesCount: 50 }],
                    newPostText: 'Type Post'
                },
                dialogsPage: {
                    dialogsData: [
                        { id: 1, name: "Dmitriy" },
                        { id: 2, name: "Andrey" },
                        { id: 3, name: "Valera" },
                        { id: 4, name: "Sveta" },
                        { id: 5, name: "Viktor" }],
                    messagesData: [
                        { id: 1, msg: "Hi" },
                        { id: 2, msg: "Yo" },
                        { id: 3, msg: "What's up?" },
                        { id: 4, msg: "Hi" },
                        { id: 5, msg: "Yo" }],
                    newMsgBody: 'Type Msg'
                }
            },
            _callSubscriber() {

            },

            getState() {
                return this._state;
            },
            subscribe(observer) {
                this._callSubscriber = observer;
            },

            dispatch(action) {

                this._state.profilePage = profileReducer(this._state.profilePage, action);
                this._state.dialogsPage = dialogsReducer(this._state.dialogsPage, action);

                this._callSubscriber(this._state);
            }
        }


        export const addPostActionCreator = () => ({ type: ADD_POST })

        export const updateNewPostTextActionCreator = (text) => {
            return { type: UPDATE_NEW_POST_TEXT, newText: text }
        }

        export const sendMsgCreator = () => ({ type: SEND_MSG })

        export const updateNewMsgBodyCreator = (msgBody) => {
            return { type: UPDATE_NEW_MSG_BODY, newMsgBody: msgBody }
        }


        export default store;
        window.store = store;



    Сделаем рефаторинг if else в switch в редюсерах(если количество кейсов в if else это конкретное число, а не бесконечное 
        множество автор рекомендует сделать switch вместо if else). Переносим всё в switch, вместо общего return будем в каждом
        case возвращать state и тогда break нам не нужен, и сделаем default если ни один из кейсов не сработал. Перенесем 
        actionCreaterы в редюсеры и сделаем реимпорт их в файлах MyPosts и Dialogs


        Profile reducer:

        const ADD_POST = 'ADD-POST';
        const UPDATE_NEW_POST_TEXT = 'UPDATE-NEW-POST-TEXT';

        const profileReducer = (state, action) => {
            
            switch(action.type) {
                case ADD_POST:
                    let newPost = {
                        id: 5,
                        post: state.newPostText,
                        likesCount: 0
                    };

                    state.postsData.push(newPost);
                    state.newPostText = '';
                    return state;

                case UPDATE_NEW_POST_TEXT:
                    state.newPostText = action.newText;
                    return state;

                default:
                    return state;
            }
        }


        export const addPostActionCreator = () => ({ type: ADD_POST })

        export const updateNewPostTextActionCreator = (text) => {
            return { type: UPDATE_NEW_POST_TEXT, newText: text }
        }

        export default profileReducer;


        Dialogs reducer:

        const SEND_MSG = 'SEND-MSG';
        const UPDATE_NEW_MSG_BODY = 'UPDATE-NEW-MSG-BODY';

        const dialogsReducer = (state, action) => {

            switch(action.type) {
                case UPDATE_NEW_MSG_BODY:
                    state.newMsgBody = action.newMsgBody;
                    return state;

                case SEND_MSG:
                    let newMsg =  state.newMsgBody
                    state.newMsgBody = '';
                    state.messagesData.push({ id: 6, newMsg});
                    return state;

                default:
                    return state;
            }
        }

        export const sendMsgCreator = () => ({ type: SEND_MSG })

        export const updateNewMsgBodyCreator = (msgBody) => {
            return { type: UPDATE_NEW_MSG_BODY, newMsgBody: msgBody }
        }

        export default dialogsReducer;



        Dialogs:
        import { sendMsgCreator, updateNewMsgBodyCreator } from "../redux/dialogs-reducer";


        MyPosts
        import { addPostActionCreator, updateNewPostTextActionCreator } from "../../redux/profile-reducer";

*/}


{/*    ====    42. Практика - redux     ====

    Автор переименовал state.js в store я переименую позже чтобы всё не сломалось(испортировать в index и в render(ф-я addPost
        импортируется из state, уже наверное сломалось)), у него всё заработало и так(вебшторм сам наверное сделал переимспорт).

    
    Redux - отдельная библиотека, нужно ее проинсталлировать: npm install redux --save


    Redux предоставляет некоторые возможности, одна из них - создать store. Создадим новый файл redux-strore.js и в нем пропишем
        createStore при этом его проимпортировав из redux:

        import {createStore} from 'redux';

        let store = createStore();
        
        export default store;

    

    В index.js заменяем импорт нашего store на redux-store. 


    В нашем store была некая логика, в redux-store - методы getState и subscribe - такие же, поэтому тут переписывать ничего не
        нужно. Из dispatch логику мы вынесли в редюсеры поэтому всё что нам нужно сделать для нового dispatch - отдать редюсеры
        в redux-store. Для этого наши редюсеры нужно склеить вместе при момощи метода combineReducers в него передаем объект в
        котором имя ключа = свойство старого _state, а значения импортируем из редюсеров, думаем что есть profilePage и за него
        отвечает profileReducer. Теперь эти закомбайненый редюсеры передаем в createStore. createStore автоматически создает
        внутри себя state у которого есть эти свойства profilePage и dialogsPage.

        import {createStore, combineReducers} from 'redux';
        import  profileReducer from './profile-reducer'
        import dialogsReducer from './dialogs-reducer'

        let reducers = combineReducers({
            profilePage: profileReducer,
            dialogsPage: dialogsReducer
        });

        let store = createStore(reducers);

        export default store;


    Но у созданных свойст state нету значений в redux-store. Для этого редакс посылает action в редюсер чтобы сформировать
        первоначальный state и отобразить его, но мы в редюсерах не прописывали никакой заготовки и action не совпадет ни с одним
        условием и вернет undefined из редюсера. Данные state у нас были захардкожены в старом _state и нам нужно эти данные
        перенести в редюсеры как данные по умолчанию. Создадим переменную для инициализации InitialState в нее поместим нужную
        для этого редюсера часть старого _state и укажем что если state не передали в ф-ю profileReducer то он по умолчанию
        будет равен InitialState - (state = InitialState, action). Также сделаем в dialogs-reducer:


        let InitialState = {
            postsData: [
                { id: 1, post: "yo", likesCount: 12 },
                { id: 2, post: "It's my fist post.", likesCount: 11 },
                { id: 3, post: "0", likesCount: 50 }],
            newPostText: 'Type Post'
        }

        const profileReducer = (state = InitialState, action) => {



        let InitialState = {
            dialogsData: [
                { id: 1, name: "Dmitriy" },
                { id: 2, name: "Andrey" },
                { id: 3, name: "Valera" },
                { id: 4, name: "Sveta" },
                { id: 5, name: "Viktor" }],
            messagesData: [
                { id: 1, msg: "Hi" },
                { id: 2, msg: "Yo" },
                { id: 3, msg: "What's up?" },
                { id: 4, msg: "Hi" },
                { id: 5, msg: "Yo" }],
            newMsgBody: 'Type Msg'
        }

        const dialogsReducer = (state = InitialState, action) => {

*/}


{/*    ====    43. Практика - container component     ====

    Все компоненты у нас ф-е, про классовые забываем. Создадим свой контейнерный компонент. Store нужно прокидывать в компоненты так
        чтобы компонент получил как можно меньше данных, только нужные для его работы, потому что стор это редакс, а компоненты это
        реакт, такой подход позволит использовать компоненты реакта с другим стейт менеджером(моб икс, локальный стейт или хуки).

    В Апп в Диалогс прокидываем весь стор, а он сам выбирает потом что ему нужно, тоесть он слишком умный компонент получился,
        также в Профайл прокидываем сразу выделяемый стейт profilePage(уже лучше), но все равно нам нужно прокидывать диспатч, а
        это всё равно логика из редакса, далее этот диспатч идет в МайПостс и там загрязняет знанием о сторе этот компонент.
        МайПостс все равно нужно что-то получить чтобы сообщить в стейт что нажалась кнопка в МайПостс, но как сделать это без
        диспатча - передать в компонент отдельную коллбек ф-ю, а диспатч это не отдельная ф-я, а универсальная ф-я взаимодействия
        со стором. Раньше у нас так и было колбек ф-ии props.addPost() и props.updateNewPostText(text) вместо диспатча. 
        
    Если перепишем как было по старому с колбеками и компонент МайПостс перестает что-либо знать диспатче или каком-либо интерфейсе 
        редакса, это просто компонент который вызывает коллбек чтобы сообщить родителю, а родитель пусть сам разбирается что с этим
        сделать и как законектится к стору, грубо говоря мы поднимаем эту зависимость из МайПостс и уходим вверх в Профайл, и так 
        далее мы можем зачистить почти всё, но по итогу всеравно кто-то должен общаться со стором. Если мы поднимем таким образом
        всё до Индекса, то нам нужно будет прокидывать кучу колбеков и мы не будем этому рады, так мы один стор прокидываем, а так
        кучу коллбеков, и прийдем к тому с чего начинали, так не годится, нужно выбрать оптимальную точку для общения со стором.

    Чтобы наш компонент был чистым(презентационным) он должен получить минимум данных, например ему в props прийдет объект со 
        свойствами currentValue: 'Yo', onChanged: ()=> {dispatch}, а компонент использует  currentValue для вставки значения в окно
        ввода текста и метод onChanged для вызова когда по кнопке кликают. При этом store и dispatch ему передаваться не будут.
        Для такого поведения обернем компонент другим компонентом(контейнерным) в котором разрешено присутствовать store и dispatch,
        в нем же мы и будем вытаскивать нужные для передачи свойства и методы из store. Этот контейнерный компонент будет обслуживать
        наш презентационный компонент(снабжать данными, выполнять запросы на сервер, ...), таким образом для презентационного
        компонента store остается внешним.


    Создаем контейнерный компонент для MyPosts - копируем MyPosts и переназываем его в MyPostsContainer. Переименовываем название 
        ф-ии в середине с MyPosts на MyPostsContainer. Задача этого контейнерного компонента - отрисовать MyPosts, поэтому в
        return оставляем только <MyPosts /> и будем в него передавать нужные данные. Импортируем MyPosts в MyPostsContainer.


        Очистим таким способом компонент MyPosts от лишних данных, начнем с onPostChange удалим диспатч и будем использовать
        переданную нам ф-ю updateNewPostText, в нее передадим text.

            let onPostChange = () => {
                let text = newPostElement.current.value;
                props.updateNewPostText(text);
            };


        В MyPostsContainer преобразуем эту же ф-ю, теперь она не знает ничего о newPostElement.current, а text получает из
        MyPosts и запускает updateNewPostTextActionCreator из dispatch с принятым text. Эту ф-ю передадим в MyPosts для 
        ее вызова там.

            let onPostChange = (text) => {
                props.dispatch( updateNewPostTextActionCreator(text) );
            };

            return ( <MyPosts updateNewPostText={onPostChange} /> );



        Также очищаем и ф-ю addPost и переименуем ф-ю addPost которую навешиваем на обработчик события чтобы не путаться

            let onAddPost = () => {
                props.addPost();
            };

            <button onClick={ onAddPost }>Add Post</button>


         В MyPostsContainer

            let addPost = () => {
                props.dispatch( addPostActionCreator() );
            };

            return ( <MyPosts updateNewPostText={onPostChange} addPost={addPost}/> );


        Из MyPostsContainer удаляем - postsElementspostsElements так как они используются в самом компоненте MyPosts

        Также прокидываем посты postsData={props.postsData} через MyPostsContainer.

    
    Так как MyPostsContainer разрешено быть грязным компонентом сделаем так чтобы она ожидала весь store:

        let addPost = () => {
            props.store.dispatch( addPostActionCreator() );
        };

        let onPostChange = (text) => {
            props.store.dispatch( updateNewPostTextActionCreator(text) );
        };



    Теперь заменим в Profile компонент MyPosts на MyPostsContainer и все прокидываемые props на store:

        import React from "react";
        import MyPostsContainer from "./MyPosts/MyPostsContainer";
        import ProfileInfo from './ProfileInfo/ProfileInfo'


        const Profile = (props) => {
            return(
                <main>
                    <ProfileInfo />
                    <MyPostsContainer store={props.store} />
                </main>
            );
        }

        export default Profile;
        

    и для работы с этим store в MyPostsContainer вытаскиваем state и прокдываем дальше нужные данные 

        const MyPostsContainer = (props) => {

            let state = props.store.getState();

            let addPost = () => {
                props.store.dispatch( addPostActionCreator() );
            };

            let onPostChange = (text) => {
             props.store.dispatch( updateNewPostTextActionCreator(text) );
            };

            return ( <MyPosts updateNewPostText={onPostChange} addPost={addPost} 
                            postsData={state.profilePage.postsData} 
                            newPostText={state.profilePage.newPostText} /> );
        }


        Получаем ошибку, потому что в Profile не приходит store из Апп потому что там мы его разделяли и вытаскивали
        отдельно state и dispatch, но так как теперь будем рефакторить все компоненты оборачивая их контейнерными
        можно store прокинуть полностью:

        <Route path="/profile"  element={<Profile store={props.store} />} />

        //*! Как заработали методы диспатч если мы байндили их в индексе и передавали дальше, так получается байнд
        //! работать не должен, а у нас все работает.



    //*! пока оборачиваем контейнерами те компоненты где была логика(нажатие на кнопку, и т.п.)
    По аналогии рефакторим Dialogs. 
    

        В Апп заменяем Dialogs на DialogsContainer + импорт
    
            <Route path="/dialogs" element={<DialogsContainer store={props.store} />} />:


        Копируем Dialogs и переименовываем его в DialogsContainer. В нем переименовываем ф-ю и экспортируем ее новое название,
        удаляем разметку и оставляем только компонент <Dialogs/> :

            const DialogsContainer = (props) => {

            let state = props.store.getState().dialogsPage;

            let onSendMsgClick = () => {
                props.store.dispatch(sendMsgCreator());
            };

            let onNewMsgChange = (msgBody) => {
                props.store.dispatch(updateNewMsgBodyCreator(msgBody));
            };


            return  <Dialogs updateNewMsgBody={onNewMsgChange} sendMsg={onSendMsgClick} 
                            dialogsPage={state}/> ;
            }

            export default DialogsContainer;


        В Dialogs изменились:

            let state = props.dialogsPage;

            let onSendMsgClick = () => {
                props.sendMsg();
            };

            let onNewMsgChange = (e) => {
                let msgBody = e.target.value;
                props.updateNewMsgBody(msgBody);
            };


    //*! Исправил ошибку в Диалог редюсерс - теперь всё работает!!! Ну кроме той фишки что уходит из фокус textarea.

    // todo Осталась проблема - каким образом эффективнее прокидывать store, мы прокидываем его через props по всем
        компонентам. И чтобы такого не было будем использовать context, он позволяет в родительском компоненте создать
        контекст(объект который живет в стороне) и он будет доступен всем дочерним компонентам(всему дочернему дереву).
        То есть если для Апп добавить store в context то любой контейнерный компонент которому нужен store, он может
        получить доступ к context напрямую без прокидывания через props. Это тема следующего урока и после него
        //*! перейдем к React-Redux библиотеке, это прослойка между Реактом и Редаксом.

*/}


{/*    ====    44. Практика - Context API     ====

    Context - используется для глобальных вещей(тема сайта, язык, активный пользовтель), не нужно использовать его для всех данных
        потому что так они становятся глобальными и к ним может получить доступ любой дочерний компонент(менее защищены), таже 
        становится труднее дебажить код.


    Попробуем сделать вручную контекст и к нем обратиться. В следующем уроке будем подключать библиотеку которая будет делать тоже 
        самое(прокидывать store через сcntext) но скрытно  от нас(без нашего участия).


    Создадим новый файл - storeContext.js в папке src(все равно дальше мы его использовать не будем и в последующем удалим), а в 
        нем создаем переменную для хранения контекста, пока пустую и экспортируем ее:

        import React from 'react';

        const StoreContext = React.createContext(null);

        export default StoreContext;


    Теперь в index.js импортируем StoreContext и заключим компонент Апп в компонент StoreContext.Provider и передадим value={store},
        то есть все компоненты которые вложены в Апп(возможно и сам Апп) могут пользоваться теперь этим store.

        import StoreContext from './StoreContext';

        let rerenderEntireTree = (state) => {
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(
                <React.StrictMode>
                    <StoreContext.Provider value={store}>
                        <App />
                    </StoreContext.Provider>
                </React.StrictMode>
            );
        }

    
    Во всех последующих компонентах где раньше прокидывали store через  props удалим передачу через props. А получать store будет
        контейнерный компонент(что бы не загрязнять чистую ф-ю).  В Profile теперь место <MyPostsContainer store={props.store} />
        будем вытаскивать store из контекста. Оборачиваем компонет MyPosts в контейнерном компоненте в  <StoreContext.Consumer>
        в середине которого вызывается ф-я со значением store к которому может обращаться возвращаемая ф-ей разметка. Так как
        компонент у нас раньше брал значение из переменных которые лежат выше него и теперь эти переменные не имеют доступа к
        стору, теперь мы их переместим в саму ф-ю возвращающую разметку и будем брать стор напрямую.

        import StoreContext from '../../../StoreContext' 

        const MyPostsContainer = (props) => {
          return (
                <StoreContext.Consumer> {
                    (store) => {
                        let state = store.getState();
                        let addPost = () => { store.dispatch(addPostActionCreator()); };
                        let onPostChange = (text) => { store.dispatch(updateNewPostTextActionCreator(text)); };

                        return (<MyPosts updateNewPostText={onPostChange} 
                                addPost={addPost}
                                postsData={state.profilePage.postsData}
                                newPostText={state.profilePage.newPostText} />)
                    }
                }
                </StoreContext.Consumer>
            );
        }



    Делаем также для компонента DialogsContainer:

        import StoreContext from "../../StoreContext"

        const DialogsContainer = () => {
            return <StoreContext.Consumer>{
                        (store) => {
                            let state = store.getState().dialogsPage;
                            let onSendMsgClick = () => { store.dispatch(sendMsgCreator()); };
                            let onNewMsgChange = (msgBody) => { store.dispatch(updateNewMsgBodyCreator(msgBody)); };

                            return <Dialogs updateNewMsgBody={onNewMsgChange}
                                            sendMsg={onSendMsgClick}
                                            dialogsPage={state} />;
                        }
                    }
                    </StoreContext.Consumer>
        }

        export default DialogsContainer;


    Появилась ошибка у автора - render is not a function (update ContextConsumer). В результате поиска ошибки нашли сообщение 
        children of Consumer without new line gives "TypeError render is not a function". Окзалось что после 
        <StoreContext.Consumer> { - эта фигунрная скобка должна быть на новой строке.

        Изменил у себя, теперь всё должно работать.



        //*! можно инкапсулировать код например в СторКонтексте  создать переменную Provider и прописать в ней
        
                export const Provider = (props) => {
                    <StoreContext.Provider value={props.store}>
                        {props.children}
                    </StoreContext.Provider>
                }

            потом импортировать в скрипт.дс Provider и обернуть в него компонент Апп

                    <Provider store={store}>
                        <App />
                    </Provider>

            Таким образом меньше потом прописывать каждый раз, и также можно поступить с Consumerom. Но для всего этого есть 
            библиотека React-Redux которая скрывает от нас такие детали(context, dispatch, store, connect) и позволяет легче 
            обращать к Redux и оптимизирует рендер(перерисовку) так чтобы перерисовывался только тот компонент стейт которого
            изменился.

*/}


{/*    ====    45. Практика - connect, mapStateToProps, mapDispatchToProps     ====

    Мы уже подключили redux и создали с помощью него store и закомбайнили редюсеры. Редакс не обязательно использовать с реактом,
        его можно использовать с нативным JS, Angular, ... Проблема в том что достучаться к этому редаксовскому стору немного
        затруднительно, нужно создавать контекст провайдер, в компоненте которой нужен стор создавать контент консумер. Для более
        удобной работы с редаксом установим библиотеку react-redux  это такая прослойка между реактом(UI) и редаксом(BLL) для того
        чтобы эффективно и легче обращаться к редаксу. Мы по сути будем обращаться к реакт-редаксу, а она будет обращаться к редаксу
        сама.

        npm instal react-redux --save


    Проблемы которые будем решать:
        1) передача store через Context (мы создали свой Provider). Теперь можно пользоваться Provider из библиотеки, у него такой
            же синтаксис как у нас был(хоть и немного другая реализация в самой библиотеке), теперь можно удалить файл StoreContext
            где мы создавали свой Context. Теперь Provider в index где мы его используем будем импортировать из библиотеки 
            react-redux.

                import {Provider} from 'react-redux';

                <Provider store={store}>
                    <App />
                </Provider>


            //*! Мы создавали контейнерные компоненты для того чтобы получить данные из store и коллбеки(ф-и которые обращаются к
            стору и диспатчат action) которые потом используем в презентационном компоненте, по сути работа в таких контейнерных
            компонентах будет проделываться одна и таже. Библиотека реакт-редакс(рр) предоставляет нам способ создавать такие
            контейнерные компоненты красивым(легким?) путем. Сделаем создание нашего конт. компонента в DialogsContainer с помощью
            ф-и connect, назовем его DialogsContainer. Присваиваем переменной двойной вызов ф-и(если стоят два
            вызова ф-и ()() это значит что мы вызывыем эту ф-ю, она возвращает еще какую-то ф-ю и уже ее мы вызываем вторыми 
            скобками) и в возвращенную ф-ю передаем аргументом название того компонента вокруг которого нужно сделать контейнерный
            компонент.

                import connect from 'react-redux';

                const DialogsContainer = connect()(Dialogs);


            Таким образом мы присоединили Диалоги к стору. Сделали почти тоже что делали вручную, но какой стейт прийдет и какие 
            коллбеки - это мы определяем(настраиваем) в первой ф-ии. Для этого мы создадим две ф-ии которые возвращают объект и
            передадим их в первый вызов.

                let f1 = () => {
                    return { }
                }

                let f2 = () => {
                    return { }
                }

                const DialogsContainer = connect(f1, f2)(Dialogs);

            //*! Как это работает. Ф-я connect создает контейнерный компонент в нем она рендерит переданный презентационный 
            компонент и внутрь нее в качестве props передает те свойства которые сидят в объектах возарвщаемых ф-ми f1, f2.
            Заполним ф-ии нужными данными:

                

            Коннект позволяет нам забыть про store и предоставляет его составные части, state теперь можно брать без
            вызова ф-ии getState просто передав стейт в параметры ф-и 1, и тогда можно обращаться к стейту минуя стор, тоесть
            dialogsPage={store.getState().dialogsPage;}  -  dialogsPage: state.dialogsPage , в пропсы к презентационному компоненту
            попадет такая же конструкция dialogsPage = {state.dialogsPage} сформировавшаяся из пары ключ-значение объекта в ф-и.
            В первой ф-ии в качестве пар ключ-значение будем передавать все нужные пропсы которые зависят от state, во второй
            ф-ии все нужные колбеки которые зависят от dispatch. Также переименуем ф-ии под их назначение.

                let mapStateToProps = (state) => {
                    return {
                        dialogsPage: state.dialogsPage
                    }
                }

                let mapDispatchToProps = (dispatch) => {
                    return {
                        updateNewMsgBody: (msgBody) => { dispatch(updateNewMsgBodyCreator(msgBody)); },
                        sendMsg: () => { dispatch(sendMsgCreator()); }
                    }
                }

                const DialogsContainer = connect(mapStateToProps, mapDispatchToProps)(Dialogs);


                export default DialogsContainer;


            //*! Кроме ф-й которые делал наш контейнерный элемент, connect делает еще коекакую "магию" - это будет в следующем 
            уроке когда нам повылазят некоторые баги.


    По такому же принципу передалаем МайПостКонтейнер

        import connect from 'react-redux';

        let mapStateToProps = (state) => {
            return {
                postsData: state.profilePage.postsData,
                newPostText: state.profilePage.newPostText
            }
        }

        let mapDispatchToProps = (dispatch) => {
            return {
                updateNewPostText: (text) => { dispatch(updateNewPostTextActionCreator(text)) },
                addPost: () => { dispatch(addPostActionCreator()) }
            }
        }

        const MyPostsContainer = connect(mapStateToProps, mapDispatchToProps)(MyPosts);


        export default MyPostsContainer;



    На первый взгляд кода сильно меньше не стало, но коннект выполняет дополнительные ф-ии(оптимизации и перерисовки).


    //*! У автора приложение работает, но не впечатывается сообщение и не работают создания постов. Автор сказал подумать
    почему так, а на следующем уроке будем разбираться. Думаю потому что state теперь обновляется как-то по другому. У 
    меня дома все заработало без дополнительных ухищрений.

*/}


{/*    ====    46. Практика - копия глубокая vs поверхностная (deep copy vs shallow copy)     ====

    Прежде чем решить проблему из прошлого занятия(у автора не заработало изменение формы и добавление сообщения) когда state 
        меняется, но отображения не видим(в  комментариях подсказывали про правильное копирование объекта - иммутабельность).


    
    ПРИМЕР. Есть объект и в него вложены другие объекты и массив. 

            var a = {
                name: 'it',
                protocol: 'https',
                maxStudentCount: 10,
                isOnline: true,
                students: ['ivan', 'andrey', 'farid'],
                classroom: {
                    teacher:{
                        name: 'wew',
                        age: 18
                    }
                }
            }

            
        Если в переменную положить примитив let age = 18, то он там и будет находиться, и при let age2 = age, в переменную age2 
        скопируется не переменная age, а значение, и у age2 получиться свое скопированное значение, которое при изменении age2 
        не затронет age. 
 

        Так как в переменной "а" находится не объект, а ссылка на него, то если сделать такое присвоение  let b = a; - мы скопируем
        ссылку на объект и по сути будем обращаться к тому же объекту ссылка на который сидит в "а". 
            a === b  // true  - потому что сравниваются ссылки которые лежат в переменных


        //*! Два разных объекта не могут быть равны потому что они созданы в разных частях памяти и они разные, даже если пустые
            {} == {}  // false
        

        Если скопировать поверхностно, b = {...a} скопируются все свойства с примитивами, а свойства которые содержат ссылки на
        объекты(которые по сути созданы в памяти вне этого объекта, хоть нам и кажеться что они вложенные) скопируются как ссылки 
        на объекты, и при обращении и изменении их будут меняться оригиналы. Тоесть при таком копировании 
            a.students === b.students  // true  - потому что содержат ссылки на один и тот же объект.
            a.name === b.name  // true  -  сравниваются примитивы которые в них лежат  //!примитивы сравниваются по значению.

    
        Чтобы его скопировать правильно(глубоко - со всеми вложенными структурами) нужно создавать для каждого вложенного объекта
        новый объект и раскрывать спредом в него значения из старого:

            let b = {...a};
            b.students = [...a.students];
            b.classroom = {...a.classroom};
            b.classroom.teacher = {...a.classroom.teacher};
            
*/}


{/*    ====    47. Практика - делаем копию состояния в profileReducer     ====

    Для выявления ошибки(не обновляется информация на странице при нажатии кнопки поста или записи в текст эреа) посмотрим сначала
        отрабатывают ли ф-ии и приходит ли информация в store. Для этого в ReduxStore присвоим стор глобальному объекту window
        чтобы из браузера увидеть добавилась ли информация

        window.store = store;


        теперь после нажатия кнопки добавления поста  открываем инспектор и в консоле пишем store.getState(), нам вернулся объект
        стейта в котором видно что посты добавились в объект, но мы не видим их на странице.


    Так происходит потому что реакт и редакс  ожидают что мы будем использовать чистые ф-и, которые вернут результат. 

            propst --> Functional Component --> JSX

            state, action --> Reducer --> state

        
        При одних и тех же переданных данных результат должен быть одинаков, если данные передадуться другие то и результат будет 
        другой, это называется детерминирование(предсказуемость). Такие ф-ии легче оптимизировать и тестировать.

            data --> Deterministic Function --> Result
            data --> Deterministic Function --> Result

            data2 --> Deterministic Function --> Result2
            data2 --> Deterministic Function --> Result2


        Еще одной важной характеристикой чистой ф-ии является иммутабельность(неизменяемость - ф-я не имеет права изменить данные 
        которые к ней пришли), но как же не менять если Reducer меняет state от action. Важен метод изменения, тоесть мы должны 
        сделать копию state и провести изменения в копии и вернуть ее из редюсера.


    Раньше в index.js мы подписывались на изменение state и перерисовывали всё дерево от любого изменения state. Не происходит 
        сейчас эта перерисовка потому что connect делае свой внутренний subscribe(подписку), поэтому происходит глобальная 
        блокировка перерисовки. Сейчас компонент сам смотрит нужно ему перерисоваться или нет, происходит локальная перерисовка
        вместо обновления всего дерева, это еще более оптимизирует работу приложения.
            
        Теперь нам не нужен наш subscribe для обновления, убираем его. Просто отрисовываем дерево единожды при загрузке приложения
        поэтому убираем всё лишнее. Теперь за перерисовку отвечает локальный сабскрайб который создался при подключении компонента
        с помощью ф-и connect. 
        
        Он работает так - каждый раз когда в state происходит изменение запускается ф-я mapStateToProps и формируется новый объект
        внутренности которого сравниваются с внутренностями(значениями свойств) старого объекта, и если в state не изменились
        посты postsData и newPostText - тогда компонент не перерисовывается.

            let mapStateToProps = (state) => {
                return {
                    postsData: state.profilePage.postsData,
                    newPostText: state.profilePage.newPostText
                }
            }


        Но у нас же state изменяется, почему же не происходит ререндер. Потому что реакт и редакс( может реакт-редакс?) из-за 
        правила иммутабельности считает что объект не изменен, потому что по сути объект остался тот же(сравнивает по ссылке? не
        лезет внутрь) но мы внесли в него изменения,а так делать нельзя , нужно скопировать объект и в него внести правки и тогда
        при сравнении этих двух объектов  они будут не равны потому что это уже два разны объекта. 


        То есть нам нужно изменить принцип занесения информации в state в profile-reducer и dialog-reducer. Сначала делаем покпию
        state, пока что для каждого case и поэтому берем в фигурные скобки код в кейсе чтобы не было конфликта двух одинаковых
        переменных(позже отрефакторим). Делаем изменения в копии и возвращаем копию, для массива postsData делаем глубокую копию.

            const profileReducer = (state = InitialState, action) => {
                switch(action.type) {
                    case ADD_POST: {
                        let newPost = {
                            id: 5,
                            post: state.newPostText,
                            likesCount: 0
                        };

                        let stateCopy = {...state};
                        stateCopy.postsData =  [...state.postsData];
                        stateCopy.postsData.push(newPost);
                        stateCopy.newPostText = '';
                        return stateCopy;
                    }
                    case UPDATE_NEW_POST_TEXT: {
                        let stateCopy = {...state};
                        stateCopy.newPostText = action.newText;
                        return stateCopy;
                    }
                    default:
                        return state;
                }
            }

        Теперь connect видит что state изменился - другой объект и соответственно перерисует данный компонент.

        Копию делаем только того участка state который будем менять, тоесть если это свойство newPostText - в нем сидит примитив,
        достаточно сделать поверхностную копию, чтобы не затрагивать postsData и не заставлять компонент от него зависящий его 
        перерисовывать(так как будет создан новый объект но по факту внутренние свойства и значения теже). А если нужно
        поменять postsData тогда уже делаем для него глубокое копирование.

*/}


{/*    ====    48. Практика - делаем копию состояния в dialogsReducer     ====

    В dialogsReducer сделаем переменную с копией state перед конструкцией switch, чтобы она была доступна в любом кейсе свича.
        Запишем в одну строку, //!сначала всегда делаем спред state, а потом перезаписываем свойство, иначе свойство 
        изменится у оригинала, а потом создастся поверхностная копия.

                let stateCopy = {
                    ...state,
                    messagesData: [...state.messagesData]
                };

                switch(action.type) {
                    case UPDATE_NEW_MSG_BODY:
                        stateCopy.newMsgBody = action.newMsgBody;
                        return stateCopy;

                    case SEND_MSG:
                        let msg =  state.newMsgBody; //! тут автор оставил state потому что из текущего state достаем то что будем
                                                                                                        добавлять в новый state
                        stateCopy.messagesData.push({ id: 6, msg});
                        stateCopy.newMsgBody = '';
                        return stateCopy;

                    default:
                        return state;
                }
            }

        //! и не заработало полез дебажить и чтобы устранить ошибку везде где map добавил key который = id элемента из которого
        получаем JSX элемент. Потом вылезла ошибка что два чилдрена с одним и тем же key, потому что он у нас захардкоджен при 
        впечатывании сообщения, так получилось потому что в предыдущих уроках он в диспатчере перепутал местами акшены, после 
        замены работает, хотя он //! оставил в этом случае ТОЛЬКО поверхностную копию let stateCopy = {...state,}; потому что
        в DialogsContainer мы передаем сразу весь объект -  dialogsPage: state.dialogsPage, а не дробим его как в MyPostsContainer
        postsData: state.profilePage.postsData, newPostText: state.profilePage.newPostText. Поэтому будет перерисовываться
        компонент даже при поверхностном копировании //! но получается сообщения будут пушиться в оригинальный объект - да
        автор говорит что нарушен принцип иммутабельности. Но если мы сделаем копию messagesData, то так как эта копия делается
        до switch то даже при впечатывании текста будет создаваться новый массив с постами, а так тоже делать не нужно(надо 
        копировать только то что изменяем) потому что засоряется память 
        
        //! значит будем делать нужную копию в зависимости от экшена, перенесем  в сами кейсы, но так как в прошлом примере со 
        скобками выглядит не красиво, а без скобок нельзя объявить две одинаковые переменные, сделаем объявление до switch, а 
        присваивание уже в самом кейсе.

            const dialogsReducer = (state = InitialState, action) => {

                let stateCopy;
                
                switch(action.type) {
                    case UPDATE_NEW_MSG_BODY:
                        stateCopy = {...state};
                        stateCopy.newMsgBody = action.newMsgBody;
                        return stateCopy;

                    case SEND_MSG:
                        stateCopy = {...state, messagesData: [...state.messagesData] };

                        let msg =  stateCopy.newMsgBody;

                        stateCopy.messagesData.push({ id: 6, msg});
                        stateCopy.newMsgBody = '';
                        return stateCopy;

                    default:
                        return state;
                }
            }



        Теперь отрефакторим чтобы выполнять изменения при создании объекта. Так как при копировании messagesData мы уже раскрываем
        массив [...state.messagesData], то теперь можно вместо push в копированный массив, добавить новый объект после запятой: 
        messagesData:  [...state.messagesData, { id: 6, msg} ]  - так мы добави эл. в конец массива, если нужно в начало, тогда
        сразу пишем добавляемый аргумент, а через запятую спред стейта.

            const dialogsReducer = (state = InitialState, action) => {

                let stateCopy;

                switch(action.type) {
                    case UPDATE_NEW_MSG_BODY:
                        stateCopy = {
                            ...state,
                            newMsgBody: action.newMsgBody
                        };
                        return stateCopy;

                    case SEND_MSG:
                        let msg =  state.newMsgBody;
                        stateCopy = {
                            ...state,
                            newMsgBody: '',
                            messagesData:  [...state.messagesData, { id: 6, msg} ] 
                        };
                        return stateCopy;

                    default:
                        return state;
                }
            }


        Можно даже избавиться от переменной и сразу возвращать скопированный объект:

            const dialogsReducer = (state = InitialState, action) => {

                switch(action.type) {
                    case UPDATE_NEW_MSG_BODY:
                        return {
                            ...state,
                            newMsgBody: action.newMsgBody
                        };

                    case SEND_MSG:
                        let msg =  state.newMsgBody;
                        return {
                            ...state,
                            newMsgBody: '',
                            messagesData:  [...state.messagesData, { id: 6, msg} ] 
                        };

                    default:
                        return state;
                }
            }



    Зарефакторим profileReducer и пофиксим ошибку(не обнуляется поле после отправки поста):

       const profileReducer = (state = InitialState, action) => {
    
            switch(action.type) {
                case ADD_POST: 
                    let newPost = {
                        id: 5,
                        post: state.newPostText,
                        likesCount: 0
                    };

                    return {
                        ...state,
                        postsData: [...state.postsData, newPost],
                        newPostText: ''
                    };
                    // stateCopy.postsData =  [...state.postsData];
                    // stateCopy.postsData.push(newPost);
                    // stateCopy.newPostText = '';
                    // return stateCopy;
                
                case UPDATE_NEW_POST_TEXT: 
                    return {...state, newPostText: action.newText};
                
                default:
                    return state;
            }
        }     

        //! у автора все равно не происходит зануление текст ареа, у меня работает. Автор забыл раскоментировать в MyPostsContainer
        строчку newPostText: state.profilePage.newPostText - поэтому обновленное поле не передавалось из стейта в компонент.

*/}


{/*    ====    49. Практика - Страница пользователей     ====

    Рассмотрим взаимодействие с сервером AJAX запросы, rest API, для этого сделаем отдельную страницу(find users).


    В App у нас происходит рендер компонента в зависимости от адрессной строки, добавим туда наш будущий компонент Users, и
        после создания его испортируем в Апп.
        <Route path="/users" element={<Users />} />


    Создадим в Components папку Users и в ней Users.jsx компонент. //! jsx используем только для файлов компонент, для редюсеров
        и остального расширение js(иначе могут вылезать разные баги).


    В Users  импортируем React(чтобы работал Babel для преобразования JSX разметки в JS код), создаем компонент Users, и 
        экспортируем его.

            import React from 'react';

            let Users = (props) => {
                return(
                    <div>Users will be here</div>
                )
            }

            export default Users;




    Теперь вопрос - с чего начинать разработку с UI или с BLL ? Так как БЛЛ важнее начнем разработку с него(при этом нам нужно
        видеть макет - какие элементы должны быть на странице).

    
    Создадим для Users reducer(ф-я которая принимает старый state + action и выдает новый state(измененную опию) если он 
        изменился в зависимости от экшена, если не изменился возвращает старый state). Скопируем редюсер профиля, из switch
        пока удалим вс кроме default, и подумаем как должен выглядеть наш инициализируемый state. На макете у нас показано
        4 пользователя (аватарка, личные данные: имя, страна/город, статус, кнопка - follow), внизу кнопка Show More по нажатию
        на которую будут к этим 4м еще на страницу добавляться еще 4 пользователя и т.д. - это всё мы можем узнать у заказчика
        (почему эта строчка - статус. а не дескрипшн) что бы не додумывать. 

        //todo почитать книгу Domen Driven Design - Эрик Дж. Эванс - по этой теме.

        Заполняем InitialState. Переименуем его в usersData. id оставляем (особенно если это массив объектов, она будет браться
        с сервера, там будут создаваться сущности и на сервере есть идентификатор), добавляем fullname и location - место
        проживания как объект в котором есть city и country. Также сделаем флаг followed чтобы видеть пользователь у нас в 
        друзьях или нет.

            let InitialState = {
                usersData: [
                    { id: 1, followed: false, fullName: "Dmitry", status: 'I am a boss', location: {city: 'Minsk' , country:'Belarus' } },
                    { id: 2, followed: true, fullName: "Sasha", status:'I am a boss too', location: {city: 'Moskov', country:'Russia'  } },
                    { id: 3, followed: false, fullName: "Vitya", status: 'I am a super boss',location: {city: 'Kyiv', country:'Ukraine' }  }
                ]
            }


        Кнопку show more будем добавлять уже после того как сделаем вывод пользоватьелей на страницу. Для реализации кнопки - follow и unfollow
        нам нужно два action их и реализуем в диспатче. Поменяем ф-и которые отдаем и константы, в ф-ии которые отдаем нам нужно принять 
        параметром userId - айди того юзера которого нужно поменять.
        
            const FOLLOW = 'FOLLOW';
            const UNFOLLOW = 'UNFOLLOW';

            export const followAC = (userId) => ({ type: FOLLOW, userId })
            export const unfollowAC = (userId) => ({ type: UNFOLLOW, userId })


        Далее для того чтобы применить экшены в редюсере нужно скопировать state и сделать копию массива users который будем изменять.

            let stateCopy = { ...state, users:[...state.usersData] } - так мы делали если нужно было добавить что то в массив


        Когда нужно перебрать массив и изменить один из его текущих элементов используем - map - возвращает новый массив на основе
        старого(копирует). Но копирует только того пользователя которого изменяем, если изменения не требуются то возвращает старый
        массив.

            const usersReducer = (state = InitialState, action) => {
    
                switch(action.type) {
                    case FOLLOW:
                        return { 
                            ...state, 
                            users: state.usersData.map( u => {
                                if(u.id === action.userId) {
                                    return {...u, followed: true}
                                }
                                return u;
                            })
                        }

                    case UNFOLLOW:
                        return { 
                            ...state, 
                            users: state.usersData.map( u => {
                                if(u.id === action.userId) {
                                    return {...u, followed: false}
                                }
                                return u;
                            })
                        }

                    default:
                        return state;
                }
            }

        
        Пока мы захардкодили юзеров, но на самом деле массив будет пустой изначально, а потом мы получим данные пользователей
        с сервера и нам их нужно будет добавить в массив для этого нужно создать еше один action назовем его setUsers. В
        switch case SET_USERS: копируем state, копируем юзеров ...state.usersData и также раскрывая через спред оператор
        вставляем юзеров из action - ...action.users (склеиваем два массива).

            const SET_USERS = 'SET_USERS';

                    case SET_USERS:
            return {
                ...state,
                users: [ ...state.usersData, ...action.users ]
            }

            export const setUsersAC = (users) => ({ type: SET_USERS, users })

        
        Bll для юзеров готов теперь сделаем UI.



    Создадим UsersContainer для снабжения компонента Users данными из store(state),  изменим в Апп просто компонент Users на 
        UsersContainer. Диспатчим не action creator a результат его работы(он возвращает нам action ) и мы диспатчим action который
        вернул action creator - простой объект который как минимум должен содержать тип(type). setUsers тоже добавляем ( как будто
        это намерение пользователя засетать юзеров) - да пользователь не нажимает никакую кнопку для отображения пользователей, они
        отображаются на странице автоматически, но ведь он зашел на эту страницу, поэтому это можно считать за его действие, при
        котором презентационный компонент  диспатчит action в state и отрисовываются пользователи которые приходят уже из state.
        
            import React from 'react';
            import Users from './Users';
            import {connect} from 'react-redux';
            import {followAC, unfollowAC, setUsersAC} from '../redux/users-reducer'


            let mapDispatchToProps = (state) => {
                return {
                    users: state.usersPage.usersData
                }
            };

            let mapDispatchToProps = (dispatch) => {
                return {
                    follow: (userId) => { dispatch(followAC(userId)); },
                    unfollow: (userId) => { dispatch(unfollowAC(userId)); },
                    setUsers: (users) => { dispatch(setUsersAC(users)); }
                }
            };


            export default connect (mapStateToProps, mapDispatchToProps)(Users);
          
        
    Добавим в Redux-store в reducers users:

            import usersReducer from './users-reducer';

            let reducers = combineReducers({
                profilePage: profileReducer,
                dialogsPage: dialogsReducer,
                usersPage: usersReducer
            })


    Теперь компонент Users получает необходимые данные(колбеки и state) и можно приступить к их обработке. Берем массив юзеров и
        маппим их чтобы для каждого возвращалась разметка с нужными значениями(пока что закидывем всё в span чтобы не париться с 
        версткой, в одном span отрисуем картинку аватарки(добавим в reduser для каждого пользователя photoUrl) и кнопку, во втором
        две колонки 1(имя и статус) 2(страна+ город)). Добавим импорт styles и создадим Users.module.css чтобы уменьшить размер
        аватарок:

            import React from 'react';
            import styles from './Users.module.css';

            let Users = (props) => {
                return(
                    <div>
                        {
                            props.users.map(user => <div key = {user.id}>
                                <span>
                                    <div><img src={user.photoUrl} className={styles.userPhoto} /></div>
                                    <div>
                                        {user.followed 
                                            ? <button onClick = { ()=> {props.unfollow(user.id)} }>Unfollow</button> 
                                            : <button onClick = { ()=> {props.follow(user.id)} }>Follow</button>}
                                    </div>
                                </span>
                                <span>
                                    <span>
                                        <div>{user.fullName}</div>
                                        <div>{user.status}</div>
                                    </span>
                                    <span>
                                        <div>{user.location.country}</div>
                                        <div>{user.location.city}</div>
                                    </span>
                                </span>
                            </div>)
                        }
                    </div>
                )
            }

            export default Users;    

        Такой вид с захаркоджеными юзерами. Сетюзерс еще не применяли.



    //! Для эмуляции получения данных о пользователях с сервера( поместим их пока в презентационный компонет Users ) в котором перед 
        отрисовкой вызовем setUsers и передадим туда данные пользователей:

            let Users = (props) => {

            props.setUsers([
                { id: 1, photoUrl: 'https://images.archive-digger.com/taboola/image/fetch/f_jpg%2Cq_auto%2Ch_225%2Cw_300%2Cc_fill%2Cg_faces:auto%2Ce_sharpen/https%3A%2F%2Fi.imgur.com%2FhDNiJvY.png', 
                    followed: false, fullName: "Dmitry", status: 'I am a boss', location: {city: 'Minsk' , country:'Belarus' } },
                { id: 2, photoUrl: 'https://images.archive-digger.com/taboola/image/fetch/f_jpg%2Cq_auto%2Ch_225%2Cw_300%2Cc_fill%2Cg_faces:auto%2Ce_sharpen/https%3A%2F%2Fi.imgur.com%2FhDNiJvY.png', 
                    followed: true, fullName: "Sasha", status:'I am a boss too', location: {city: 'Moskov', country:'Russia'  } },
                { id: 3, photoUrl: 'https://images.archive-digger.com/taboola/image/fetch/f_jpg%2Cq_auto%2Ch_225%2Cw_300%2Cc_fill%2Cg_faces:auto%2Ce_sharpen/https%3A%2F%2Fi.imgur.com%2FhDNiJvY.png', 
                    followed: false, fullName: "Vitya", status: 'I am a super boss',location: {city: 'Kyiv', country:'Ukraine' }  }
            ]);

        //! появилась ошибка - maximum update depth exceeded(достигнуто максимальное количество глубины по апдейту) - так получилось
        потому что: ф-й компонент Users вызывается когда где-то отрисовывается ее тег( у нас это UsersContainer который потом
        отрисовывается в App). Тоесть он вызывается и должен вернуть JSX разметку, но перед возвратом компонент отправляет список
        пользователей в state, он меняется - поступает сигнал перерисовать компонент Users но в нем перед перерисовкой снова идет 
        отправка пользователей и снова изменяется state, возврат JSX разметки происходит постоянно, мы сделали бесконечный цикл. 
        
        Для избежания такой ситуации будем setUsers если их у нас еще нету.

            if (props.setUsers.length === 0 ) ([
                { id: 1, photoUrl:


        Теперь все работает но в ф-м компоненте появляется побочный эффект(изменение данных state) и компонент уже не чистая ф-я.
        Если бы этот диспатч работал по нажатию кнопки это одно дело, но тут он работает во время вызова ф-и Users. Пока не знаем
        как взять эти данные с сервера нас такой порядок дел устраивает.

*/}


{/*    ====    50. Практика - Rest API (краткая теория)     ====

    Interface - то как мы работаем с объектом(дверь - ручка, замок; гитара - струны).

    API (Application Programm[-ing] interface) - интерфейс взаимодействия с приложением(программой). Программа - сервер написанная
        на Node (js) или (Apache(php), Django(pyton), ...) тут нас интересует только интерфейс взаимодействия с сервером API. У 
        каждой программы сервера есть программные endpoint (конечные точки) - каждый endpoint(ресурс) имеет характеристики: 
        
        1) url адрес на который мы можем делать запросы (URL: "https://samuraiJS.com/api/users" ) - тут ресурс users
        2) тип запроса  (http-request type: get / post)
        3) request payload   (данные которые должны послать на сервер) - правильно заполнить запрос(аналогия заполнения action )
        4) response data     (данные которые должны получить с сервера) - нужно знать какой ответ к нам прийдет чтобы правильно его
                        обработать.
        5) http codes: 404 not found, 5xx -server errors, 3xx -redirect, 2xx - ok (в зависимости от возвращенного кода ответа в нашем
                        кода будут производиться различные действия)



    Server REST API - правила запросов для типизации запросов (типичность запросов от проекта к проекту).
        Раньше были такие запросы

            https://samuraiJS.com/api/users/get     - get
            https://samuraiJS.com/api/users/create  - post
            https://samuraiJS.com/api/users/update  - post
            https://samuraiJS.com/api/users/delete  - post

        Потом подумали что нужно использовать все запросы для этих целей, а не только get и post, и теперь шлем запрос на один
        breakpoint но запросы разные. На сервер приходит запрос на один endpoint и в зависимости от типа запроса сервер сам 
        определяет что нужно сделать. На самом деле REST API немного про другое, про разделение API на определенные сущности и
        взаимодействия между ними.

            https://samuraiJS.com/api/users     GET - POST - PUT - DELETE (CRUD - create - read- update - delete)   



    Запросы отличаются размером payload - допустимого размера отправляемых на сервер данных, для get и delete он будет 
        небольшим потому что мы ничего по сути не отправляем, только хотим получить или удалить, для put и post он будет больше
        ведь нам нужно или создать нового пользователя или обновить картинку аватарки.


    //! Использовать будем библиотеку Axios для нативных способов использования AJAX запросов. XML HTTP request - самая 
        олдскульная технология(но уж не используемая). Раньше использовали JQuery библиотеку, но она слишком громоздкая. 
        Fetch - делает нативные AJAX запросы, возвращает промисы - но для таких низкоуровневых библиотек нужно писать свою
        обертку, чтобы было удобно делать запросы, реализовать объекты отправляемые на сервак, устанавливать параметры ...
        То есть по сути мы создадим свой axios вокруг fetcha или другой библиотеки, это затратно и нужно поддерживать его 
        актуальность, поэтому можно использовать готовые решения.

        При работе с axios мы выполняем асинхронные запрос, во время ожидания которого остальное приложение работает. Пишем:
            axios потом через точку get происходит запрос и ожидание, дальше выполняется  console.log("after request"); а когда
            прийдет ответ с сервера выполниться код в then. То есть axios возвращает промис на который мы подписываемя при помощи
            then и когда будет получен ответ выполниться колбек ф-я в then. Пока в промисы не вникаем.


            axios 
                .get('https://blabla.com/users')
                .then( data => console.log(data) );

            console.log("after request");


    //todo Можно посмотреть на канале it kamasutra playlist - AJAX в деталях, там очень много всего, что понадобится потом.

*/}


{/*    ====    51. Практика - Users API     ====

    Будем выполнять get запрос на сервер и братю пользователей оттуда. В компоненте Users мы сейчас сетаем захардкодженных 
        пользователей, и вместо них нам нужно сделать запрос на сервер и получить данные оттуда. Для выполнения запросов установим
        библиотеку Axios (другие даже не рассматриваем) и импортируем ее в Users(там где используем)

        npm install axios --save


        import * as axios from 'axios'; - эта запись означает импортируй всё * как axios из библиотеки "axios", тоесть мы
                                            упаковываем всё что экспортируется из axios в один объект и будем обращаться к
                                            тому что нужно прописывая сначала слово - axios а потом то что нам из него нужно


    Теперь можно писать запрос - axios.get - адрес(endpoint, APIшка ) мы смотрим на сайте social-network.samuraijs.com/docs#
        //! На момент записи видео имелся такой базовый URL  https://social-network.samuraijs.com/api/1.0 - проверить какой сейчас
        Далее на тот момент была только 1 приписка /users с параметром запроса get, тоесть URL для обращения за пользователями
        будет https://social-network.samuraijs.com/api/1.0/users. Для get запроса мы можем на сервер отправить только адрес
        поэтому его и вбиваем для получения пользователей. 
        
        get запрос можно отправить просто вбив в браузере url адрес - и нам вернутся JSON данные - глобальный объект в котором 
        есть объекты и массивы как в JS но свойства тоже в кавычках, в данном случае глобальный объект со свойством items - массив
        в котором сидят элементы(объекты), дальше свойство total count со значением 44 и свойство error со значение null. Для 
        более удобного вида можно вбить этот ответ в любой онлайн JSON viwer, также в документации на этот url с которого приходит
        ответ может быть пример ответа(response).

        Поставив debugger после запроса видим что вернулось в запросе много всего и среди прочего data - это те данные которые
        нам нужны, в них сидит items в котором объекты с пользователями.

            if (props.setUsers.length === 0 ) {

                axios.get('https://social-network.samuraijs.com/api/1.0/users')
                    .then( response => { props.setUsers(response.data.items); } );

            };

        //! вылезла ошибка, потому что название свойств в объектах пользователей не совпадают с теми которые мы вытаскиваем для
        передачи в компонент. Тоесть свойства location нету, но он нам нужен.



        //! Сейчас импорт из axios  - import axios from 'axios';
        //! Доступа к серверу автора нету без VPN (Hide VPN), можно использовать пока 'https://jsonplaceholder.typicode.com/users'
        //! При заполнении массива userData - происходит заполнение 2 раза, итого пользователей вместо 10ти - 20ть и они повторяются. 
            //! Не понятно почему так(может нужно подрубить асинхронность для заполнения). follow/unfollow работают с данными с 
            //! другого сервера, непонятно как ведь соответвующих свойств у объектов нету.
            


    В реальной жизни если у нас нету нужного свойтсва( в данном случае lication) то нужно стучаться к бэкендщику или разработтчику 
        который создает API и просить добавить это свойство. Таже у нас есть свойтсво fullName, а сервер возврящает только name и
        что нам снова стучать к бэкендщикам? В идеале мы должны проектируемые в системе сущноти(объекты) в них делать свойства 
        такие же как на сервере, тогда будет меньше конфликтов, то есть нужно подстраивать свой код под API. Теперь нам нужно
        отрефакторить код.

        Если мы не знаем какие есть свойства у объектов на сервере - добавляем прослойку (data access layer - уровень доступа к 
        данным) который на себя возьмет маппинг данных которые приходят с сервера, то есть он будет мапить(превращать) эти данные
        в те ктороые нам нужны, но это дополнительная работа. Но лучше так не делать и сразу писать так чтобы работало с данными
        которые есть на сервере.


        Делаем рефакторинг свойств в users и закоментим location потому что этих свойств вообще нету и они мешают работе SPA 

            <span>
                <div>{user.name}</div>
                <div>{user.status}</div>
            </span>
            <span>
                <div>{'user.location.country'}</div>
                <div>{'user.location.city'}</div>
            </span>


        Теперь показались юзеры но они без аватарок потому что свойства также не совпадают, меняем название свойства, но в самих
        объектах нету ссылок, там везде null поэтому для такого случая сделаем показ стандартной аватарки. Скажем что если 
        свойство user.photos.small не равно null !==null тогда показываем его ? user.photos.small, а если равно тогда показываем
        то что в переменной userPhoto.  Так как картинка у нас будет одна и таже для всех теперь можно не ссылаться на url а 
        положить картинку в наш проект, создадим папку assets в ней images и уже в эту папку положим картинку user.jpg. Теперь 
        испортируем ее в users:

            import userPhoto from '../../assets/images/user.jpg'
            
            <div><img src={user.photos.small !==null ? user.photos.small : userPhoto }


        Теперь работает и отображается. //! follow / unfollow у автора работает - говорит это фейковое поведение не связанное с 
        сервером.

        
        
    В следующих уроках мы будем убирать из ф-го компонента users побочную ф-ю которая сетает юзеров потому что компонент должнен
        оставаться чистым компонентом. Для этого можно использовать классовый компонент или хуки. Но так как хуки тогда только
        появились и все еще год или полтора их не использовали бы часто то автор решает что мы будем использовать классовые 
        компоненты. Хотя реакт и уйдет от классовых компонентов но концепции которые в них используются будут перенесены на 
        ф-ные (как раз посредством хуков), поэтому понимание классовых компонентов будет важно.

*/}


{/*    ====    52. Практика - Side effect     ====

    Когда из ф-го компонента сделали запрос на сервер(side effect), он перестал быть чистым(чистой ф-й). 
    
    Side effect: 
        api calls (запросы на сервер), 
        modification parametrs (модификация входящих параметров), 
        change DOM directly,
        change outer scope variables,
        ...


    Ф-я Users вызывается реактом и в этот момент нужно получить юзеров  с сервера, тоесть в UsersContainer нам их получить не 
        получиться. Сделаем внутри ф-и users которая должна только возвращать JSX другую ф-ю getUsers которая будет получать юзеров
        с сервера(коллбек ф-ю) и возвращать их. Для вывода пользователей создадим кнопку Get Users.

            let getUsers = () => {
                if (props.users.length === 0 ) {
                    axios.get(srcApiSamurai)
                        .then( response => { 
                            props.setUsers(response.data.items); 
                        });
                }
            };


            return(
                <div>
                    <button onClick = {getUsers} >Get Users</button>


        Теперь при вызове ф-ии Users она будет только возвращать JSX то есть вести себя как чистая ф-я, а получать пользователей
        будет уже другая ф-я по нажатию на кнопку. Но мы же хотим сразу получить пользователей на странице, в обычных ф-х 
        компонентах без нарушения правил так сделать не получиться(до хуков), так что будем использовать классовый компонент.

        //! Теперь при обновлении страници или нажатии кнопки get users пользователи добавляются только 1 раз, не происходит
        нагромождения данных в массиве. 

*/}


{/*    ====    53. Практика - Классовый компонент (extends React.Component)     ====

    Классы нужны чтобы создавать однотипные объекты на базе этих классов и в дальнейшем реализовывать концепцию ООП - инкапсуляция,
        полиморфизм, наследование.


    Ф-й компонент - ф-я принимающая props возвращающая JSX. Так как это ф-я ее нужно вызывать, мы пишем тег а реакт понимает что
        это компонент и вызывает эту ф-ю и прокидывает пустые(в данном случае) props. Хоть мы и используем connect и кажеться что
        props в компоненте беруться из ниоткуда, но connect внутри так устроен что props прокидываются все равно через эти 
        аттрибуты <Header state={state} />

        const Header = (props) => {             <Header />
            return ( <div>                          |
                        <a>Home</a>                 |
                        <a>Messages</a>             |
                    </div>);                    Header({});
        }



    Класс это некое описание объекта который будет создаваться на его основе, в данном случае каждый объект будет содержать 
        свойства name и age.

            class Man {                                 __________{ }  let m1 = new Man('Dima', 31)
                constructor(name, age) {               /
                    this.name = name;       __________/___________{ }  let m2 = new Man('Viktor', 25)
                    this.age = age;                   \
                }                                      \__________{ }  let m3 = new Man('Valera', 50)
            }


        Можно было бы создать объект и таким образом let m_1 = {name:'Dima', age: 31}, но если объект сложный, с многими
        свойствами и методами тогда эти методы при таком создании объекта new Man будут автоматически доступны объекту, а если
        с помощью фигурных скобок то нет(прийдется каждому дописывать этот метод вручную).

            class Man {                                       
                constructor(name, age) {                     __________{ }  let m1 = new Man('Dima', 31)
                    this.name = name;                       /               let jsx = m1.render();
                    this.age = age;                        /
                }                               __________/___________{ }  let m2 = new Man('Viktor', 25)      
                render() {                                \
                    return (                               \
                        <div>                               \__________{ }  let m3 = new Man('Valera', 50)
                            {this.name} {this.age}
                        </div>
                    )
                }
            }


        Классовый компонент в реакте практически такой же, только вместо разных параметров принимаем объект props, а передаем уже 
        те параметры которые нам нужны упаковывая в объект. //!В этих примерах мы сами создаем объекты(сущности) класса Man 
            
            class Man {                                       
                constructor(props) {                         __________{ }  let m1 = new Man( {name:'Dima', age: 31} );
                    this.props = props;                     /               let jsx = m1.render();
                                                           /
                }                               __________/___________{ }  let m2 = new Man('Viktor', 25)      
                render() {                                \
                    return (                               \
                        <div>                               \__________{ }  let m3 = new Man('Valera', 50)
                            {this.props.name} 
                            {this.props.age}
                        </div>
                    )
                }
            }



    Также как ф-е компоненты вызывает сам реакт и классовые экземпляры он сделает за нас когда увидит что тег Мат это классовый
        компонент. Этот объект создается в памяти (нам он нужен для того чтобы повесить на него респонсибилити - ответственность
        какие то ф-и) и в данном случае выполняет рендер JSX в зависимости от props, когда реакту нужно он обращается к этому
        объекту давая новык props и получая новую JSX разметку.

            class Man { ... }           < Man name='samurai' age = {31} >
                                                        |
                                        let m1 = new Man( {name:'Dima', age: 31} );
                                        let jsx = m1.render();



    Запись классового компонента в реакт - мы создаем класс Man которыйнаследуется из стандартного реактовского классового
        компонента React.Component и мы его расширяем(extends) добавляя свои свойства и методы. Когда создается экземпляр
        m1 класса Man - для его создания срабатывает constructor, а так как сам класс Man создается из реактовского класса
        то и для его создания нужно запустить конструктор - super(props). При этом объект m1 будет иметь свойства и методы
        прописанные не только в Mam a и те которые прописаны в React.Component. 

            class Man extends React.Component {                let m1 = new Man( {name:'Dima', age: 31} );                       
                constructor(props) {                           let jsx = m1.render();
                    super(props);                     
                                                           
                }                                    
                render() {                                
                    return (                               
                        <div>                               
                            {this.props.name} 
                            {this.props.age}
                        </div>
                    )
                }
            }

        //! если constructor ничего своего(отличного от стандартного React.Component) не конструирует для Man, а только передает
        //! управление родительскому компоненту тогда можно constructor не прописывать.



    Будем заменять наш ф-й компонент на классовый. При этом у нас в ф-ии Users ежала ф-я setUsers для показа юзеров по клику, в
        классовом компоненте все внутренние ф-и становяться методами. Причем в классовом компоненте в отличие от литерала объекта
        (когда мы просто объект создаем через const Man = {} ) можно создавать методы и через стрелочную ф-ю onClick = () => ,
        потому что если мы создадим так onClick2() { ... } - начинаются проблемы с контекстом вызова this и нам нужно этот метод
        bind (байндить) или в rendere или в constructor. А при стрелочном создании метода такого не происходит, и теперь(2019 год)
        такие методы можно нормально дебажить поэтому будем использовать такую запись.

            const Header = (props) => {    
                let onClick = () => { ... }
                
                return ( <div>                          
                            <a>Home</a>                 
                            <a>Messages</a>             
                        </div>);                   
            }


            class Header extends React.Component {                                     
                constructor(props) { super(props); }    
                
                onClick = () => { ... }

                onClick2() { ... }
                
                render() {                                
                    return (                               
                        {this.props.name} 
                    )
                }
            }



    Теперь перепишем наш ф-й компонент Users в классовый. Создаем классовый компонент из стандартного реактовского без конструктора
        потому что ничего своего не добавляем. render должен быть обязательно потому что он должен возвращать JSX это то что ожидает
        реакт от компонента:

            class User extends React.Component {
                render() {
                    
                }
            }


        Для того чтобы рендер возвращал разметку вставим return из ф-го компонента и пофиксим обращение к props. Так как в render 
        props не приходят, но в самом объекте классовом они есть даже если мы не прописали конструктор(реакт их сам прокидывает)
        то для этого объекта обращаться к ним теперь нужно this.props. Для переноса ф-и getUsers просто уберем let и получиться
        метод и для передачи его в render используем this.getUsers.

            class Users extends React.Component {

                getUsers = () => {
                    if (this.props.users.length === 0 ) {
                        axios.get(srcApiSamurai)
                            .then( response => { 
                                this.props.setUsers(response.data.items); 
                            });
                    }
                }

                render() {
                    return(
                        <div>
                            <button onClick = {this.getUsers} >Get Users</button>
                            {
                                this.props.users.map(user => <div key = {user.id}>
                                    <span>
                                        <div><img src={user.photos.small !==null ? user.photos.small : userPhoto } className={styles.userPhoto} /></div>
                                        <div>
                                            {user.followed 
                                                ? <button onClick = { ()=> {this.props.unfollow(user.id)} }>Unfollow</button> 
                                                : <button onClick = { ()=> {this.props.follow(user.id)} }>Follow</button>}
                                        </div>
                                    </span>
                                    <span>
                                        <span>
                                            <div>{user.name}</div>
                                            <div>{user.status}</div>
                                        </span>
                                        <span>
                                            <div>{'user.location.country'}</div>
                                            <div>{'user.location.city'}</div>
                                        </span>
                                    </span>
                                </div>)
                            }
                        </div>
                    )
                }



    Теперь у нас по сути происходит то же что и с ф-м компонентом, но разница в том что  ф-й компонент реакт вызвал, ф-я отдала
        JSX разметку и исчезла, и чтобы перерисовать этот бло нужно снова вызвать ф-й компонент. С классовым по другому в памяти
        создается объект класса и для ререндера реакт обращается к нему же(объект никуда не девается). Такое поведение решает
        проблему запросов на сервер, потому что при каждой перерисовке происходил запрос на сервер, теперь же в объекте этот
        запрос будет выполняться 1 раз во время конструирования объекта и данные не будут пропадать как с ф-м компонентом,
        а будут сохраняться в объекте, а для перерисовки будет вызываться заново метод render.


    Теперь можно сделать чтобы запрос был не по кнопке а засунуть его в конструктор что бы данные сохранялись в объекте,
        //! так делать нельзя говорить автор, но мы сделаем, почему бы и нет)) Нам даже не понадобиться условие if потому что
        конструктор вызовется всего 1 раз при создании объекта. Конструироваться объект будет при переходе на страницу Users
        если из нее перейти на Profile (router убивает этот объект) а потом снова на Users то конечно объект создастся заново 
        но снова запросит данные с сервера только 1 раз.

            class Users extends React.Component {

                constructor(props) {
                    super(props);

                    axios.get(srcApiSamurai)
                        .then( response => { 
                            this.props.setUsers(response.data.items); 
                        });
                    
                }

                render() {

*/}


{/*    ====    54. Практика - Жизненный цикл, life cycle methods, componentDidMount     ====

    Класс нужен для того чтобы создавать объекты(экземпляры класса).

    Классовый компонент нужен для создания(посредника между классовым компонентом и реактом) объекта с которым взаимодействует
        реакт для получения JSX при этом он остается в памяти и с ним происходят различные жизненные события о которых ему сообщает
        реакт(новые props, отрисовка JSX который вернул объект) через объекты жизненного цикла. 
        
        Они беруться из стандартного реактовского классового компонента который мы расширяем при написании нашего компонента.
        При этом для Users будет своим только то что мы напишем в конструкторе и методы которые мы напишем в данном случае метод
        будет только render, но при создании нашего компонента он наследует и методы из родительского классового компонента реакта
        и созданные объект класса Users будет обладать всеми методами class React.Component (componentDidMount, componentDidUpdate,
        ... ) поэтому реакт может их вызвать у создаваемого объекта m1. 
        
            class React.Component {
                constructor(props){
                    this.props = props;
                    this.xyxy = ...;
                }
                componentDidMount() { ... }
                componentDidUpdate() { ... }
                ...
            }
        
        
            class Users extends React.Component {
                constructor(props) {
                    super(props);
                }
                render() {  return( ... ) }
            }
                   

            let m1 = new Users({
                name: 'Dima',
                age: 31
            });
            let jsx = m1.render();
            -> rootDiv.append(jsx.toDom);
            m1.componentDidMount();

        Таким образом например создался объект m1, реакт взял у него разметку JSX вызвав метод рендер, потом закинул эту разметку в
        DOM дерево, но объект не знает что реакт сделал после вызова рендера, а хотел бы узнать потому что от этого может зависеть
        поведение компонента и тогда реакт вызывает у него наследованный от родителя метод жизненного цикла componentDiDMount
        сообщая компоненту что его JSX был вмонтирован в HTML и отрисован. Именно для этого и существуют методы жизненного цикла,
        потому что созданние объекта m1 еще не значит что компонент был отрисован. 

        Мы можем если определим этот метод componentDidMount в нашем компоненте при вызове его реактом задать ему дополнитетьльное
        поведение, например показать alert сообщение что компонент отрисовался:

            class Users extends React.Component {
                constructor(props) {
                    super(props);
                }
                componentDidMount() { alert('I am in DOM already') }
                render() {  return( ... ) }
            }


        Например если компонент делал периодические запросы на сервер или показывал таймер отсчета, то реакт вызвав метод 
        componentWillUnmount (компонент будет демонтирован) - при клике на другую ссылку, реакту нужно удалить текущий компонент и
        отрисовать тот на который укажет ссылка(через Route), таким образом реакт сообщает компоненту чтобы он сделал 
        подготовительную работу перед его демонтажем(сброс таймера, сохранение последней информации о запросе на сервер).
        //! Если ссылки делаются через Route то объект созданный из класс. комп. создается 1 раз и при смене url он удаляется
        //! но заново создается когда снова нужно отрисовать этот компонент(юзер клацнул на соответсвующую ссылку)


    Таким образом все сайд эффекты(наш запрос на сервер для получения пользователей) прописываем в componentDidMount, нужно 
        перенести его из нашего constructor. Когда мы делали раньше изменения в store то перерисовывали все компоненты, но так
        как в классовом компоненте создается объект 1 раз он не будет заново создаваться и монтироваться на страницу (например
        при получении новых данных с сервера) для этого используется метод обновления (update). Таким образом метод компонента
        componentDidMount - вызовется только 1 раз и поэтому он идеально подходит для нашего запроса на сервер.

            let jsx = m1.render();
            -> rootDiv.update(jsx.toDom);
            m1.componentDidUpdate();



    Сделаем этот рефакторинг в нашем коде. Перенесем запрос на сервер в componentDidMount(если опечатаемся, то реакт все равно
        будет вызывать правильный методо, но наш - похожий но не тот не будет задействован) и теперь когда конструктор ничего
        своего(уникального для этого класса) не делает, его можно удалить(создание объекта происходит автоматически):

            class Users extends React.Component {

                componentDidMount() {
                    axios.get(srcApiSamurai)
                        .then( response => { 
                            this.props.setUsers(response.data.items); 
                        });
                }

                render() {
                    return(
                        <div> ...


    //! У меня юзеры добавляются по 2 раза, причем если перейти на другую страницу, а потом вернуться то их прибавиться еще 2 списка.
    //! А если обновить просто 2. Если дописать условие то при любых манипуляциях всё равно получается двойной список. Пока оставлю
    //! так как у автора. Прищла мысль что может такое поведение вызвано тем что массив у меня не [] пустой, а там 
    //! закомментированный код был, сейчас убрал нужно проверить как себя будет вести.

*/}


{/*    ====    55. Практика - pagination, постраничный вывод пользователей     ====

    Pagination(пейджинейшн) -  постраничный вывод, это про организация данных, взаимодействие с серверным API.

    Если сервер на запрос выдает сразу всю информацию, если данных очень много то при такой выдаче сервер будет висеть, канал
        интернета забьется(например если множество песен нужно отдать), поэтому  сервер выдаtn информацию порционно
        (по частям - страницам(page)). 

            https://social-network.samuraijs.com/api/1.0/users
        
        При нашем запросе мы получим первую часть(страницу-page), но если мы хотим получить следующую часть(страницу-page) нам
        нужно изменить url get запроса на сервер(потому что только так при get запросе мы может взаимодействовать с сервером),
        дописать через знак ? get параметр(ключ - значение) также еще нащывается query string( строка запроса). 

            https://social-network.samuraijs.com/api/1.0/users?pageNumber=2


        Почему pageNumber=2 а не например page=2 - это определяется серверным API, как его запрограммировал серверный разработчик.
        Такие вещи как параметры get запросов, по сколько пользователей в каждой части должны быть написаны в документации к серверу.

        Например сервер разбил 14 пользователей по 5 итого получилось 3 страницы, и чтобы получить первую нам нужно сделать get
        запрос users?pageNumber=1 (чтобы не получить сразу всю пачку пользователей не напрягать сервер незабивать инет канал).
        Потом мы эти 5 юзеров можем отобразить и сделать ссылки 1 -2- 3 - для переключения по страницам юзеров, тоесть когда юзер
        сайта нажмет на 2 нам нужно сделать запрос users?pageNumber=2 и отобразить ему следующих.

        Но что делать если например сервер делит по 5 юзеро, а интерфейс у нас расчитан на 3х, как отобразить сразу 4-5-6го юзера
        если она находяться на разных страницах сервера. Как правило сервер поддерживает возможность гибкого указания размера
        страницы например users?pageNumber=1&pageSize=3 или users?pageNumber=1&count=3 - тоесть первых 3х пользователей первой
        страницы.

        Для того чтобы построить ссылки на страницы пользователей нам нужно знать общее количество юзеров(записей) оно нам придет
        с сервера и мы их разделим на количество юзеров на странице(заданное нами или сервером если совпадает с нашими 
        пожеланиями).


    Если посмотреть на сервер  https://social-network.samuraijs.com/api/1.0/users то в документации написаны параметры get запросв
        по умолчанию возвращает 10 пользователей(count defualt -10, maximum - 100), page (default -1) - страница будет отображаться
        по умолчанию, и тд... Будем внедрять в наш проект.



    Сделаем отображение общего количества пользователей по страницам (1 2 3 ... ). Для этого в Users добавим разметку с этими 
        значениями над пользователями. Для начала сделаем заглушку для визуала.

            return(
            <div>
                <div>
                    <span className={styles.Selectedpage}>1</span>
                    <span>2</span>
                    <span>3</span>
                    <span>4</span>
                    <span>5</span>
                </div>


        Сделаем в БЛЛ так чтобы из него бралось это количество кнопок которые нужно отрисовать(помним что это число
        считается из деления totalCount(юзеры которые приходят с сервера)/pageSize(размер страницы который мы определяем сами)) и
        это число у нас должно быть в БЛЛ(store) в users-reducer initialState где и определяется наш store. Добавим эти значения,
        причем totalUsersCount мы не знаем какое будет число пока не получим ответ от сервера - оставим его первоначальное 
        значение - 0.
        
            let InitialState = {
                usersData: [ ],
                pageSize: 5,
                totalUsersCount: 0
            }


        Эти свойства прокидываем через props в комопнент Users. Для этого в UsersContainer добавим эти свойства в ф-ю 
        передающую  sate в презентационный компонент Users 

            let mapStateToProps = (state) => {
                return {
                    users: state.usersPage.usersData,
                    pageSize: state.usersPage.pageSize,
                    totalUsersCount: state.usersPage.totalUsersCount
                }
            };


        В users можно сделать переменную в которой будем на основании этих данных из props посчитать сколько нужно 
        отобразить страниц. Получаем число, теперь чтобы отобразить такое же количество элементов (их мы отображали пробегаясь
        map по массиву с элментами) сделаем на основе числа через цикл for массив с колличеством эл. равным числу, и так как 
        на сайте будет отсчет от 1 а не от 0, то i = 1. 
        
             render() {
                let pegesCount = this.props.totalUsersCount / this.props.pageSize;
                let pages = [];

                for (let i = 1; i <= pegesCount; i++) {
                    pages.push(i);
                }

                return(
                    <div>
                        <div>
                            { pages.map( page => {<span className={true && styles.Selectedpage}>{page}</span>} ) }
                        </div>


        Также для отображения выбранной страницы нужно ввести условие если true тогда отображать как выделенную, это true нам нужно
        откуда то взять, и конечно нужно его как свойство добавить в наш state, назовем его currentPage, присвоим значение 1 по
        умолчанию, всегда будем запрашивать первую страницу у сервера.

            let InitialState = {
                usersData: [],
                pageSize: 5,
                totalUsersCount: 0,
                currentPage: 1
            }

        
        Прокинем и это свойство через props в компонент Users.

            let mapStateToProps = (state) => {
                return {
                    users: state.usersPage.usersData,
                    pageSize: state.usersPage.pageSize,
                    totalUsersCount: state.usersPage.totalUsersCount,
                    currentPage: state.usersPage.currentPage
                }
            };


        Применим в условие это свойство сравнивая его с текущим (значением?) page

             <div>
                { pages.map( page => {
                    return <span className={this.props.currentPage === page && styles.Selectedpage}>{page}</span> }) 
                }
            </div>


        Пока не видно никаких цифр потому что у нас totalUsersCount - 0, для проверки можно его изменить на какое то число
        (например 20) и поменять currentPage чтобы увидеть как отрабатывает условие. Работает но если например у нас будет
        число юзеров 19, тоесть на 4й странице их будет не 5, а 4 и нам их тоже нужно показать, но при таком делении как у нас
        на странице отображается всего 3 страницы, тоесть на 4ю нам не нажать даже. При делении у нас получается дробное число,
        чтобы исправить такое поведение нужно рез-т округлять к большему целому с помощью  Math.ceil .

             let pegesCount = Math.ceil( this.props.totalUsersCount / this.props.pageSize );



    Будем использовать свойства state в запросе на сервер

        componentDidMount() {
            axios.get(
                `https://social-network.samuraijs.com/api/1.0/users?page=${ this.props.currentPage }&count=${ this.props.pageSize}`
                )
        .then( response => { 

        Видим что есть ответ и пользователей на странице 5 вместо 10ти, поменяем в state currentPage на 2 видим что пришли другие
        пользователи.



    Сделаем переключение страниц по клику(изменяя currentPage в state) для этого в reducere сделаем новую константу, ф-ю, АС:

            const SET_CURRENT_PAGE = 'SET_CURRENT_PAGE';

            case SET_CURRENT_PAGE:
                return { ...state, currentPage: action.currentPage }

            export const setCurrentPageAC = (currentPage) => ({ type: SET_CURRENT_PAGE, currentPage })

        
        Принимаем action для использования в UsersContainer

            setCurrentPage: (currentPage) => { dispatch(setCurrentPageAC(currentPage)); }


        Используем в users  onClick={() => { this.props.setCurrentPage(page):

            { pages.map( page => {
                        return <span className={this.props.currentPage === page && styles.Selectedpage}
                        onClick={() => { this.props.setCurrentPage(page) } }>{page}</span> }) 
                    }

            
        Номера страниц меняются(происходит выделение цифры) значит в state отправляются данные и происходит перерисовка, но юзеры
        пока не меняются потому что не идет запрос на сервер. Запрос на сервер нужно делать в момент клика юзера чтобы оперативно
        показываеть ему новую страницу, чтобы не нагромождать в onClick кучу всего сделаем метод который и будем использовать при
        клике. 

        Назначим анонимную ф-ю обработчиком события чтобы она принимала "е" (чтобы разгрузить наш метод onPageChanged от этого
        чтобы он смог принять страницу по которой кликнули), для того чтобы при вызове метода она передавала в него кликнутую 
        страницу. Так как "е" мы нигде не используем то можно его убрать но для наглядности что это обработчик события оставим.
        Благодаря замыканию мы сохранили наш page.

            onPageChanged = (pageNumber) => {
                this.props.setCurrentPage(pageNumber)
            }
            

            { pages.map( page => {
                return <span className={this.props.currentPage === page && styles.Selectedpage}
                onClick={(e) => { this.onPageChanged(page) } }>{page}</span> }) 
            }


        Вставим в метод запрос на сервер модифиируя его, изменим props.currentPage на pageNumber который мы диспатчим в state
        чтобы запрос был по актуальной странице(так как в props еще старый номер страницы) и тогда юзеры засетаются в state и 
        произойдет перерисовка уже по актуальным юзерам. PageSize пока не меняется его оставляем как есть.

             onPageChanged = (pageNumber) => {
                this.props.setCurrentPage(pageNumber);
                axios.get(`https://social-network.samuraijs.com/api/1.0/users?page=${pageNumber}&count=${ this.props.pageSize}`)
                    .then( response => { 
                        this.props.setUsers(response.data.items); 
                    });
            }

        Сейчас работает так что при клике на номер странички новые юзеры добавляются в конец( к старым ). Уберем это поведение
        изменив диспатч, так новые юзеры которые приходят будут затирать предыдущих

             case SET_USERS:
                return { ...state, usersData: action.users }



    Сделаем получение реального числа юзеров totalUsersCount, так как оно у нас не меняется при каждом запросе то можно сделать
        такое получение 1 раз при первом запросе.

            componentDidMount() {
                axios.get(`https://social-network.samuraijs.com/api/1.0/users?page=${ this.props.currentPage }&count=${ this.props.pageSize}`)
                    .then( response => { 
                        this.props.setUsers(response.data.items);
                        this.props.setTotalUsersCount(response.data.totalCount); 
                    });
            }

        

        Нужно создать этот коллбек и диспатч.

            let mapDispatchToProps = (dispatch) => {
                return {
                    follow: (userId) => { dispatch(followAC(userId)); },
                    unfollow: (userId) => { dispatch(unfollowAC(userId)); },
                    setUsers: (users) => { dispatch(setUsersAC(users)); },
                    setCurrentPage: (currentPage) => { dispatch(setCurrentPageAC(currentPage)); },
                    setTotalUsersCount: (totalCount) => { dispatch(setTotalUsersCountAC(totalCount)); }
                }
            };


            const SET_TOTAL_USERS_COUNT = 'SET_TOTAL_USERS_COUNT';

            case SET_TOTAL_USERS_COUNT:
                return { ...state, totalUsersCount: action.count }

            export const setTotalUsersCountAC = (totalUsersCount) => ({ type: SET_TOTAL_USERS_COUNT, count: totalUsersCount  })


    Paginator готов (не слишком красивый, но работает).

    //todo проверить работоспособность. Проверить как ведет себя список юзеров после удаления комментов из [] юзеров в state

    //! Работает но пользователей 4273 - страниц, и они все столбиком выводяться, а потом 5 текущих юзеров, надо прятать!

*/}


{/*    ====    56. Практика - Презентационный и Контейнерный компоненты     ====

    Сейчас Users слишком умный компонент с сайд эффектом AJAX запроса. Нужно сделать из нее чистый омпонент оставив AJAX запросы
        для контейнерного компонента. Тоесть у нас будет 2 контейнерных компонента: 1 общается со store( с помощью connect через
        context API ) и прокидывает props, 2й делает запросы и будет чистый компонент который только возвращает JSX разметку. 

    
    Создадим отдельный чистый ф-й компонент Users и будем его возвращать в классовом компоненте UsersAPIComponent(который 
        делает запросы), в Users будет возвращаемая разметка и логика которая отвечает за внешний вид, также нужно передать в нее
        props из UsersAPIComponent:

            
            import React from 'react';
            import styles from './Users.module.css';
            import userPhoto from '../../assets/images/user.jpg'


            let Users = (props) => {

                let pegesCount = Math.ceil(props.totalUsersCount / props.pageSize);
                let pages = [];

                for (let i = 1; i <= pegesCount; i++) {
                    pages.push(i);
                }

                return <div>
                    <div>
                        {pages.map(page => {
                            return <span className={props.currentPage === page && styles.selectedPage}
                                onClick={(e) => { props.onPageChanged(page); }}> {page} </span>
                        })
                        }
                    </div>
                    {
                        props.users.map(user => <div key={user.id}>
                            <span>
                                <div><img src={user.photos.small !== null ? user.photos.small : userPhoto} className={styles.userPhoto} /></div>
                                <div>
                                    {user.followed
                                        ? <button onClick={() => { props.unfollow(user.id) }}>Unfollow</button>
                                        : <button onClick={() => { props.follow(user.id) }}>Follow</button>}
                                </div>
                            </span>
                            <span>
                                <span>
                                    <div>{user.name}</div>
                                    <div>{user.status}</div>
                                </span>
                                <span>
                                    <div>{'user.location.country'}</div>
                                    <div>{'user.location.city'}</div>
                                </span>
                            </span>
                        </div>)
                    }
                </div>
            }


            export default Users;




    Но два контейнерных компонента тоже не очень удобно, порэтому перенесем UsersAPIComponent в UsersContainer и переименуем
        UsersAPIComponent в UsersContainer - это у нас будет классовый компонент внутри файла UsersContainer :

            import React from 'react';
            import {connect} from 'react-redux';
            import {followAC, unfollowAC, setUsersAC, setCurrentPageAC, setTotalUsersCountAC} from '../redux/users-reducer'
            import axios from 'axios';
            import Users from './Users'


            class UsersContainer extends React.Component {

                componentDidMount() {
                    axios.get(`https://social-network.samuraijs.com/api/1.0/users?page=${this.props.currentPage}&count=${ this.props.pageSize}`)
                        .then( response => { 
                            this.props.setUsers(response.data.items);
                            this.props.setTotalUsersCount(response.data.totalCount); 
                        });
                }

                onPageChanged = (pageNumber) => {
                    this.props.setCurrentPage(pageNumber);
                    axios.get(`https://social-network.samuraijs.com/api/1.0/users?page=${pageNumber}&count=${ this.props.pageSize}`)
                        .then( response => { 
                            this.props.setUsers(response.data.items); 
                        });
                }

                render() { return <Users totalUsersCount={this.props.totalUsersCount}
                                        pageSize={this.props.pageSize}
                                        currentPage={this.props.currentPage}
                                        onPageChanged={this.onPageChanged}
                                        users={this.props.users}
                                        follow={this.props.follow}
                                        unfollow={this.props.unfollow}
                                    />
                }
            }

            let mapStateToProps = (state) => {...

            let mapDispatchToProps = (dispatch) => {...

            export default connect (mapStateToProps, mapDispatchToProps)(UsersContainer);

*/}


{/*    ====    57. Пример - Preloader, loader-gif, isFetching indication     ====

    Preloader - анимация (крутилка) которая визуализирует загрузку чего-либо(сайта, запроса на сервер после клика по кнопке ).

    Любая визуальная часть показывается в зависимости от состояния БЛЛ, значит нам нужно внести изменение в store чтобы компонент
        знал когда показывать, а когда не показывать preloader и это будет зависеть от состояния свойства в state.

    
    В users-reducer добавим свойство isFetching со значением false. Когда компонент будет посылать AJAX запрос он также изменит
         это значение на true через диспатч(коллбек) и тогда будет отображаться крутилка до того момента пока компонент не получит
         ответ и не задиспатчит изменения в state.


    Пока просто прокинем это свойство через mapStateToProps чтобы посмотреть как будет реагировать UI без создания action. Получаем
        этот props в классовом компоненте UsersContainer и дальше нам в принципе не нужно его прокидывать, потому что запрос 
        делается тут и поэтому тут можем отобразить крутилку вторым тегом и в последстии делать диспатч. Добавим пустой элемент
        чтобы поместить в него тег Users и тег с крутилкой, раньше нужно быо div элемент делать а сейчас можно просто пустой.
        //todo найти картинку для тега - <img src=''/> вставить в src, можно проимпортировать и потом вставить как объект { }

            render() {
                return <>
                    { this.props.isFetching ? <img src=''/> : null }
                    <Users totalUsersCount={this.props.totalUsersCount}
                        pageSize={this.props.pageSize}
                        currentPage={this.props.currentPage}
                        onPageChanged={this.onPageChanged}
                        users={this.props.users}
                        follow={this.props.follow}
                        unfollow={this.props.unfollow}
                    />
                </>
            }

        проверку прошло успешно.  


    Cоздаем action creater в users-reducer, переменную и кейс. //! Можно было бы сделать так чтобы не принимать action.isFetching, 
        //! а просто менять !isFetching - текущий на противоположный, но если будет много запросов будет неразбериха с этим 
        //! значением поэтому мы будем принимать конкретно action.isFetching уже сформированный как true или false в компоненте.
            
            const TOGGLE_IS_FETCHING = 'TOGGLE_IS_FETCHING';

            case TOGGLE_IS_FETCHING:
                return { ...state, isFetching: action.isFetching }

            export const toggleIsFetchingAC = (isFetching) => ({ type: TOGGLE_IS_FETCHING, isFetching  })


    В UsersContainer создаем коллбек чтобы классовый компонент его мог принять. //! Мы диспатчим не action creater, а его вызов.
        //!  action creater возвращает объект action который и диспатчится, потому что так работает redux - ему нужен объект в
        //! котором есть тип который redux достанет и сделает нужное действие:

            toggleIsFetching: (isFetching) => { dispatch(toggleIsFetchingAC(isFetching)); }


        теперь можно использовать toggleIsFetching при запросе - отправим true чтобы показывать крутилку, а когда получим ответ от
        сервера отправим false чтобы крулка не показывалась:

            componentDidMount() {
                this.props.toggleIsFetching(true);
                axios.get(`https://social-network.samuraijs.com/api/1.0/users?page=${this.props.currentPage}&count=${this.props.pageSize}`)
                    .then(response => {
                        this.props.toggleIsFetching(false);
                        this.props.setUsers(response.data.items);
                        this.props.setTotalUsersCount(response.data.totalCount);
                    });
            }

            onPageChanged = (pageNumber) => {
                this.props.setCurrentPage(pageNumber);
                this.props.toggleIsFetching(true);
                axios.get(`https://social-network.samuraijs.com/api/1.0/users?page=${pageNumber}&count=${this.props.pageSize}`)
                    .then(response => {
                        this.props.toggleIsFetching(false);
                        this.props.setUsers(response.data.items);
                    });
            }
            
        //! У автора не показывалась крутилка, даже при замедлении интернета как slow 3G в вкладке Network инспектора кода
        //! она как бы моргала(место под нее было но она не успевала показываться) так происходило потому что стояла галочка 
        //! disable cash и таким образом каждый раз крутилку подгружало с сервера и она загружалась за мгновение до загрузки юзеров
        //! поэтому ее не было видно. Нужно preloader сохранить в папку с картинками проекта. 



    Так как preloader у нас может использоваться на многих страницах приложения, то можно его вынести как отдельный компонент.
        Создаем папку common (общие) в ней папку preloader и там уже Preloader.jsx и скопируем туда код(создавая ф-й компонент,
        импортируя реакт, експортируя комопнент) также импортируем Preloader в UsersContiner

            import React from 'react';
            import preloader from '../../../assets/images/preloader.svg'

            const Preloader = (props) => {
                return <>
                    <img src={preloader} />
                </>

            }

            export default Preloader;



    //! Проверено дома, работает, но крутилка все равно как-то 2 раза из 3х показывается.

*/}


{/*    ====    58.  mapDispatchToProps лайф-хак     ====

    mapStateToProps и mapDispatchToProps позволяют пркидывать в нужный компонент в пропсах свойства и коллбеки. mapStateToProps
        возвращает объект со свойствами которые мы берем из state по отдельности, это для того чтобы прокинуть в компонент только
        нужные ему свойства от которых зависит его перерисовка(чтобы он не ререндерился если обновится какое то свойство state не 
        участвующее в компоненте). mapDispatchToProps прокидывает коллбеки(ф-и) возвращая объект с этими ф-ями. Эти свойства и
        коллбеки connect собирает в один общий объект props. 


    Так как по сути в mapDispatchToProps мы делаем обертку(коллбек) для ф-и(объекта) экшен криэйтера который создан в памяти,
        мы по сути делаем на него ссылку в новом обхекте mapDispatchToProps. Коннект может это сделать за нас, даже если мы
        просто передадим объект со свойствами вместо ф-й

            было
            follow: (userId) => { dispatch(followAC(userId)); },

            станет
            follow: followAC,

        и connect сам сделает из них коллбеки, тогда надобность в mapDispatchToProps отпадает и мы передадим в connect просто
        объект.

            export default connect(mapStateToProps, {
                follow: followAC,
                unfollow: unfollowAC,
                setUsers: setUsersAC,
                setCurrentPage: setCurrentPageAC,
                setTotalUsersCount: setTotalUsersCountAC,
                toggleIsFetching: toggleIsFetchingAC
            })(UsersContainer);


    
    Так как современный синтаксис дает нам возможность делать запись таким образом что при создании объекта если имя его свойства
        такое же как имя его значения name: name - можно сократить запись до просто name. В данном случае переменную name помещаем
        в объект obj как свойство, и объект понимает что если есть одно имя свойства, значит где то есть переменная с таким
        именем, он посмотрит выше найдет переменную name и присвоит свойству name ее значение.

            let name = 'Alex';
            let obj = {
                name
            }
            alert(obj.name)


        Таким образом если в reducere убрать из названия action createrов буквы AC можно еще сократить наш код(подправим и импорт),
        наш код станет еще короче:

            import { follow, unfollow, setUsers, setCurrentPage, setTotalUsersCount, toggleIsFetching } from '../redux/users-reducer'

            export default connect(mapStateToProps, 
                        { follow, unfollow, setUsers, setCurrentPage, setTotalUsersCount, toggleIsFetching})
                        (UsersContainer);

*/}


{/*    ====    59.  profile page, ajax, api     ====

    Сейчас на странице profile показывается только наш профиль. Сделаем так чтобы при клике на юзера на открывался
        его профиль. Сделаем это обернув аватарку юзера в тег navlink чтобы создавался путь к профилю пользователя, этот путь 
        можно будет скопировать и отправить кому-то:

        
    В users оборачиваем аватарку в navlink. По сути navlink это тег <a> просто к нему цепляют некоторое поведение. Импортируем
        navlink и прописываем путь, ссылка на каждого пользователя будет вести на profile + id юзера:

             props.users.map(user => <div key={user.id}>
                <span>
                    <div>
                        <NavLink to={ '/profile/' + user.id }>
                            <img src={user.photos.small !== null ? user.photos.small : userPhoto} className={styles.userPhoto} />
                        </NavLink>
                    </div>

        идет переход на страницу profile и далее показывается id юзера например profile/1060 но отображается наш обычный профиль
        потому что мы еще в нем не внесли изменения, а Route важно только чтобы начало пути совпадало тоесть profile, и он 
        перейдет на страницу профиля, а то что дальше идут какие то числа или буквы ему уже всё равно.

        //! При перемещении назад на страницу юзеров они снова запрашиваются с сервера, далее мы сделаем так чтобы если они уже есть
        в state мы их брали оттуда.

    
    //! Сейчас запросы мы отправляем по URL при этом добавляя дополнительные QUERY параметры через вопросительный знак "?", при
    //! этом URL адрес не меняется. На сервере есть отдельный ендпоинт для запроса профиля юзера чтобы на него попасть нужно
    //! вводить URI запрос он меняет ендпоинт, выглядит он так profile/{userid} - получаемый ответ в JSON формате.


    По аналогии с Users в Profile тоже нужно делать запрос на сервер, но это тоже ф-й компонент, поэтому для него нужно сделать
        контейнерный компонент ProfileContainer потому что для вложенных компонент ProfileInfo(профиль) и MyPostsContainer(посты
        юзера) могут понадобиться данные для отображения, и мы будем их передавать уже пропсами из Profile, а получать в 
        ProfileContainer. В App нужно изменить Profile на ProfileContainer

        Создаем классовый компонент ProfileContainer, он будет делать запрос на сервер и прокидывать все данные в компонент Profile
        //! так тут нам нужно прокинуть ВСЕ данные в props сделаем это одной записью  <Profile {...this.props} /> - так делается
        //! потому что для отправки данных в Profile  они как свойства запаковываются в объект props и получиться что наш объект
        //! который мы получим с сервера будет свойством в объекте props и к внутренним свойствам нужно будет обращаться через
        //! дополнительное слово например props.props.user еслибы запись была такая props={this.props}. А так как мы спред 
        //! оператором распаковываем этот объект то дополнитьной вложенности в объекте props у нас не будет и можно будет обратиться
        //! props.user

            class ProfileContainer extends React.Component {
                render() {
                    return <Profile {...this.props} />
                }
            }


    Дополняем стандартный метод объекта componentDidMount нашим поведением - запросом на сервер. Для получению профиля юзера к
        стандартному URL добавляем profile, но какого юзера мы получим пока не умеем определять, захардкодим пока юзера номер 2
        приходящий response содержит множество информации, но нужная нам(профиль) находится в объекте data поэтому его мы и будем
        из response сетать в reducer:

            componentDidMount() {
                axios.get(`https://social-network.samuraijs.com/api/1.0/profile/2`)
                .then(response => {
                    this.props.setUserProfile(response.data);
                });
            }

        
        Создаем коллбек который будет сетать данные юзера в объект в редюсере с помощью connect который импортируем. Пока в 
        mapStateToProps напишем выдуманное свойство, если mapStateToProps пишем в одну строчку - то нужно добавлять () скобки
        иначе mapStateToProps будет восприниматься не как ф-я которая возвращает объект, а этот объект будет восприниматься как
        код let mapStateToProps = (state) => ({a: 13}) :

            let mapStateToProps = (state) => {
                a: 13
            }

            export default  connect(mapStateToProps, {setUserProfile} )(ProfileContainer);

    
    Создадим setUserProfile - этот экшн креэйтер в profile-reducer:
    
            const SET_USER_PROFILE = 'SET_USER_PROFILE'

                    userProfile: null  - в initial state присвоим значение null - пусто(можно было и пустой объект присвоить)

                case SET_USER_PROFILE: 
                    return {...state, userProfile: action.profile};

            export const setUserProfile = (profile) => {
                return { type: SET_USER_PROFILE, profile}
            }


    Теперь написав store.getState() в консоли видим что в profilePage в userProfile есть объект с данными. Сделаем отображение
        этих данных в ProfileInfo и для этого в профайл контейнер прокинем эти данные, а из него через props прокинем в Profile
        который и содержит ProfileInfo, :

            let mapStateToProps = (state) => {
                profile: state.profilePage.userProfile;
            }


            return <Profile {...this.props} profile={this.props.profile}/> - 
            //! тут дополнительно прокидываем profile отдельно от тех {...this.props} - которые пришли из вне(с сервера?)


        Profile :  <ProfileInfo profile={props.profile}/> 

        ProfileInfo:      <img className={style.userAvatar} src={props.profile.photos.large} />


    //! Появилась ошибка не может взять фото у null. Так как мы при инициализации в редюсере указали null это он вызывает ошибку
    //! при первичном рендере страницы, пока еще запрос на сервер не был отправлен и данные не занеслись в state, поэтому нужно
    //! сделать условие для проверки на null или undefined и если у нас нету тогда мы вервнем вместо фото юзера компонент
    //! Preloader показывая что ожидается подгрузка профиля.
    

        ProfileInfo:
        
            const ProfileInfo = (props) => {
                if(!props.profile) {
                    return <Preloader/>
                }

                return (



    //todo достать остальные даные из профиля юзера и отобразить их в description.

    //! следующий урок будем анализировасть адресную строку и доставать айди юзера 

*/}


{/*    ====    60.  withRouter, props.match.params     ====

    withRouter - компонент высшего порядка( HOC - High Order Component )

    //!Сейчас у нас есть UI - React - библиотека которая эффективно отрисовываетс страницу, у нее есть свой механизм управления 
        statом в классовом компоненте - setSate или в функциональном компоненте черех хуки useState. Чтобы не засорять statом реакт 
        (придерживаться для компонентов single responcibility принципа) подключаем Redux чтобы у нас был отдельный источник данных.
        В редаксе из store мы получаем state (через метод getState - созданный чтобы искапсулировать state, отделить его от прямого
        вмешательства) и в store диспатчим данные (через store.dispatch  - connect скрывает это от нас но работает также внутри).
        Когда мы что то диспатчим store это берет прокидывает по всем редюсерам и state преобразовывается.

        Теперь появился второй источник информации - сервер(адресная строка). Есть разные подходы что с чем должно взаимодействовать
        мы используем стандартный(базовый, частоприменимый) подход, когда UI - react читает адресную строку(получает данные с 
        сервера) диспатчит данные в БЛЛ store и после его обновления перерисуется UI.


        Применимо к нашему проекту - благодаря withRouter вычленяем id юзера в компоненте, потом в методе componentDidMount делаем
        запрос на сервер по айди юзера, получаем его данные(профиль), диспатчим этот профиль в store и после его обновления 
        ререндерим страницу под текущий state.


        //! получать айди юзера можно нативныйм JS но при таком способе придется взаимодействовать с глобальными данными document
        locatiom, это нарушает принцип того что все данные которые нужны компоненту получаются через props, а не через import 
        или из глобальных сущностей(вещей) - таким обрзом мы контролируем предсказуемость поведения компонента, легко его 
        тестируем потому что знаем что компонент даст определенный JSX в зависимости от определенных входящих props.

        Значит получать айди юзера из адресной строки будет через withRouter.



    Так как у нас запрос на сервер для получения профиля идет из классового компонента ProfileContainer то он уже перед запросом
        должен получить данные которые подставил в адресную строку запроса. Данные в ProfileContainer приходят в объекте который
        создает connect. Значит перед тем как ProfileContainer отдать данные через connect нужно получить айди нужного профиля 
        юзера и передать их connectom вместе с  данными из state.

        //! Пропишем в componentDidMount debugger и при остановке кода в консоль введем this.props видим что приходит объект 
        { profile: null, setUserProfile: f } - профиль и ф-я коллбек которая диспатчит данные в store для этого свойства profile.


        Теперь перед connectom пропишем withRouter при этом его заимпортировав из react dom библиотеки

            withRouter(ProfileContainer);

        withRouter - работает также как connect( возвращает новый компонент который по факту отрисует ProfileContainer но закинет
        в него данные из store). withRouter вернет новый компонент в который отрисует ProfileContainer но в него закинутся еще
        данные из URL. Для наглядности можно записать так:

            let WithUrlDataContainerComponent = withRouter(ProfileContainer);

            export default  connect(mapStateToProps, {setUserProfile} )(WithUrlDataContainerComponent);

        тоесть withRouter отработал и вернул компонент в который мы передадим данные через connect из store.


        //! теперь при просмотре this.props в консоли видим что в объекте появились еще свойства:

            {
                history: { length: 2, action: POP, location: { ... }, history: { ... }, ... }
                location: { pathname: 'profile/10', search: '', hash: '', state: udefined }
                match: { path: '/profile', url: 'profile', isExact: false, params: { }  }
                profile: null 
                setUserProfile: f ()
                staticContext: undefined
            }

            //! staticContext появился из-за BrouserRouter (делает тоже самое что и в Provider который мы делали) которым мы 
            оборачиваем всё наше содержимое для того чтобы дочерние компоненты могли достучаться через context к данным которые
            поставляются как и Providerом в данном случае BrouserRouterом. можно пересмотреть видео про Provider.
            //! Этот BrouserRouter у него в index.js оборачивает Provider и весь App, у меня он в App может нужно будет перенести.

            В location есть путь по которому в данный момент открыто окно(где мы находимся) pathname: 'profile/10' - тут как раз
            видно что мы хотели бы отобразить 10го юзера.

            match - совпадение текущего URL с каким то Route. Совпадение найдено с путем path: '/profile' , но так как совпадение
            не полное(наш путь profile/10) поэтому isExact: false. params: { } - в данном случае пустой объект, параметры это то
            что у нас в строке браузера тоесть 10 это параметр, но в params он не заносится потому что мы не прописали этого в 
            Route. Поэтому легко прочесть эту 10ку мы не можем. можно обратиться к location, взять pathname и разбить строку на
            подстроки, засплитать, взять последние цифры или использовать регулярные выражения - НЕ НУЖНО УСЛОЖНЯТЬ. Сделаем 
            правильно и легче. 
            

            Пропишем в Route для пути /profile параметры и тогда та часть которая будет после /profile/ будет сама извлекаться и
            храниться в params откуда мы ее просто заберем. В будущем реализуем поведение что если у profile есть параметр то
            покажем этот profile, а если нету то покажем наш профиль(сейчас сделаем заглушку). Обозначается параметр двоеточием :
            и именем которое мы придумаем для параметра:

                   <Route path="/profile/:userId" element={<ProfileContainer />} />

            Таким образом говорим что у нас есть параметр userId

            теперь в консоли видим isExact: true, path: '/profile/:userId', url: '/profile/10' и в params теперь { userId: '2'}

            //! параметры можно добавлять еще "/profile/:userId/:secondParams  - и их доставать, но наc пока интересует userId


    Теперь в didMount получим userId и прикрепим его в строку запроса(//!автор сделал конкатенацией потому что к концу строки
        лепим):

                componentDidMount() {
                    let userId = this.props.match.params.userId;
                    axios.get(`https://social-network.samuraijs.com/api/1.0/profile/${userId}`)


    Работает если клацнуть на юзера, но если путь будет просто profile то мы получаем пустую страницу без нашего компонента, нужно
        сказать что параметры для юзеров это опциональная вещь, они могут быть, а может их не быть, и тогде если их не будет
        просто отобразиться компонент Profile. После параметра ставим вопросительный знак ?:

                 <Route path="/profile/:userId?" element={<ProfileContainer />} />


        вылезла ошибка(постоянно крутится Preloader потому что не может получить доступ к данным по пути) при переходе по пути 
        /profile/ - так как теперь в переменную в дидМаунт приходит undefined и он приклеивается к пути запроса как текст(у автора
        конкатенация). Так что нужно эту ситуацию предусмотреть:

                componentDidMount() {
                    let userId = this.props.match.params.userId;
                    if (!userId) {
                        userId = 2;
                    }
                    axios.get

        Если у нас не будет опционального параметра - !userId - тоесть он равен null или undefined, то по умолчанию переменной
        присвоим пользователя под айди 2. Пока это будет 2 - но позже сделаем распознавание для системы чтобы показывало именно
        наш профиль.

        
        //! Сейчас нету withRouter, вместо него используется хук useParams и он не работает с классовым компонентом и нужно 
        //! использовать с ф-м применяя useState и также в App сделать отдельный роут для профилей с параметрами который
        //! будет вести на другую страницу или переделать наш классовый компонент в ф-й с хуком useState 

*/}


{/*    ====    61.  cookie, login в теории, auth me     ====

    В браузере для каждого сайта храниться cookie - файл который передается автоматически на серверс с КАЖДЫМ запросом(со старта
        cookie пустой). 
        
    Упрощенно эта печенька возвращается и от сервера, например при вводе логина и пароля мы посылаем запрос на сервер и если мы
        залогинились(совпал логин/пароль) то сервер в обратную печеньку записывает информацию(наш айди) в  ЗАКОДИРОВАННОМ виде
        (кодировку/декодировку производит только сервер). Печенька может жить или одну сессию или если поставить на сайте галочку -
        запомнить меня - будет продлеваться информация в печеньке с каждым запросом или установиться длительный срок. Теперь при
        каждом запросе на сервер - например к messages сервер знает что у нас такой айди и даст нам только наши сообщения.

    Сейчас у нас браузер подключен к localhost - это один домен и куки для него одна, и потом мы делаем запрос на сервер с юзерами
        это другой домен и куки для него другая. Такие запросы кросдоменные(когда с одного домена делается запрос на другой)
        запрещены политикой КОРС, но если сервер разрешает такие запросы то браузер их пропустит как сайчас и происходит.

        Тоесть когда залогинились на сервере юзеров создалась куки, и потом когда происходит запрос из приложения используется эта 
        же куки поэтому сервер с юъерами нас узнает.

    
    На сервере юзеров досупен новый ендпоинт по которому можно получить ответ от сервера авторизирован ли юзер или нет. Если
        да то приходит объект с пустым сообщением и объектом data в котором есть id, login, email. Если нет - тогда приходит объект
        с пустым объектом data и со свойством messages : ['You are not authorisec'] и свойством resultCode: 1 (при да - это свойство
        со значением - 0).
        
            https://social-network.samuraijs.com/api/1.0/aut/me

        Теперь можно это использовать для определения юзера не создавая у себя авторизацию. Тоесть юзер авторизируется на сервере
        юзеров, а в зависимости от ответа сервера мы можем показать данные юзера(имя или кнопку логин если он не залогинился), его
        аватарку, и тд...



    В компоненте Header //!(это не совмесем правильно делать в ней, но пока сделаем так) создадим контейнерный компонент в нем в 
        componentDidMount сделаем запрос на сервер на /aut/me , проанализируем ответ и покажем тот или иной интерфейс.

        Снова подготовим для этого весь цикл: reducer нам нужно диспатчить/мапить и т.д. //! До сейчас мы делали для каждой страници
        свой reducer с аналогичным названием, но reducer это БЛЛ и он не должен отвечать полностью структуре реакта, создадим 
        редюсер с названием auth-reducer.js который будет использовать компонент Header.


        С сервера приходит id, login, email в объекте data, сделаем такие же свойства в initaialState. В экшене мы создадим один
        объект data и в него положим все эти 3 свойства и деструктуризируем его чтобы они сразу распаковались в наш редюсерский
        объект. Чтобы более понятно что за data(данные) к нам приходят в экшен криэйтере примем все свойства которые будут и упакуем в
        data.

            const SET_USER_DATA = 'SET_USER_DATA';

            let initialState = {
                userId: null,
                email: null,
                login: null
            }

            const authReducer = (state = initialState, action) => {
                
                switch(action.type) {
                    case SET_USER_DATA:
                        return { 
                            ...state, 
                            ...action.data
                        }
                    
                    default:
                        return state;
                }
            }

            export const setUserData = (userId, email, login) => ({ type: SET_USER_DATA, data:{ userId, email, login}  })

            export default authReducer;


    Добавим этот редюсер в redux-store

            import authReducer from './auth-reducer'
            
            auth: authReducer


    Добавим в Header еще блок с авторизацией, присвоим класснейм и пока выровняем float по правой стороне. В этот див поместим
        navlink на страницу логина '/login' :

            <header className={style.header}>
                <img src="https://th.bing.com/th/id/OIP.PBVmERenoA81uh26kHU04QHaHa?pid=ImgDet&rs=1" />
                <div className={style.loginBlock}>
                    <NavLink to={ '/login'}>
                        Login
                    </NavLink>
                </div>


    Создадим контейнерный компонент HeaderContainer.jsx в котором будем делать запрос. Заменим Header на HeaderContainer в App:

            class HeaderContainer extends React.Component {

                componentDidMount() {
                    axios.get(`https://social-network.samuraijs.com/api/1.0/auth/me`)
                    .then(response => {
                        debugger;
                    });
                }

                render() {
                    return <Header {...this.props} />
                }
            }

        //! запрос вернул ошибку - не авторизованы. При кроссерверном запросе браузер автоматически не прицемпляет куки и для 
        //! этого нужно к гет запросу добавить параметр с настройками запроса withCredentials: true - означает что мы хотим 
        //! передавать логин, пароль и т.д. и если сервак поддерживает тогда пойдет запрос авторизованный и получим нужный ответ

             axios.get(`https://social-network.samuraijs.com/api/1.0/auth/me`, { withCredentials: true })
                .then(response => {

        Теперь HeaderContainer узнал что мы авторизованы и он может сделать диспатч этой информации в редюсер.

            import React from "react";
            import Header from './Header'
            import axios from 'axios';
            import { connect } from 'react-redux';
            import {setAuthUserData} from '../redux/auth-reducer'


            class HeaderContainer extends React.Component {

                componentDidMount() {
                    axios.get(`https://social-network.samuraijs.com/api/1.0/auth/me`, { withCredentials: true })
                    .then(response => {
                        if(!response.data.resultCode === 0) {
                            let { id, login, email} = response.data.data;
                            this.props.setAuthUserData( id, login, email );
                        }
                    });
                }

                render() {
                    return <Header {...this.props} />
                }
            }

            const mapStateToProps = (state) => ( {  } );

            export default  connect(mapStateToProps, { setAuthUserData } )(HeaderContainer);


        Через debugger проверяем чтобы в state были данные которые нам нужны. Сделали деструктуризацию ответа 
        
            let { id, login, email} = response.data.data; чтобы дальше писать сокращенно id, а не response.data.data.id для каждого

        своства.


    В Header сделаем показ логина если он есть в state, для этого добавим в редюсер свойство isAuth для проврки условия, и в диспатч
    добавляем что если диспатче данных юзера это свойство меняется на true. В контейнерном компоненте прокинем эти свойства :

                login: null,
                isAuth: false
            }

            const authReducer = (state = initialState, action) => {
                switch(action.type) {
                    case SET_AUTH_USER_DATA:
                        return { 
                            ...state, 
                            ...action.data,
                            isAuth: true
                        }


        в Heade props.login - покажеться как текст:

            <div className={style.loginBlock}>
                { props.isAuth ?  props.login : <NavLink to={ '/login'}>Login</NavLink>}
            </div>


    //todo можно сделать показ аватарки юзера, для этого уже зная айди посылаем после первого запроса второй тутже и получаем его
    //todo автарку или другую инфу и для этой инфы сделать в state соответствующие свойства и брать потом инфу из них.

*/}


{/*    ====    62.  follow-unfollow api     ====

    Сейчас поведение follow-unfollow реализовано локально. При нажатии на кнопку диспатчим в state новое значение свойства.

    Сделаем чтобы такой диспатч происходил только после подтверждения сервера что мы подписались или отписались. Тоесть сначала
        выполнятся POST(создать) запрос на сервер с номером(айди) юзера на которого мы хотим подписаться //! мы должны быть 
        //! залогинены при этом, потом сервер дает ответ что изменилось состояние и потом производим диспатч + перерисовку. Чтобы
        отписаться нужно послать DELETE(удалить) запрос.


    Сейчас у нас есть 2 кнопки follow unfollow к которым прицеплен обработчик события onClick в него передана анонимная ф-я 
        которая при нажатии на кнопку из props вызывает коллбек follow/unfollow. connect автоматически за нас создал эти коллбек
        ф-и, в них connect вызывает follow - action creater, он возвращает action который потом диспатчится.

        Теперь при нажатии кнопок будем вызывать не коллбек ф-ии, а свои ф-и которые будут посылать запрос на сервер, эти ф-и будут
        находиться в этом же компоненте, это не сайд эффект, а просто компонент стал немного умнее чем должен.


    Пока пропишем логику прямо в onClick потом чтобы не загромождать разметку логикой вынесем ее в отдельные ф-и. Для подписки или
        отписки нужно слать запрос на follow/userId - так написано в документации на сервер, и в ответе приходит resultCode: 0
        если операция успешна или 1 если неудачно. Так как нам нужно быть авторизованными для того чтобы выполнять подписку/отписку
        нужно посылать параметр { withCredentials: true } но в post запросе он идет 3м, пока вторым посылаем null или пустой объект.
        После проверки ответа сервера, если опарация успешна запускаем коллбек ф-ю, так же сделаем и с отпиской но DELETE запрос 
        как и get объект настройки принимает вторым.

             : <button onClick={() => { 
                                axios.post(`https://social-network.samuraijs.com/api/1.0/follow/${user.id}`, {}, 
                                { withCredentials: true })
                                .then(response => {
                                    if (response.data.resultCode == 0) {
                                        props.follow(user.id);
                                    }
                                });
                            }}>Follow</button>}


    Появилась ошибка, в консоли  CORS требует headers - заголовки, для всех запросов кроме get. В заголовок мы должны вставить 
        сгенерированный в профиле на сервере ключ. Его вставляем в заголовок в объекте настроек.
        //! посмотреть как сейчас пишется, на момент видео еще не было инструкции для вставки этого ключа и вставить свой ключ 

             { withCredentials: true,
                headers: {"API-KEY": "some generated key"}
              })                        

        //! теперь ошибки нету, и ответ от сервера был - вы уже фоловите этого юзера, а кнопка не сменилась на unfollow, так
        //! произошло потому что при запросе страницы юзеров, запрос проходил анонимно(без withCredentials ) и поэтому для 
        //! всех юзеров followed возвращается false. Нужно добавить авторизацию в запрос по юзерам.

        //! Все заработало у автора. В консоли в Network видим на один наш клик 2 запроса. 1й (preflight - предполетный) запрос дает 
        //! браузер на сервер - request method: OPTIONS, спрашивая можно ли слать такой то запрос не сервер, а сервер отвечает если
        //! да, то браузер делает этот(наш) запрос, если нет - то браузер не пропускает его, тоесть за CORS безопасность отвечает
        //! браузер. Это общение идет с помощью хедеров.

*/}


{/*    ====    63.  DAL, axios create     ====

    Сейчас с множеством запросов на сервер получается много повторяющегося кода + нагромождение в коде логики. Для решения этой
        проблемы будем разделять на уровни. Сейчас у нас UI + БЛЛ нам нужно добавить еще DAL.


    DAL - Data access level. В классическом подходе UI общаеться с БЛЛ, а БЛЛ общается с DAL (UI в DAL не лезет). К этому мы еще 
        прийдем.

    В нашем случае DAL будет общаться с сервером(API) и с UI , это нам позволит забрать у компонентов ф-ю запросов к серверу и
        поместив их в DAL вернуть компонентам сингл респонсибилити.



    Создаем к корне(папка src) папку api а в ней файл api.js и в него перенесем axios get запрос из UsersContainer DidMount и 
        обернем эту логику ф-й getUsers и сделаем return ответа на запрос - вынесем ответ из ф-ии:

            import axios from 'axios';

            export const getUsers = () => {
                return axios.get(`https://social-network.samuraijs.com/api/1.0/users?page=${this.props.currentPage}&count=${this.props.pageSize}`,
                        { withCredentials: true }) 
            }


    Теперь можем использовать эту ф-ю в UsersContainer вместо всего того запрос который был раньше:

            import { getUsers } from '../../api/api'  

              getUsers().then(response => {
                this.props.toggleIsFetching(false);
                this.props.setUsers(response.data.items);
                this.props.setTotalUsersCount(response.data.totalCount);
            });


        Получается ошибка, так происходит потому что в api у нас прописан this - но он может быть только в классовом компоненте,
        и props которые нам не передают, значит удаляем их, а нужные currentPage и pageSize помещаем в параметры чтобы при вызове
        ф-ии тот кто вызывает нам их передавал, также установих их значение по умолчанию. А в UsersComponent при вызове ф-ии
        передадим туда параметры коотрые у нас были с this и также заменяем запрос который при изменении страницы происходит,
        только вместо this.props.currentPage берем это значение из параметров ф-ии onPageChange.

            export const getUsers = (currentPage = 1, pageSize = 10) => {
                return axios.get(`https://social-network.samuraijs.com/api/1.0/users?page=${currentPage}&count=${pageSize}`,


                getUsers(this.props.currentPage, this.props.pageSize).then(response => {

            onPageChanged = (pageNumber) => {
                this.props.setCurrentPage(pageNumber);
                this.props.toggleIsFetching(true);
                getUsers(pageNumber, this.props.pageSize).then(response => {


    Работает, но нужно ли компоненту вся та информация коотрая приходит с сервера? Обычно нет, поэтому в api мы из response вытащим
        только объект data который нужен компоненту:

            export const getUsers = (currentPage = 1, pageSize = 10) => {
                return axios.get(`https://social-network.samuraijs.com/api/1.0/users?page=${currentPage}&count=${pageSize}`,
                        { withCredentials: true })
                        .then(response => response.data);
            }

        тоесть мы отдаем не промис response, a промис который уже вытащил из response объект data, можно написать так 

                .then(response => {return  response.data });

    
    //todo почитать про промисы.


    В UsersComponent можно избавиться от response и переименовать его в data чтобы подсказать что мы используем только часто ответа
            
            componentDidMount() {
                this.props.toggleIsFetching(true);
                    getUsers(this.props.currentPage, this.props.pageSize).then(data => {
                        this.props.toggleIsFetching(false);
                        this.props.setUsers(data.items);
                        this.props.setTotalUsersCount(data.totalCount);
                    });
            }

            onPageChanged = (pageNumber) => {
                this.props.setCurrentPage(pageNumber);
                this.props.toggleIsFetching(true);
                getUsers(pageNumber, this.props.pageSize).then(data => {
                        this.props.toggleIsFetching(false);
                        this.props.setUsers(data.items);
                    });
            }


    //todo сделать так - перенести в api запросы follow/unfollow и запрос на авторизацию. При этом начнет дублироваться базовый
    //todo URL вынесем его в отделюную переменную   const baseUrl = 'https://social-network.samuraijs.com/api/1.0/';


    //! Создадим instance чере axios.create() - это будет экземпляр(объект) axios с нужными настройками, такое нужно например чтобы
    //! разные instance работали с разными частями или разными версиями серверов(разными API).


    Сделаем instance аксиоса с нужными настройками, базовый урл перенесем тудаже, при этом нам не нужно будет дописывать в каждую
        ф-ю одинаковые параметры:

            import axios from 'axios';

            const instance = axios.create({
                withCredentials: true,
                baseURL: 'https://social-network.samuraijs.com/api/1.0/',
                headers: {"API-KEY": "some generated key"}
            });

            export const getUsers = (currentPage = 1, pageSize = 10) => {
                return instance.get( `users?page=${currentPage}&count=${pageSize}`)
                        .then(response => response.data);
            }



    Можно сделать не ф-ями а объект, а в нем методы, для каждго ендпоинта свой объект с методами работы с ендпоинтом:
            
            export const usersAPI = {
                getUsers (currentPage = 1, pageSize = 10) {
                    return instance.get(`users?page=${currentPage}&count=${pageSize}`)
                        .then(response => response.data);
                }
            }

        тогда и в UsersContainer нужно изменить:

            import { usersAPI } from '../../api/api'

            class UsersContainer extends React.Component {
                componentDidMount() {
                    this.props.toggleIsFetching(true);
                        usersAPI.getUsers(this.props.currentPage, this.props.pageSize).then(data => {
                            this.props.toggleIsFetching(false);
                            this.props.setUsers(data.items);
                            this.props.setTotalUsersCount(data.totalCount);
                        });
                }

                onPageChanged = (pageNumber) => {
                    this.props.setCurrentPage(pageNumber);
                    this.props.toggleIsFetching(true);
                        usersAPI.getUsers(pageNumber, this.props.pageSize).then(data => {
                            this.props.toggleIsFetching(false);
                            this.props.setUsers(data.items);
                        });
                }


    //! Архитектура этого API зависит от разработчика, можно и ф-ями можно и объектами , можно и классами + наследование сделать.

    //! Перенес Aut и follow/unfollow в api. Работает или нет не понятно, нужно исправить withRouter чтобы spa работало.

*/}


{/*    ====    64.  button disabled(follow unfollow)     ====

    После нажатия кнопки идет запрос на сервер, но если юзер этого не видит (например как у нас при нажатии кнопки follow/unf) то 
        юзер может нажать на кнопку еще несколько раз думая что запрос не отправился, и пока будет идти ответ на первый запрос
        юзер может наклацать еще десяток запросов. Есть области где это очень критично например в банковских операциях. Чтобы
        избежать такого поведения будем прятать кнопку до того момента как получим ответ от сервера, чтобы юзер ее не клацал
        лишние разы, принцип такой же как с крутилкой preloader.


    В users-reducer у нас уже есть свойство isFetching но оно нам не подходит потому что если будем использовать его то будет 
        отображаться большая крутилка, а нам нужно спрятать кнопку. Создадим новое свойство followingInProgress: false. Создадим
        константу и экшн криэйтер для него.

            const TOGGLE_FOLLOWING_IN_PROGRESS = 'TOGGLE_FOLLOWING_IN_PROGRESS';

            case TOGGLE_FOLLOWING_IN_PROGRESS:
                return { ...state, followingInProgress: action.isFetching }

            export const toggleFollowingInProgress = (isFetching) => ({ type: TOGGLE_FOLLOWING_IN_PROGRESS, isFetching  })

        isFetching такое название символизирует процесс ответа сервера, этот isFetching не пересекается с другим АС 



    Через UsersContainer прокинем этот АС сначала испортируем его, потом коннектом прокидываем в UsersContainer классовый коспонент
        коннект для него делает коллбек и помещает в props и через props нужно прокинуть его в Users. Также через mapStateToProps
        прокинем followingInProgress - свойство чтобы скрывать или отображать кнопку в зависимости от его значения.



    В Users используем коллбек toggleFollowingInProgress до отправки запроса сменим на true, a после получения ответа на false.
        toggleFollowingInProgress выносим за условиу if для того чтобы если будет негативный ответ от сервера кнопка показалась.
        disabled={props.followingInProgress} - вешаем на кнопку, если followingInProgress будет truу то кнопка задизейблится.

             {user.followed
                ? <button disabled={props.followingInProgress} onClick={() => { 
                    props.toggleFollowingInProgress(true);
                    usersTracking.unfollow(user.id)
                    .then(data => {
                        if (data.resultCode == 0) {
                            props.unfollow(user.id); 
                        }
                        props.toggleFollowingInProgress(false);
                    });
                }}>Unfollow</button>
                : <button disabled={props.followingInProgress} onClick={() => { 
                    props.toggleFollowingInProgress(true);
                    usersTracking.follow(user.id).then(data => {
                        if (data.resultCode == 0) {
                            props.follow(user.id);
                        }
                        props.toggleFollowingInProgress(true);
                    });
                }}>Follow</button>}

        Работает но //! дизейбляться все кнопки. Автор предложил сделать followingInProgress массивом и получать вместо булевого
        значения массив с id юзеров на кнопку котороых нажали, тогда сопоставив этот id с id на странице задизейбляться только
        кнопкпи id которых совпадает, проверку делает метод some который возвращает false если id нету в массиве. Добавим передачу
        в action id юзера.
        

            в Users 
            <button disabled={props.followingInProgress.some(id => id === user.id )} onClick={() => {

            props.toggleFollowingInProgress(true, user.id );


            в reducer - свойство = массив. В кейсе если action.isFetching - тру тогда надо добавить в копию(деструктуризируем) 
            свойства followingInProgress айдишку юзера action.userId, а если фолс(пришел ответ от сервера) тогда 
            фильтруется этот массив (при этом создается новая копия автоматически, метод filter возвращает) тогда сравниваются
            id который пришел с теми которые есть в массиве != - (не равно) и получается удаляется только тот который в action
            пришел, остальные если есть остаются. 

            followingInProgress: []

            case TOGGLE_FOLLOWING_IN_PROGRESS:
                return { ...state,
                        followingInProgress: action.isFetching ?
                        [...state.followingInProgress, action.userId ] 
                        : state.followingInProgress.filter(id => id != action.userId) 
                }

            export const toggleFollowingInProgress = (isFetching, userId) => ({ type: TOGGLE_FOLLOWING_IN_PROGRESS, isFetching, userId  })


    //todo почитать про методы some every.
    
*/}


{/*    ====    65.  redux-thunk (санки) теория в деталях     ====

    Сейчас у нас UI выступает в роли менеджера. Через DAL он делает запрос на сервер берет оттуда данные и диспатчит их в БЛЛ.


    UI не должен таким заниматься, он должен в БЛЛ только доносить намеренья юзера через диспатч, например вывести список юзеров,
        тогда БЛЛ смотрит что их у него нету и обращается через DAL чтобы не загрязнять себя этой логикой на серврер, берет данные
        сохраняет в state и на основании нового state UI перерисовывается.


    Как сделать чтобы БЛЛ делал запрос. У него есть store и три метода которые нам интересны .getState .subscribe .dispatch.
        UI может общаться с БЛЛ только dispatchem, но при диспатче мы посылаем action(объект с как мининмум типом) и он 
        раскидывается по reduceram. Reducer - это чистая синхронная ф-я которая не делает сайд эффекты  и должна моментально 
        изменить state если  нужно и вернуть его. А запрос на сервер это асинхронная операция поэтому мы не можем сделать такой 
        запрос из редюсера.
    
    
    Поэтому сейчас мы и делаем запросы на сервер из UI. Он состоит из диспатча - покажи крутилку потом делаем запрос, потом при
        ответе диспатч - выключить крутилку, и третий диспатч - например добавить сообщение в state. Эти операции у нас неразрывны,
        мы не можем без диспатча крутилки начать запрос на серврер, получается эти действия объединены в группу. Значит их можно
        обернуть в ф-ю addMessage например. И эта ф-я должна быть помещена в БЛЛ, это и есть thunk, ф-я которая делает асинхронные
        запросы и диспатчи, может и не быть в ней асинхрю запросов или быть только 1 диспатч.


    Так как с БЛЛ UI может общаться только через диспатч то нам нужно такую ф-ю задиспатчить. Но это ф-я, а диспатчим мы только
        объект action который сразу уходит по редюсерам, так не получается потому что наша ф-я должна запуститься перед редюсерами
        и вообще не должна в них попасть. Тоесть нам нужно диспатчить уже ф-ю - thunk предназначенную для чего то другого нежели
        action. Она должна будет просто запуститься.


    Thunk - ф-я которая делае асинхронную задачу и умеет диспатчить обычные action. При диспатче такой ф-и store(redux) поймет что 
        это thunk и не пустит ее в редюсеры , и запустит ее выполнение. Чтобы thunk могла выполнять диспатчи обычных action в нее в
        параметры должа прийти ф-я dispatch - которую закинет сам redux при ее запуске.

            const addPost = (dispatch) => {
                dispatch(onLoading())
                axios.post({message}).then( ()=> {
                    dispatch(addPost(message))
                    dispatch(offLoading())
                }
            }


    Нам еще нужно передать то самое сообщение которое нужно добавить, в параметрах мы этого сделать не можем потому что мы 
        диспатчим только название санки но не вызываем её. Тут нам поможет замыкание, мы создадим другую ф-ю которая будет
        создавать санку и содержать сообщение, потом эта санка будет через замыкание брать это сообщение из родительской ф-ии.
        Ф-ии такие будут на подобие АС(экшн криэйтеров) только thunk creater. Например

            const addPostThunkCreator = (message) => (dispatch) => {
                dispatch(onLoading())
                axios.post({message}).then( ()=> {
                    dispatch(addPost(message))
                    dispatch(offLoading())
                }
            }

        Мы вызываем санк креэйтер помещаем в него сообщание он вернте санку которую и будем диспатчить, и потом когда она будет
        вызвана message она возьмет из замыкания. //! по сути как и с АС мы диспатчим не санку а ВЫЗОВ санк криэетера который 
        //! вернет санку 

    
    //todo прочитать про замыкания


    //! Сам store не умеет работать с санками для этого используется thunk middleware который вклинивается в работу store
    //! и если видит что пришел action он его дальше перенаправляет по обычному пути, а если пришла санка он ее запустит, закинет 
    //! в нее диспатч. После запуска если в санке будет обычный диспатч то thunk middle wear передаст этот диспатч снова в store
    //! для обычной работы, но если внутри этой санки он наткнется на другую санку он снова ее запустит и разберет на составляющие.
    //! После таких циклов редюсеры получат обычные action преобразуют state и будет результат. 

    //! thunk middle wear - нужно встроить в store при его создании(на стадии combine дописать код).

*/}


{/*    ====    66.  redux-thunk (санки) практика в деталях     ====

    Для метода componentDidMount в классе Userscontainer нам нужнен список юзеров для показа, и для этого мы делаем запрос на
        сервер, а потом результат сетаем в state. Вынесем эту логику в users-reducer создав санку getUsersThunk. В ней теперь
        можно диспатчить АС сразу без this и props потому что АС находяться тут же.  usersAPI импортируем.


            export const getUsersThunk = (dispatch) => {
                dispatch( toggleIsFetching(true) );

                usersAPI.getUsers(this.props.currentPage, this.props.pageSize).then(data => {
                    dispatch( toggleIsFetching(false) );
                    dispatch( setUsers(data.items) );
                    dispatch( setTotalUsersCount(data.totalCount) );
                });
            }

        
        Но проблема с this.props.currentPage и this.props.pageSize откуда их взять, теперь делаем внешнюю ф-ю thunk creator для 
        того чтобы санка взяла эти параметры через замыкание. thunk creator может принимать параметры и возвращает санку которая
        может взять параметры из thunk creator которые в нее передадут

            export const getUsersThunkCreator = (currentPage, pageSize) => {
                return (dispatch) => {
                    dispatch(toggleIsFetching(true));
                    usersAPI.getUsers(currentPage, pageSize).then(data => {
                        dispatch(toggleIsFetching(false));
                        dispatch(setUsers(data.items));
                        dispatch(setTotalUsersCount(data.totalCount));
                    });
                }
            }


    Теперь можем задиспатчить этот ТС(thunk creator) из класса UsersContainer, предварительно его импортировав и передав в 
        props через connect коллбек на него:

            componentDidMount() {
                this.props.getUsersThunkCreator(this.props.currentPage, this.props.pageSize);

        //! Коллбек делается автоматически connectom, если писать вручную то будет такой вид

            export default connect(mapStateToProps,
            { follow, unfollow, setUsers, setCurrentPage, setTotalUsersCount, toggleIsFetching, toggleFollowingInProgress, 
            //! getUsers: getUsersThunkCreator })

        и теперь используем этот коллбек

            componentDidMount() {
                this.props.getUsers(this.props.currentPage, this.props.pageSize);
            }



    Появилась ошибка что диспатчить можно только простые объекты, а для async actions нужно использовать custom middleware,
        теперь нам нужно его прикрутить там где создается store в redux-store импортировав из redux. Это редаксовский готовый
        метод который сделали чтобы мы могли вклиниться в обычный поток со своей логикой:

            import {applyMiddleware, createStore, combineReducers} from 'redux';

            let store = createStore(reducers, applyMiddleware());


        //! в applyMiddleware нужно передать конкретную Middleware которую хотим использовать, для этого нужно ее установить:

            npm i redux-thunk

        теперь ее тут же импортируем 

            import thunkMiddleware from 'redux-thunk'; //! в документации import thunk - чтобы не путаться назвали thunkMiddleware

            let store = createStore(reducers, applyMiddleware(thunkMiddleware));



    Заменим туже логику в onPageChanged но передадим другой currentPage в параметры (pageNumber) - тот который запрашиваем:
        //! вроде первой строки в санках нету this.props.setCurrentPage(pageNumber);

            onPageChanged = (pageNumber) => {
                this.props.getUsers(pageNumber, this.props.pageSize);
            

    Удалим ненужные теперь тут АС из коннекта, они стали теперь внутринними для санки, и переименуем getUsersThunkCreator в
        getUsers - и так как они теперь с одинаковыми именами можно оставить в коннекте просто getUsers.

            export default connect(mapStateToProps,
            { follow, unfollow, setCurrentPage, toggleFollowingInProgress, getUsers })
            (UsersContainer);


    //! У автора работает без this.props.setCurrentPage(pageNumber); в onPageChanged страницы меняются но не выделяется цифра
    //! текущей страницы, я у себя эту строчку оставил перед запросом.



    Рефакторим Users переносим логику запросов из него в API. //! не сделал в API преобразование response в data.

    Создаем санку в users-reducer, переименуем follow/unfollow AC в followSuccess/unfollowSuccess чтобы санки навать 
    follow/unfollow 

            export const follow = (userId) => {
                return (dispatch) => {
                    dispatch(toggleFollowingInProgress(true, userId) );
                    usersAPI.follow(userId).then(data => {
                        if (data.resultCode == 0) {
                            dispatch( followSuccess(userId) );
                        }
                        dispatch( toggleFollowingInProgress(true, userId) );
                    });
                }
            }

            export const unfollow = (userId) => {
                return (dispatch) => {
                    dispatch(toggleFollowingInProgress(true, userId) );
                    usersAPI.unfollow(userId).then(data => {
                        if (data.resultCode == 0) {
                            dispatch( unfollowSuccess(userId) );
                        }
                        dispatch( toggleFollowingInProgress(true, userId) );
                    });
                }
            }     


    Зарефакторим Users:

            {user.followed
                ? <button disabled={props.followingInProgress.some(id => id === user.id )}
                    onClick={ () => { props.unfollow( user.id ) }}>Unfollow</button>
                : <button disabled={props.followingInProgress.some(id => id === user.id )} onClick={() => { 
                    props.follow(user.id) } }>Follow</button>}

        Эти санки прокидываются через контейнерный компонент так как у нас раньше прокидывались АС с такими же именами, но
        некоторые лишние уже props нужно удалить:  - toggleFollowingInProgress удаляем, он уже внутренний АС.

*/}


{/*    ====    67.  redux-thunk (санки) практика в деталях 2ч.    ====

    Переводим все остальные запросы на сервер сначала в API потом на санки.



    Начнем с ProfileContainer там идет запрос профиля, назовем его getProfile:
        
        В API

            getProfile(userId) {
                return instance.get(`https://social-network.samuraijs.com/api/1.0/profile/${userId}`);
            }
            
        В ProfileContainer:

             usersAPI.getProfile(userId)
                .then(response => {
                    this.props.setUserProfile(response.data);
                });
    

    
    В HeaderContainer auth уже не совсем про юзеров, поэтому создадим в API другой объект authAPI с методом me() :

            export const authAPI = {
                me() {
                    return instance.get(`auth/me`)
                }
            }        
    

        В HeaderContainer

             componentDidMount() {
                authAPI.me().then(response => {
                    if(!response.data.resultCode === 0) {
                        let { id, login, email} = response.data.data;
                        this.props.setAuthUserData( id, login, email );
                    }
                });
            }



    Создаем санку getUserProfile для ProfileContainer в profile reducer. Импортируем usersAPI.

            export const getUserProfile = (userId) => (dispatch) => {
                usersAPI.getProfile(userId) 
                    .then(response => {
                        dispatch( setUserProfile(response.data) );
                    });
            }


        Используем ее в ProfileContainer - импортируем, вносим в connect и используем доставая из props:

             componentDidMount() {
                let userId = this.props.match.params.userId;
                if (!userId) {
                    userId = 2;
                }
                this.props.getUserProfile(userId);
            }



    Создаем санку getAuthUserData для HeaderContainer в auth reducer. Импортируем authAPI.

            export const getAuthUserData = () => (dispatch) => {
                authAPI.me().then(response => {
                    if(!response.data.resultCode === 0) {
                        let { id, login, email} = response.data.data;
                        dispatch( setAuthUserData( id, login, email ) );
                    }
                });
            }

        
        Используем в HeaderContainer - импортируем, прокидываем в классовый компонент, используем из пропсов через this

            import {getAuthUserData} from '../redux/auth-reducer'

                componentDidMount() {
                    this.props.getAuthUserData();
                }

            export default  connect(mapStateToProps, { getAuthUserData } )(HeaderContainer);

*/}


{/*    ====    68.  Redirect    ====

    Redirect - перенаправление. Одна из задач редиректа - защита данных.
    
    Защитим некоторые страницы нашего приложения от незалогиненых юзеров. При нажатии например на профиль или messages
        будет выполняться проверка авторизирован ли юзер, если нет тогда будет направляться на страницу логинизации.
        Для проверки будет использоваться свойство state в auth - isAuth: false, если оно false тогда будет редирект
        если true тогда покажем страницу на которую кликнули. Для проверки незалогиненого юзера сделаем выход на
        сайте сервера из профиля, тогда это свойство всегда будет false, потому что куки при запросе не будут 
        заполнеными.
        
        Свойство auth по умолчанию false в HeaderContainer в didMount получаем данные о авторизации юзера через 
        getAuthUserData в ней идет запрос на сервер на authApi.me и он сообщает залогинены мы или нет. Если
        залогинены то возвращается resultCode === 0 и мы сетаем id, login, email в state и меняем флаг isAuth на
        true. //! Таким образом в любой момент времени мы знаем залогинены мы или нет. Эти данные из state может
        получить любой контейнерный компонент.

        
    Создадим сначала ее чтобы видеть что нас действительно перебрасывает туда куда нужно. 
    
    В App создадим роут на компонент Login:  <Route path="/login" element={<Login />} />

    Создадим папку Login и jsx файл (пока только с заглушкой текстом):

            import React from "react";

            const Login = (props) => {
                return <h1>LOGIN</h1>
            }

            export default Login;

    Импортируем в App.

    
    Начнем с messages, если не залогинены то перекинет на страницу логина. В DialogsContainer в didMount получим инфу
        про статус юзера.

            let mapStateToProps = (state) => {
                return {
                    dialogsPage: state.dialogsPage,
                    isAuth: state.auth.isAuth
                }
            }

        теперь в props это свойство прийдет в Dialogs, пере returnom делаем условие и если оно истинное(isAuth == false)
        тогда будем делать return другого компонента - Login а перекинет нас на него компонент Redirect из билиотеки

        //! Не идет проверка на авторизацию у меня isAuth не меняется.

        //! Теперь вместо Redirect используется Navigate - import {Navigate} from 'react-router-dom';

             };

            if (props.isAuth == false) return <Navigate to={'/login'} />;

            return (


                
    Сделаем также и для Profile. В ProfileContainer берем значение из state и прокидываем в ProfileContainer через mapSateToProps

            let mapStateToProps = (state) => ({ profile: state.profilePage.userProfile,
                                    isAuth: state.auth.isAuth });

            
        теперь в классовом компоненте ProfileContainer так как он классовы то условие будем делать в render перед обычным return, 
        используем строгое равенство, а если булево значение то его можно не сравнивать с булевым, а просто указать если тру
        (this.props.isAuth) - делаем это, или если false - не тру (!this.props.isAuth) - делаем это.

            render() {

                if(this.props.isAuth === false) return <Navigate to='/login'/>

                return <Profile {...this.props} profile={this.props.profile} />
            }


    Так как у нас будет много компонентов которые мы хотим защитить таким образом то нужно будет в каждую прокидывать значение 
        свойства isAuth через props и вписывать условие с Navigate. Это дублирование кода и лишняя ф-сть презентационных 
        компонентов, можно вынести эту ф-сть в отдельный контейнерный компонент, но там тоже будет дублироваться код, тогда
        можно создать ф-ю коотрая будет заниматься созданием таких контейнерных компонентов. Это тема следующего урока - HOC(High
        Order Component) 



    //! Работает, но не будут показаны страницы для авторизованного юзера

*/}


{/*    ====    69.  HOC(High Order Component)    ====

    HOC(High Order Component) - компонент высшего порядка, это ф-я которая принимает компонент, а возвращает другой 
        компонент(контейнерный). Задача такой ф-ии - создавать однообразные контейнерные компоненты для разных компонентов которые
        мы ей передадим.


    Создадим такой HOC для ProfileContainer. Вынесли редирект Navigate из комопонента ProfileContainer и создали для такого 
        поведения отдельную ф-ю (HOC) AuthRedirectComponent - все props которые прийдут в него он передаст в ProfileContainer
        и вернет его, а если пользователь будет не атворизован то сделает редирект - это контейнерный компонент над контейнерным
        компонентом. Передадим AuthRedirectComponent в WithUrlDataContainerComponent вместо ProfileContainer

            let AuthRedirectComponent = (props) => {
                if(this.props.isAuth === false) return <Navigate to='/login'/>
                return <ProfileContainer {...props} />
            }

            let WithUrlDataContainerComponent = withRouter(AuthRedirectComponent);

            export default connect(mapStateToProps, { getUserProfile })(WithUrlDataContainerComponent);



    Сделаем тоже для DialogsContainer и у нас уже будет дублироваться код, поэтому вынесем этот ф-л в отдельный файл 
        withAuthRedirect.js в папке hoc. В нем создаем ф-ю которая создает класовый компонент(можно ф-й) и в нем делает
        проверку, если проверка не проходит возвращает тот компонент который передали(Component - с большой буквы чтобы
        отрисовать(вернуть) как компонент) с props и возвращаем этот классовый компонент из ф-и.

            import React from 'react';

            export const withAuthRedirect = (Component) => {

                class RedirectComponent extends React.Component {
                    render() {
                        if(this.props.isAuth === false) return <Navigate to='/login'/>
                        return <Component {...props} />
                    }
                }

                return RedirectComponent
            }


    Теперь можно использовать этот hoc в нужный нам комопонентах. Например в ProfileContainer, импортируем withAuthRedirect из
        файла, и замемяем вручную созданное поведение.

            let AuthRedirectComponent = withAuthRedirect(ProfileContainer);


    Аналогично заменяем в DialogsContainer:

            let AuthRedirectComponent = withAuthRedirect(Dialogs);

            const DialogsContainer = connect(mapStateToProps, mapDispatchToProps)(AuthRedirectComponent);


    //! Hoc принято называть с первым словом with(С) так как они дают новые возможности или свойства и теперь компонент будет С ними.

    Работает но все равно в компоненте мы прокидываем через props свойство isAuth каждый раз. Можно его поместить в наш hoc но
        для каждого компонента который мы возвращаем еще нужны другие props которые отличаются. Поэтому сделаем двойной connect
        чтобы на каждом этапе брать необходимые свойства из state. Для второго нового connect сделаем свой mapStateToProps в 
        котором будем брать isAuth, а остальные нужные для конкретного компонента свойства будем брать в старом mapStateToProps.



    Получается мы в AuthRedirectComponent получаем withAuthRedirect(ProfileContainer), потом в эту же переменную передаем через
        connect props для аутентификации юзера взятые из state connect(mapStateToPropsRedirect)(AuthRedirectComponent);
        с переданным компонентом из первой строчки withAuthRedirect(Pr... и потом уже готовый компонент с уже имеющимися props
        передаем в следующий HOC WithUrlDataContainerComponent который потом передасться во второй connect.

           let AuthRedirectComponent = withAuthRedirect(ProfileContainer);

            let mapStateToPropsRedirect = (state) => ({isAuth: state.auth.isAuth });

            AuthRedirectComponent = connect(mapStateToPropsRedirect)(AuthRedirectComponent);


            let mapStateToProps = (state) => ({ profile: state.profilePage.userProfile });
                
            let WithUrlDataContainerComponent = withRouter(AuthRedirectComponent);

            export default connect(mapStateToProps, { getUserProfile })(WithUrlDataContainerComponent);

        //! Получается wrapper hell - ад из оберток, позже автор обещает сделать это лучшим способом.



    Теперь можно этот connect вынести в сам hoc чтобы его не добавлять каждый раз и не знать о нем:

            let mapStateToPropsRedirect = (state) => ({isAuth: state.auth.isAuth });

            export const withAuthRedirect = (Component) => {

                class RedirectComponent extends React.Component {
                    render() {
                        if(this.props.isAuth === false) return <Navigate to='/login'/>
                        return <Component {...props} />
                    }
                }

                let ConnectedAuthRedirectComponent = connect(mapStateToPropsRedirect)(RedirectComponent);

                return ConnectedAuthRedirectComponent
            }



    Применим к DialogsContainer - уберем из props isAuth так как она теперь берется внутри withAuthRedirect и остается только hoc
            
            let AuthRedirectComponent = withAuthRedirect(Dialogs);


    //! По сути при вызове withAuthRedirect получаем 2 контейнерных компонента один в одном - один делает коннект и берет значение
    //! isAuth из state, а второй возвращает классовый(ф-й) комонент или редиректит уже в зависимости от значения isAuth.

    Чтобы запись была не такой замудреной будем использовать ф-ю compose

*/}


{/*    ====    70.  Compose    ====

    Ф-я compose сбивает в кучу все наши обработчики. присутствует в различных библиотеках или фреймворках, в нашем случаем в реакте
        ее нету, а в redux он есть, будем брать отсуда


    compose()() - двойной вызов - сначала вызывается ф-я, а потом вызывается то что вернула ф-я compose еще раз.

        compose()(Dialogs) - закидываем целевой объект который будет изменяться.

        Во вторых скобках будем идти снизу вверх как у нас было раньше

            // let AuthRedirectComponent = withAuthRedirect(Dialogs);
            // const DialogsContainer = connect(mapStateToProps, mapDispatchToProps)(AuthRedirectComponent);
            // export default DialogsContainer;


        //! Пришел Dialogs и он попадал в withAuthRedirect его мы и записываем во вторые скобки. Ф-я composу автоматически возьмет
        Dialogs и закинет в вызов ф-ии withAuthRedirect - атоматически вызовет withAuthRedirect(поставит скобки) и передаст
        Dialogs в него. Потом возьмет рез-т от выполнения этой ф-ии и перекинет в следующую ф-ю connect. Но не в сам connect
        потому что connect(вызывается 2 раза) это не hoc, а ф-я которая возвращает hoc в который нам нужно закинуть наш компонент.
        Поэтому сначала мы эту ф-ю вызываем сами - с помощью замыкания она создает нам специальный hoc с определенными настройками
        и потом вызовется ф-й compose который закинет в нее предыдущий результат. То есть мы сами ставим одни скобки - вызовем
        connect с настройками и он вернет нам hoc и второй раз уже этот hoc запустит compose. И теперь можно не создавать 
        переменную для экспорта, а экспортировать рез-т выполнения compose:

            export default compose(
                connect(mapStateToProps, mapDispatchToProps),
                withAuthRedirect
            )(Dialogs);


    Также зарефакторим ProfileContainer тут конвеер будет уже из 3х уровней:

            export default compose(
                    connect(mapStateToProps, { getUserProfile }),
                    withRouter,
                    withAuthRedirect
                )(ProfileContainer);


    Также зарефакторим UsersContainer:

            export default compose (
                connect(mapStateToProps, { follow, unfollow, setCurrentPage, toggleFollowingInProgress, getUsers }),
                withAuthRedirect
                )(UsersContainer);            



    //! проверить есть ли compose в redux сейчас

    //! У автора при обновлении приложения если он находился на странице профиля редиректит на логин, потом он нажимает на ссылку
    //! профиля и все работает, сказал пофиксим позже, пока закоментировал строчку с редиректом в compose, я думаю это из-за того
    //! что по умолчанию стоит false и сначала отрисовывается с ним а потом происходит запрос на сервер, меняется на true isAuth
    //! снова происходит перерисовка но путь уже логина и назад автоматом не перкидывает

    //todo разобраться с авторизацией
    //todo  1) ф-й компонент вместо withRouter, 2) установить redux-thunk, 3) почитать про promise и замыкание 4) почитать книги
    //todo  Domen Driven Design - Эрик Дж. Эванс, Чистый код - автор хз

*/}


{/*    ====    71.  setState, local state    ====

    Будем делать status юзера. При даблклике активируется строка - в нее вбиваем новый текст, потом будем отводить фокус и она 
        будет сохраняться(без кнопки сохранить).


    Добавим в ProfileInfo тег для отрисовки статуса и закоментируем фоновую картинку, она пока только мешает, это будет умный тег
        поэтому сразу пропишем как компонент:

            return (
                <div>
                <div className={style.formUser}>
                    <img className={style.userAvatar} src={props.profile.photos.large} />
                    <ProfileStatus />
                    <div className={style.userDescription}>Description</div>
                </div>
                </div>
            );


    Создадим компонент ProfileStatus в этой же папке:

            import React from 'react';
            import style from '../Profile.module.css';

            const ProfileStatus = (props) => {

                return (
                    <div>
                        <div>
                            <span>{props.status}</span>
                        </div>
                         <div>
                            <input value={props.status} />
                        </div>
                    </div>
                );
            }

            export default ProfileStatus;

        Для того чтобы был какой то текст захардкодим его в пропсы в ProfileInfo

            <ProfileStatus status={'This is my status'}/>

    
    Видим что одновременно нам показывается и статус и инпут поле с одинаковым текстом. Но идея у нас такая - показывается status
        при дабл клике на него показывается инпут в него вводим новый текст убираем фокус и он сохраняется уже в статус который
        показывается, а инпут пропадает. 

        Перерисовка UI всегда происходит с изменением state, поэтому нам нужно было бы диспатчить текст в state, а потом бы 
        происходила перерисовка из-за измененного state. Можно было бы делать свойство при тру показывался бы режим редактирования
        инпут поле, при фолс показывался бы статус - спан. Нужно было бы добавлять свойство в state добавлять диспатчи и т.д.

        //! Сначала мы изменяли state и перерисовывалось условно всё приложение, потом начали использовать connect и таким образом
        //! перерисовывался только тот компонент state от которого он зависит изменился.

        
    Можно было бы сделать как обычно но это свойство нужно только одному компоненту и его не целесообразно заносить в глобальный
        state, для таких свойств существует локальный state, он работает по тем же правилам что и глобальный, тоесть компонент
        перерисуется только тогда когда измениться что то в локальном state(//!также перерисуются все дочерние компоненты). 
        
        Он не позволяет хранить в себе такие данные с которыми работает только этот компонент и эти данные не для бизнеса, а 
        только UI: например - cкрыто меню или раскрыто, статус в  редактировании или в отображении, hover эффект появился или нет.


    Состояние нашего status будем хранить в локальном state, сначала реализуем как классовый компонент, потом через хуки когда
        их изучим. В ProfileStatus переделываем компонент в классовый. //! Классы в JS нужны чтобы создавать однотипные объекты
        //! когда реакт видит что пытаются отрисовать класовый компонент он в памяти создает объект с коотрым потом взаимодействует
        //! поэтому изначально локальный state был только в классовых компонентах потому что он хранился в этом объекте.

            class ProfileStatus extends React.Component {
                render() {
                    return (
                        <div>
                            <div>
                                <span>{this.props.status}</span>
                            </div>
                            <div>
                                <input value={this.props.status} />
                            </div>
                        </div>
                    );
                }
            }

        state содается как обычное свойство объекта и теперь можно обращаться как this.state.editMode

            state = {
                editMode: false
            }


        Пропишем условие если у нас эдитмод false тогда показываем span< а если true тогда input. Автор сделал через 2 условия
        так ему легче читать по коду:

            render() {
                return (
                    <div>
                        {!this.state.editMode &&
                            <div>
                                <span>{this.props.status}</span>
                            </div>
                        }
                        {this.state.editMode &&
                            <div>
                                <input value={this.props.status} />
                            </div>
                        }
                    </div>
                    
                );
            }

    //! Очень удобно, почему же мы не использовали его для всей информации - потому что если какая то информация нужна была 
    //! двум компонентам то чтобы не дублировать код мы поднимали ее до общего родителя, а потом прокидывали через props
    //! и в итоге получалось что все равно нужно было выносить state почти на самый верхний уровень и мы выбрали redux 
    //! как state manager для удобной работы со state.


    Повесим на span обработчик события чтобы при двойном клике менять editMode. Чтобы не вписывать много кода в обработчик события
        создадим метод(так как класс) для того чтобы изменять state. //! создаем метод как стрелочнаю ф-ю чтобы не потерялся 
        //! контекст при вызове метода и не писать bind  в обработчике события или в конструкторе потому что это лишний код.
        //! при стрелочной ф-и пишем onDoubleClick={}>{this.activateEditMode}, а при обычном методе activateEditMode() {  нужно
        //! добавить bind - onDoubleClick={}>{this.activateEditMode.bind(this)}:

            activateEditMode = () => {
                this.state.editMode = true;
            }


        //! При обычном изменении state руками - реакт не перерисует компонент потому что не умеет следить за этим, для того чтобы
        //! он увидел что произошло изменение в state используется метод setState в который нужно передать объект свойство которого
        //! изменилось.

            activateEditMode = () => {
                this.setState({
                    editMode: true
                }) 
            }

        Теперь реакт автоматически возьмет этот объект и склеит его с тем объектом у которого переназначается это свойство.



    //! Частый вопрос на собеседованиях - два консоль лога до изменения и после изменения - когда делаем дабл клик в консоль 
        //! выводится 2 раза false - так происходит потому что setState - асинхронный, и он закидывается в очередь и будет выполнен
        //! когда выполниться весь код который находиться в этой ф-ии. То есть выполняется 1й консоль лог, потом ставиться в 
        //! очередь setState и выполняется 2й консольлог при этом значение еще false, а потом уже после этой ф-и выполниться 
        //! setState и измениться значение свойства.

             activateEditMode = () => {
                console.log(this.state.editMode);
                this.setState({
                    editMode: true
                });
                console.log(this.state.editMode);
            }



    По аналогии сделаем deactivate ф-ю. //! можно было сделать toggle ф-ю, но автор предпочитает конкретику, хотя если toggle
        //! сильно сокращает код то можно использовать иногда.

            deactivateEditMode = () => {
                this.setState({
                    editMode: false
                })
            }


    Повесим его на input на событие onBlur - оно срабатывает когда элемент в фокусе, а потом фокус с него уходит

            {this.state.editMode &&
                    <div>
                        <input onBlur={this.deactivateEditMode} value={this.props.status} />
                    </div>
            }

        //! добавим чтобы фокус помещался в поле input (каретка помещалась в поле при срабатывании), раньше нужно было играться
        //! с ref. Надо было бы создать ref на input и когда он появиться вызвать нативный HTML метод focus.  Сейчас есть более
        //! простой метод autoFocus={true}

            {this.state.editMode &&
                    <div>
                        <input autoFocus={true} onBlur={this.deactivateEditMode} value={this.props.status} />
                    </div>
            }



    В следующем уроке будем отображать реальный статус юзера из запроса на сервер.

*/}


{/*    ====    72.  обновляем create-react-app    ====

    Автор столкнулся с проблемой. Если писать методы для объекта по стандарту activateEditMode() {  то нужно при отдаче этого
        метода его байндить с this  - this.activateEditMode.bind(this) создавая при этом копию метода и связывая ее с объектом 
        чтобы когда будут вызывать эту копию this для нее был изначальный объект, если так не сделать то при вызове метода кем-то
        другим он будет вызван со своим this в котором нету того что нужно для выполнения метода. При таком способе удобно дебажить
        код потому что this при дебагинге показывается как нужно.
    
    Но есть способ создания метода со стрелочной ф-й activateEditMode = ()=> { при таком способе не нужно делать bind и 
        соответственно получается меньше кода и не допускаешь ошибок из-за того что забыл сделать байнд. Но при дебагинге 
        this - undefined поэтому это делает работу с ним неудобной.


    Еще автора напрягает то что если ты не пишешь debugger в коде а хочешь из браузера сделать точку останова - можно найти файл
        в котором ты это хочешь сделать но их оказывается 2. 1й твой файл, 2й тот в который компилируется файл для работы с 
        браузером(компилируется в нативный JS). И если поставить точку останова в одном то код остановиться, а если в другом то нет
        и каждый раз играть в рулетку 50/50 не очень приятно, потому что сразу не понятно в каком файле нужно работать.


    Для решения этих проблем автор решил обновить react до последней версии так как в ней  вроде как все нормально уже с этими 
        проблемами. Но есть один нюанс - обычно при обновлении библиотеки или фреймворки имеют обратную совместимость, тоесть
        код который написан раньше будет работать. Но есть и случаи как с реактом когда на некоторое время оставляют устаревшие
        вещи, но предупреждают что нужно использовать уже новый синтаксис потому что этот скоро будет удален и приходится 
        переписывать код для миграции на новую версию потому что приложение перестанет работать.


    
    Вбиваем в поиск create-react-app update to new version - переходим по ссылке - update to new releases и читаем что нужно 
        сделать для установки новой версии. Сначала пишут открыть change log и прочитать что в каких версиях добавилось или 
        удалилось, найти версию на которой проект сейчас(можно посмотреть в package.json) и следовать инструкциям по обновлению.

        Пишут что обычно хватает бампнуть react-scripts версию в package.json и запустить npm install в папке проекта будет 
        достаточно, но лучше просмотреть changelog на изменения которые потенциально могут сломать наше приложение.


    Автор прописал установку с save из инструкции установилась новая версия реакт скриптов 3.0.1 и установилась новая версия
        реакта 16.8 но если смотреть в yarn.lock(потому что автор пользовался установщиком yarn) то версия реакта для проекта
        осталась старой 16.6.3. При старте проекта не смогло скомпилироваться.

        для решения проблемы автор удалил папку node_modules потому что имея dependencies в файле package.json можно просто
        прописать npm install(если npm или yarn ) и все нужные модули сами установяться заново. Установилось и стартануло без
        проблем. 


    Проблема с двумя файлами пропала, теперь только 1 файл если в консоли открыть вкладку sources и ctrl+P - искать файл по имени.

    Проблема с this осталась он до сих пор показывается как undefined.

    Версия реакта не обновилась. Автор пробует удалить package lock и хочет заново переустановить чтобы обновился и реакт.
        npm install - установилось в package.json версия 16.6.3 , а в package-lock 16.8...
    
    Проблема с this осталась.

    

    Автор сделал новый проект create-react-app в него закинул ProfileStatus подрубил к App. Всё это дело запускал в VS code вместо
        вебшторма. Снова появились 2 файла 1й по пути - d, 2й по пути static... но теперь this работает корректно, хоть он и 
        передал в props не объект {'Hello'} а просто строку - status='hello'


    Нашел что в старом проекте babel 7.4.3 вместо 7.4.4 - не обновился. Снова удаляет node_modules и package lock и в package.json
        руками вставляет три строчки реакта из dependencies react, react-dom, react-scripts из нового проекта который создавался. 
    
        Идея такая что когда мы дебажим файл с jsx разметкой в браузере то браузер не понимает что там написано и для него все 
        равно идет преобразование через babel поэтому this который в коде файла не тот который понастоящему приходит в браузер, 
        или мы просто не видим его. Потому что если в консоли впечатать _this то будет видно настоящий this.

        Установил но версия babel не изменилась и все осталось как есть. А на новом проект пропал второй файл , так что там вообще
        всё отлично.



     Автор решил обновить все зависимости и redux и остальное, но чтобы обновить нужно обновить npm. Нашел что npm может автоматом
        обновить все их сразу если глобально поставить npm-chak-updates независимо от того какие версии где прописаны, обновит
        на пофиг.
        
        Для этого установит сначала эту ф-ю 

            npm install -g npm-check-updates

        Установилось, теперь вбил команду npm-check-updates - оно нашло новые версии и показало их и написало что можно вводить 
        короткий синтаксис ncu. И теперь говорит что если хотите обновить до таких версий то впишите ncu ~u . Babel в списке
        для апдейта нету, так что это не помогло бы( в списке axios, react-redux, react-router-dom) 

        Но автор этого не увидел, снова начал делать npm install и сообтветственно у него версии остались старыми, и babel тоже 
        остался старым.

        
    В новом установленном проекте он удалил nod modules и сделал npm install, поставился старый babel но в консоли this работает,
        значит дело не в нем и значит при npx create установка отличается от npm install.

    
    Перенес проект в новый проект и подправилс dependencies в новом чтобы установились зависимости, а в старом сделал yarn install
        перед этим он удалял yarn lock в обоих проектах всё заработало, как не понятно)).
   
*/}


{/*    ====    73.  http put, local state    ====

    Завершим работу со status. Будем подгружать настоящий status и обновлять его.


    Для подгрузки статуса сделаем API в DAL уровне. В API разделим юзер API и Profile. Вынесем getProfile в новый объект. Но 
        старый у нас уже используется в коде, и чтобы не изменять это использование во всех местах сейчас, создадим в console
        предупреждение - используется старый метод и сделает из старого метода вызов нового. В profileApi добавим tit методов
        getStatus (//! чтобы послать запрос смотрим в документацию сервера там идет - get uri запрос profile profile/status/{userID}
        //! uri запрос отличается от query тем что его параметр {userID} когда вбиваем в поле браузера не отличить от url адреса
        //! и нельзя проскочить параметры(они должны идти строго последовательно), а для query запрос передаем параметры через
        //! вопросительный знак и их можно передавать в любой последовательности и в строке браузера видно что url - это всё что до
        //! вопросительного знака ).  

        //! Для updateStatus нужно использовать PUT запрос, при этом с запросом мы должны передать тело запроса body. Смотрим в
        //! документации требуется body с media type - application/json и type - object, и необходимым свойством (в нашем случае
        //! status (string maxLength 300) ). Тело запроса передается вторым параметром после url, при этом юзер айди передавать
        //! не нужно потому что мы можем обновить только свой статус, а сервер по куки и так знает кто мы.

            getProfile(userId) {
                    console.log('U use old method. Please use profileApi object.')
                    return profileAPI.getProfile(userId);
                }
            }

            export const profileAPI = {
                getProfile(userId) {
                    return instance.get(`profile/`+ userId);
                },
                getStatus(userId) {
                    return instance.get(`profile/status/`+ userId);
                },
                updateStatus(status) {
                    return instance.put(`profile/status/`, {status: status});
                }
            }

        Теперь можно использовать нашу API


    //! Get и delete запросы отправляют только url + параметры, потому что нужно только взять бъект с id или удалить объект с id
    //! на серваке. POST и PUT вторым параметром, кроме url отправляют объект(смотреть в документации на сервак какой объект
    //! нужен) с нужными свойствами.



    В ProfileContainer сделаем запрос и для status юзера(нужно прописать в reducere метод) и потом раскидаем через props в нужные
        компоненты.

            componentDidMount() {
                let userId = this.props.match.params.userId;
                if (!userId) {
                    userId = 2;
                }
                this.props.getUserProfile(userId);
                this.props.getUserStatus(userId); 
            }

            let mapStateToProps = (state) => ({ profile: state.profilePage.userProfile,
                                    status: state.profilePage.status });
        


    В profile-reducer сделает этот action, case , action creater, свойсво в state и так как у нас ajax запрос за получением статуса
        должна быть санка (в этом значении приходит просто строка - это плохая практика лучше чтобы приходил json объект с value),
        также сделаем сразу и для updateStatus(при ответе с сервера проверяем resultCode. если всё ок тогда сетаем этот status себе
        в state чтобы произошла перерисовка) :

            import { usersAPI, profileAPI } from "../../api/api";

            const SET_STATUS = 'SET_STATUS';

                userProfile: null,
                status: ''
            }

            case SET_STATUS:
                return { ...state, status: action.status };

            export const setStatus = (status) => {
                return { type: SET_STATUS, status }
            }

            export const updateUserStatus = (status) => (dispatch) => {
                profileAPI.updateStatus(status) 
                    .then(response => {
                        if(response.data.resultCode === 0 )
                        dispatch( setStatus(status) );
                    });
            }



    В ProfileContainer прокидываем через connect и дальше в компонент props

            render() {
                return <Profile {...this.props} profile={this.props.profile} 
                                                status={this.props.status} 
                                                updateUserStatus={this.props.updateUserStatus}/>
                }
            }

            export default compose(
                    connect(mapStateToProps, { getUserProfile, getUserStatus, updateUserStatus }),


    В profile прокидываем дальше 
            
            const Profile = (props) => {
                return(
                    <main>
                        <ProfileInfo profile={props.profile} status={props.status} updateStatus={props.updateStatus}/>



    В ProfileStatus в deactivateEditMode - после окончания редактирования нужно отправить запрос на сервер для обновления.
        Предварительно прокинем в него updateStatus={props.updateStatus} и теперь нужно гдето взять введенный статус. Можно
        повесить ref на инпут но он не сработает потому что у нас value зафиксированно от props из глобального state? а они еще не
        обновятся, поэтому нужно использовать локальный state. //! если value зафиксирован нужно использовать onChange чтобы
        //! видеть то что мы печатаем в input (чтобы происходила перерисовка инпута)

        //! То есть принцып такой создаем в локальном state свойство status - оно береться из глобального state и при первом
        //! запуске(и когда инпут неактивен) ставим тоже из глобального, сохраняется напечатанный текст пока печатаем в локальном 
        //! state текущий status и при окончании редактирования этот локальный status пойдет на сервер, там изменится, вернеться 
        //! в глоб. state там перезапишеться и тогда уже будем перерисовывать от глобального state.

        //! Но если например слишком длинный статус мы впечатали он сохранился в локальном state послался на сервер, а там его не
        //! пропустили то мы увидим снова глобальный (старый/до редактирования) статус, но если сделаем дабл клик то зайдем в
        //! инпут и там будет отображаться статус из локального state который не применился и можно его подредактировать чтобы 
        //! заново не перепечатывать. То есть у нас локальный state не синхронизирован с глобальным это как баг так и фича,
        //! получается так из-за того что классовый компонент и при перерисовке компонента объект с данными сохраняется.

            state = {
                editMode: false,
                status: this.props.status
            }

            activateEditMode = () => {
                this.setState({
                    editMode: true
                }); 
            }
            
            deactivateEditMode = () => {
                this.setState({
                    editMode: false
                });
                this.props.updateStatus(this.state.status);
            }

            onStatusChange= (e) => {
                this.setState({
                    status: e.currentTarget.value
                })
            
            }

            render() {
                return (
                    <div>
                        {!this.state.editMode &&
                            <div>
                                <span onDoubleClick={this.activateEditMode}>{this.props.status}</span>
                            </div>
                        }
                        {this.state.editMode &&
                            <div>
                                <input autoFocus={true} onChange={this.onStatusChange} 
                                        onBlur={this.deactivateEditMode} value={this.state.status} />
                            </div>
                        }
                    </div>
                    
                );
            }



    //! Вылез баг, у нас в глоб state - status - пустая строка, и когда первый раз инициализируется то нету статуса и даже не на
        что кликнуть чтобы задать новый статус, поэтому нужно в спан добавить - показывать дефисы ----- если нету статуса

             <div>
                {!this.state.editMode &&
                    <div>
                        <span onDoubleClick={this.activateEditMode}>{this.props.status || "----------"}</span>
                    </div>
                }
    
    //! Так получается потому что при отрисовке компонента статуса у нас в глобальном state по умолчанию пустая строка, и она же
    //! создается в локальном state. Потом идет запрос на сервер и получаем в глобальный state статус юзера, но так как у нас
    //! не синхронизированы state(я так думаю, так и не понял логику автора) поэтому не происходит перерисовка компонента и
    //! в локальном статусе у нас пустая строка лежит при том что в глобальном уже есть статус. Для того чтобы воспользоваться
    //! статусом из глобального state есть метод жизненного цикла рассмотрим в следующем уроке

*/}


{/*    ====    74.  componentDidUpdate    ====

    Баг при попадании на страницу профиля - статус сначала показывается стандартный - заглушка (может быть и не он а статус юзера)
        потом при дабл клике в инпуте пусто, вводим - показывается статус введеный, обновляем страницу заходим снова дабл кликом и
        через раз может оставаться то что мы ввели прошлый раз, а может не оставаться - быть пустое поле, то есть статус из глобального 
        state в локальный приходит пустой.

        Так получается потому что у нас происходит два запроса в ProfileContainer - getUserProfile и getUserStatus и они так как это
        асинхронные запросы получают ответ по разному, один раз профиль прийдет быстрее тогда отрисуется профиль без статуса(статус
        приходит в глобальный state позже но не обновит страницу и не занесет данные в локальный state который мы и видим в инпуте),
        а в следующий раз статус отработает раньше, занесет свои значения в глоб. state и передаст в локальный, а потом получим
        профиль и он отрисуется уже с данными статуса.


    В комментариях предлагали брать статус из профиля потому что он там уже будет, но автор хочет нам показать как работать с 
        методами жизненного цикла  чтобы решать такие ситуации. Хотел сначала использовать метод getDerivedStateFromState - но 
        потом почитав про него (пишут что его лучше не использовать и даже там где он вроде необходим можно обойтись другими
        способами). Будем использовать другой метод жизненного цикла - ComponentDidUpdate.

        Вспомним в двух словах жизненный цикл - создаем классовый компонент экстендив его из реактовского компонента, потом когда
        реакт попадает в компонент он создает на основе класса объект и взаимодействует с ним. Получает от него jsx разметку,
        превращает в хтмл код, аппендит эти элементы на страницу и потом уведомляет объект методом ComponentDidMount что эта
        разметка добавлена на страницу. Но если находясь на той же странице у компонента меняются props или state то используется
        другой метод ComponentDidUpdate - он не аппендит заново разметку на страницу, а обновляет(апдейтит) ее с новыми данными 
        (получая новый jsx) и уведомляет об этом компонент. И используя этот метод мы можем решить нашу текущую проблему синхронизации
        стейтов.


    В ProfileStatus создадим метод ComponentDidUpdate - он вызывается всякий раз когда обновляется компонент(принудительно извне -
        наверное глобальный state и когда обновляется локальный state). В этот компонент приходят предыдущие пропсы и state и можно
        достучаться до текущих чтобы увидеть что изменилось(почему происходит перерисовка). 

            ComponentDidUpdate(prevProps, prevState) {
                let a = this.state;
                let и = this.props;
                console.log("ComponentDidUpdate")
            }

        В нашем случае при даблклике происходит обновление локального state - заноситься пустая строка,  - вызывается метод render
        перерисовывает компонент и сообщает в  компонент что он обновился.


    Этот метод будет вызываться каждый раз когда status не успевает первым обновиться. То есть сначала загрузился профиль и отрисовал
        компонент с пустым статусом, а потом в props прокинулся новый status, при этом компонент не перерисовывался, и в этом случае
        можно из сработавшего метода ComponentDidUpdate сделать синхронизацию state. Мы можем прописать в нем setState() и присвоить
        локальному state новое свойство status. //! но если сделать это просто то рендер зациклиться потому что мы будем попадать
        //! каждый раз в ComponentDidUpdate и каждый раз будет запускаться setState и снова будет перерисовка. Поэтому нужно
        //! условие, что если prevStatus не равен тому который пришел в props тогда присвоить свойству status локального state
        //! значение из props и на следующий раз они будут равны и setState не сработает. В ComponentDidUpdate всегда приходят
        //! prevProps, prevState которые можно сравнить с текущими и увидеть из-за чего произошло обновление.

            componentDidUpdate(prevProps, prevState) {
                if (prevProps.status !== this.props.status){
                    this.setState({
                        status: this.props.status
                    });
                }
            }


    Теперь мы всегда будем видеть status. Но если перейти на какого то пользователя - видим его статус, попробуем средактировать,
        статус обновиться, но на самом деле обновиться наш статус и он будет показываться в чужом профиле пока мы не обновим
        страницу, тогда статус чужого профиля снова станет таким как и должен быть(прийдет из глоб. state) и когда мы перейдем на
        свой профиль то увидим что обновлен наш статус, на тот который мы последний раз писали вроде как на чужом профиле.

*/}


{/*    ====    75.  redux form (React final form) - введение    ====

    Сейчас для того чтобы происходило обновление инпут поля(ввод поста, статуса, ...) нам нужно создавать свойства в локальном или
        глобальном state которые будут обновляться когда в них диспатчаться новые данные и из-за этого будет перерисовываться поле. 
        Нужно писать много обслуживающего кода для одного поля. А если в форме будет много полей это очень осложнит и замедлит 
        разработку. Плюс все эти данные мы создаем в бизнес слое которому по сути не нужны эти данные, они временные данные - не
        факт что логин который написал юзер после отправки будет его логином, потому что он мог написать недопустимое имя или такое
        уже есть в базе, и соответственно для нашего state это лишняя нагрузка.

    
    Для таких случаем используют библиотеку redux form - она позволяеят создавать разные формы, автоматически создавая ветку(редюсер)
        в state и сама делает диспатчи нужных значений свойств, показывает визуальные эффекты(если юзер кликнул на обязательно поле
        и потом убрал фокус но ничего не ввел) - проводит валидацию и другое поведение, например дизейблит кнопку Sign in если 
        не заполнены все нужные поля.

        Примеры форм можно посмотреть на сайте redux-form.com в разделе examples.


    //! Сейчас вместо redux-form используется другая библиотека - React final form - на сайте redux-form на главной странице есть
    //! инструкция по миграции на эту библиотеку, значит нужно дописать этот урок как автор, а потом исправить на новый синтаксис.
    

    Попробуем с помощью redux form сделать форму login. В login.jsx сделаем компонент. //! обязательно добавляем тег <form>

            const Login = (props) => {
                return <div>
                    <h1>Login</h1>
                    <form>
                        <div>
                            <input placeholder={ 'Login' } />
                        </div>
                        <div>
                            <input placeholder={ 'Password' } />
                        </div>
                       <div>
                            <input type={ "checkbox"} /> remember me
                        </div>
                        <div>
                            <button>Log In</button>
                        </div>
                    </form>
                </div>
            }

        //! Сразу можем впечатывать текст потому что поля инпут не контролируемы (не задали фиксированое value и не повесили
        //! обработчик события onChange ) - мы не будем делать это руками, а используем redux form.


        Лучше форму вынести в отдельный компонент, создадим его тут же( Ден Абрамов писал - если вам удобно можно хоть всё 
        приложение писать в одном файле). //! Когда нажимаем на кнопку - страница перегружается - стандартное поведение кнопки
        //! которая находиться в форме - сабмит формы - взять всё содержимое эл-в и отправить на сервер - это устаревшее поведение
        //! когда еще не было AJAX запросов. Это поведение мы изменим. А для сбора информации из эл-в будем использовать redux form.


    
    Устанавливаем библиотеку redux form

            npm install redux-form  - наверное так //! Эта библиотека уже не устанавливается

            npm install --save final-form react-final-form  //! Теперь используется эта библиотека


            
        //! redux form предоставляет нам HOC который вокруг нашего компонента создаст контейнерный компонент - задача которого 
        //! общаться со своей частью которая будет добавлена в reducer. Для этого в redux-store в reducer в метод combine добавим 
        //! специальный reducer. Сделаем его импорт из библиотеки

            import { reducer as formReducer } from 'redux-form'
           
        добавляем в combine - таким образом создаем в state ветку - объект для форм
            

            form: formReducer  //! важно чтобы название свойства было form - что-бы библиотека работала


        //! для подключения нашей формы нужно ее обернуть в HOC - reduxForm который как и connect вызывается дважды. Фактически
        //! reduxForm это не HOC а ф-я которую мы вызываем и настраиваем, и она уже вернет нам HOC который настроен с помощью
        //! замыкания и он уже обернет нашу форму контейнерным компонентом который и будет заниматься dispatch и общением со state
        //! который только что создали.
        


    //! сейчас библиотека не использует redux и reducer отсутсвует в API, соответственно HOC нету, вместо этого используется 
        state через хуки useField(), useForm(), useFormState(). Таким образом нужно переписать и компонент LoginForm в 
        login.jsx



    Создаем LoginReduxForm - контейнерный компонент  который принимает нашу форму и регистрирует ее под названием login в state
        redux, отрисовываем на выходу уже контейнерный компонент:

            import reduxForm from "redux-from";

            const LoginReduxForm = reduxForm ({form: 'login'}) (LoginForm)

            const Login = (props) => {
                return <div>
                    <h1>Login</h1>
                    <LoginReduxForm />
                </div>
            }

        
        Чтобы заработала связь между полями формы и state нужно вместо input использовать спец эл. из библиотеки - field. В нем
        указываем название поля и его тип. В field уже засетаны onChange, филды будут брать неймы и общаться со state чтобы 
        сохранять временные данные. Импортируем Field из библиотеки.

            <div>
                <Field placeholder={'Password'} name={ "password" } component={'input'} />
            </div>
            <div>
                <Field type={"checkbox"} name={ "rememberMe" } component={'input'} /> remember me
            </div>


        Теперь при обычном вводе в поля текста, в консоли можно прописать store.getState().form и мы увидим в нем объект login
        который создавали. В нем много свойств: 
            anyTouch: true - был ли тронут хоть один элемент,
            fields:
                login: {visited: true, touched: true}
                password: {visited: true, touched: true}
                rememberMe: {visited: true, touched: true}
            registeredFields: { login{...}, password{...}, rememberMe{...}}
            values: { login: "sdsf", password: "dfdfss", rememberMe: true }

        В принципе трогать их нам не нужно, напрямую работать с ним мы не будем.



    Сделаем получение данных при нажатии на кнопку сабмита. //! При оборачивании формы контейнерным компонентом, он прокидывает
        //! особый props(коллбек) в нашу форму он называется handleSubmit. Его мы должны повесить на событие формы onSubmit, это
        //! событие есть у любой формы. При этом мы доверяем ему обработку сабмита формы: 1) e.preventDefault, 2) сбор данных 
        формы и упаковка в объект, 3) конт. компонент вызывает props.onSumit(formData) и передает в него объект с данными условно
        formData.

            const LoginForm = (props) => {
                return (
                    <form onSubmit={props.handleSubmit}>
                        <div>


        Этот handleSubmit наша форма получает от контейнорного компонента, но в него тоже нужно передать этот метод onSubmit
        по props чтобы он работал.
                
            const Login = (props) => {
                const onSubmit = (formData) => {
                    console.log(formData);
                }

                return <div>
                    <h1>Login</h1>
                    <LoginReduxForm onSubmit={onSubmit} />
                </div>
            }

        теперь при нажании на кнопку страница не будет перегружаться(внутри handleSubmit написан - e.preventDefault - отмена 
        действия по умолчанию) и все собранные данные отправяться в консоль, далее будем их использовать.


        //! То есть наша форма LoginForm - вызвала handleSubmit который прокидывает контейнерный компонент LoginReduxForm который
        //! образуется с помощью HOC - reduxForm. Внутри handleSubmit вызоветься то что пришло в LoginReduxForm по props - 
        //! onSubmit={onSubmit} - при отрисовке передаем свой метод onSubmit и в него уже прийдут данные собранные контейнерным комп-м.




    //!  удалить import в reducere - сделать через хуки компонент, удалить HOC.
    //! из-за авторизации не пускает дальше, не проходит проверка на авторизацию, похоже не изменяется state проверить auth-reducer.
    //! Даже если вручную установить isAuth - true в login всё равно приходит null хоть и меняется в хедере Login на пустой эл.
    //! в котором должен быть логин юзера. Посмотреть порядок внесения в state - id login email
    //todo  1) ф-й компонент вместо withRouter, 2) почитать про promise и замыкание 

    // Подставил в Login тестовую форму, переделал нашу стандартную форму согласно ей. Заработало. 
    //! не работает Логинизация! Посмотреть есть ли в консоли данные из формы

*/}


{/*    ====    76.  redux form (React final form) - про базовые вещи    ====

    Сделаем таким же образом с формами в Profile(отправка поста) и в Messages(Dialogs)(отправка сообщения).


    Dialogs. Выносим поле с кнопкой в отдельный компонент в этом же файле. Оборачиваем в Form. Создаем саму форму form
        к ней добавляем <form onSubmit={handleSubmit}> - обработчик событий который прописан в Form - из него берется.
        Из кнопки удалим обработчик события при клике. (Для старой версии еще оборачивют ХОКом и уже его отрисовывают).
        Еще нужно создать функцию которая будет получать данные из формы и запускаться для отправки этих данных в state,
        ее будем прокидывать через props для отрисовываемого компонента(в Login она называлась onSubmit)

            const addNewMsg = (values) => {
                alert(values.newMsgBody);  - указываем name филда значение которого выводим
            }


            const AddMsgForm = (props) => {
                return (
                    <Form
                    onSubmit={onSubmit}
                    render={({ handleSubmit, form, submitting, pristine, values }) => (
                        <form onSubmit={handleSubmit}>
                        <div>
                            <Field placeholder='Type Msg' name="newMsgBody" component='textarea' />
                        </div>
                        <div>
                        <div><button>Send</button></div>
                        </div>
                        </form>
                    )}
                    />
                )
            }


            ...
            <AddMsgForm onSubmit={addNewMsg}/> - отрисовываемый компонент в компоненте Dialogs
            ...


    Должно работать(показывать в алерте напечатанное сообщение). Теперь нужно это значение отправить в бизнес.
    
    
    //! Раньше мы в бизнес мы не отправляли значение, мы в бизнес при клике диспатчили action - props.sendMsg();
            let onSendMsgClick = () => {
                props.sendMsg();
            };

    //! а бизнес это новое сообщение брал из state. Так было возможно потому что в state у нас хранились временные значения для
    //! сообщения. Достаточно было обратиться к state(в dialogs-reducer видно что есть редюсер SEND_MSG в котором новое
    //! сообщение доставали из state.newMsgBody) чтобы добавить новое сообщение в массив сообщений. Теперь этого state.newMsgBody
    у нас не будет. 
    Тоесть раньше мы вызывали коллбек sendMsg()(который пришел из DialogsContainer) - в котором диспатчили action
    который получали с помощью вызова action криэйтера sendMsgCreator и нам не нужно было диспатчить сам текст сообщения потому что
    он уже был в стейте. Теперь его там не будет, и взять из хранилища form в redux даже в старой версии библиотеки нам запрещает 
    автор, потому что лучше в этот state не лезть.


    //! Есть библиотека Formik которая тоже используется для работы с формами но не использует редакс для хранения своих временных 
    данных, а использует локал state.
    

    Теперь модернизируем addNewMsg, так чтобы получаемое значение(текст сообщения) передавать в sendMsg. Раньше он не принимал
        никаких параметров, теперь будет принимать.

            const addNewMsg = (values) => {
                //alert(values.newMsgBody);
                props.sendMsg(values.newMsgBody);
            }

        для этого в dialogsContainer в sendMsg добавим параметр newMsgBody и его же передадим дальше в action creator sendMsgCreator

            let mapDispatchToProps = (dispatch) => {
                return {
                    updateNewMsgBody: (msgBody) => { dispatch(updateNewMsgBodyCreator(msgBody)); },
                    sendMsg: (newMsgBody) => { dispatch(sendMsgCreator(newMsgBody)); }
                }
            }


        добавим параметры и в dialogsReducer в принимаемые и в передаваемые, также newMsgBody мы теперь будем брать не из state
        а из экшена. И уберем старое место хранения в let InitialState и строчку в SEND_MSG где затирали это старое место хранения.

            case SEND_MSG:
                        let msg =  action.newMsgBody;
                        return {
                            ...state,
                            messagesData:  [...state.messagesData, { id: 6, msg} ] 
                        };

                    default:
                        return state;
            }

            export const sendMsgCreator = (newMsgBody) => ({ type: SEND_MSG, newMsgBody })


        Должно работать хоть и поле после клика на кнопку не очищается, нужно будет позже работать с механизмами React final form. 


        Теперь нам не нужен в dialogs-reducerу action - updateNewMsgBodyCreator(который раньше обновлялиз state отображение вводимых
        символов) и константа для него, как и case для него в switch.

        В dialogsContainer updateNewMsgBody тоже теперь не нужен.

        В Dialogs нам не нужен обработчик события onNewMsgChange и onSendMsgClick который мы заменили на addNewMsg.



    Сделаем тоже самое с Posts в Profile.

            import { Form, Field } from 'react-final-form'

            const onAddPost = (values) => {
                props.addPost(values.newPostText);
            }

            const AddNewPostForm = (props) => {
                return (
                    <Form
                    onSubmit={onSubmit}
                    render={({ handleSubmit, form, submitting, pristine, values }) => (
                        <form onSubmit={handleSubmit}>
                        <div>
                            <Field placeholder='Type Msg' name="newPostText" component='textarea' />
                        </div>
                        <div>
                        <div><button>Add Post</button></div>
                        </div>
                        </form>
                    )}
                    />
                )
            }

            const MyPosts = (props) => {
                let postsElements = 
                    props.postsData.map((el, ind) => <Post  msg={el.post} likesCount={el.likesCount} key={ind} />);

                return (
                <div className={style.form__newPost}>
                    <div className={style.newPost__title}>New Post
                        <AddNewPostForm onSubmit={onAddPost}/>
                    </div>
                    {postsElements}
                </div>
                );
            }


        В MyPostContainer добавляем отправленное значение для его диспатча, и убираем апдейт.

            let mapDispatchToProps = (dispatch) => {
                return {
                    addPost: (newPostText) => { dispatch(addPostActionCreator(newPostText)) }
                }
            }


        В profile-reducer удаляем всё что связано с апдейтом поста, добавляем newPostText в action creator

            export const addPostActionCreator = (newPostText) => ({ type: ADD_POST, newPostText })



            
    //! Проверить работоспособность. добавил скобки в profile-reducer, может заработает показ залогинен или нет

            export const updateUserStatus = (status) => (dispatch) => {
                profileAPI.updateStatus(status)
                    .then(response => {
                        if (response.data.resultCode === 0) {
                            dispatch(setStatus(status));
                        }
                    });
            }

    //! По прежнему не отображаются страницы которые делал, только логин(из-за того что думает что не залогинен и
    //! и дальше не пускает).


*/}


{/*    ====    77.  redux form (React final form) - field validation(валидация, ошибки). Осторожно Замыкание!    ====

    //! Доступ к сайту самурай доступен без ВПН  https://social-network.samuraijs.com/api/


    Научимся делать валидацию формы(проверка правильности введенных данных). 

    Смотрим на сайте redux-form в разделе field-level validation - означает что валидация будет привязана к конкретному input и 
        подсветка неправильного ввода будет тоже завязана на конкретном input(есть еще отдельная подсветка валидации на всю
        форму). 

    На сайте видно что валидатор это ф-я которая выполняет проверку. Создадим валидаторы для наших форм, создадим их в отдельной
        папке utils\validators в файле validators.js потому что они могут быть общими для input или похожими и мы будем их 
        переиспользовать.



    Создаем валидатор для обязательно заполненого поля. Это ф-я которая получает значение(из поля) если значение есть - 
        возвращает undefined, если значения нет - сообщение что поле обязательное.

            export const required = value => {
                if (value) return undefined;

                return "Field is required";
            }

        теперь прикрутим этот валидатор к форме в MyPosts для этого в Field нужно в параметре validate передать массивом все 
        валидаторы которые использутся для поля. В нашем случае его нужно проимпортировать.
        
            import { required } from "../../../utils/validators/validators";

            const AddNewPostForm = (props) => {
                return (
                    <Form
                    onSubmit={onSubmit}
                    render={({ handleSubmit, form, submitting, pristine, values }) => (
                        <form onSubmit={handleSubmit}>
                        <div>
                            <Field name="newPostText" placeholder='Type Msg'  component='textarea' validate={required} />


    Создадим валидатор для проверки максимального количества символов в инпуте(проверку есть ли вообще значение мы пока опустим)

            export const maxLength30 = value => {
                if (value.length > 30) return "Max length is 30 symbols";
                return undefined;
            }           

        а если нам нужно будет изменить количество символов для нескольких полей и назначить каждому свое количество, для этого
        нужно передавать в ф-ю число строк.
        //! по старому образцу, так как нужно передать дополнительное значение  нужно создать по аналогии с санкКриэйтер(ф-ю 
        //! которая возвращает санку и в нее передает данные, так как санка фиксированная и ей нужны данные извне) для создания 
        //! санки, валидатор фиксированный, мы не можем передать maxValue вместе с value потому что ф-ю будем вызывать не мы а  
        //! redux-form (как и санку которую вызывает store когда мы ее диспатчим и он передает в нее метод диспатч). 
        
        //! Поэтому создадим maxLengthCreator ф-ю которая возвращает другую ф-ю maxLength (по аналогии с санкой и санк криэйтером
        //! у нас получился maxLengthCreator который принимает параметры(maxLength - макс. длинна) возвращает ф-ю валидатор в 
        //! которой мы будем использовать maxLength)

            export const maxLengthCreator =(maxLength) => value => {
                if (value.length > maxLength) return `Max length is ${maxLength} symbols`;
                return undefined;
            }

        //! Теперь чтобы получить валидатор для поля необходимой длинны мы(redux-form) должны вызвыть maxLengthCreator передав в
        //! него нужную длинну и нам вернеться валидатор с уникальным значением для этого поля. 



        В MyPosts 

            import { required, maxLengthCreator } from "../../../utils/validators/validators";

            const maxLength10 = maxLengthCreator(10);

            const AddNewPostForm = (props) => {
            return (
                <Form
                onSubmit={onSubmit}
                render={({ handleSubmit, form, submitting, pristine, values }) => (
                    <form onSubmit={handleSubmit}>
                    <div>
                        <Field name="newPostText" placeholder='Type Msg'  component='textarea' 
                        validate={[required, maxLength10]} />

        //! Чтобы избежать ошибки макс количества вложенности (когда ф-я вызывается слишком много раз) выносим создание 
        //! maxLengthCreator в отдельную переменную которую уже и вставляем в validate. Если вставить сразу maxLengthCreator(10)
        //! в validate то при каждой отрисовке поля будет посылаться значение в maxLengthCreator а он будет возвращать новую
        //! ф-ю и полю нужно будет снова перерисовываться, так получается зацикливание.

        Теперь при попытке добавить пустой пост или пост с больше чем 10 символом срабатывает валидатор и мы даже не попадаем в 
        onAddPost и соответственно не добавляется пост. 



    //! В новой редакции final-form в примере валидатор размещен прямо в файле с ф-ями и теперь если нужно больше чем 1 валидатор
    //! для поля делают composeValodators, а не массив и получиться что ошибка как выше не возникает.

        const required => value => (value ? undefined : "Required")

        const minValue => min => value => 
                isNaN(value) || value >= min ? undefined : `Should be greater than ${min}`

        const composeValidators = (...validators) => value =>
                validators.reduce((error, validator) => error || validator(value), undefined)
                

            <Field validate={composeValidators( required, minValue(18) )}

    //todo Проверить работоспособность как есть, или переделать по новому.



    Срабатывает валидатор, но никакого сообщения или подсветки нету и юзеру не очевидно что есть ошибка. Чтобы красиво сделать input 
        его нужно обернуть div(дополнительными обертками), чтобы было всплывающее сообщение нужно рядом с input сделать скрытый
        span со специфическими классами, на который будет навешиваться сообщение, и т.д.

        У нас также, на нужен не обычный component='textarea', а какой то навороченный textarea, значит нужно её создать.


        В common\FormControls созадим файл FormControls.js и в нем создадим комопнент Textarea который подставим в MyPosts вместо
        стандартного textarea уже не в кавычках, а в фигурных скобках потому что это компонент. Так как теперь redux-form будет
        общаться не со стандартной textarea а с компонентом то нам нужно вместо обычных props, преобразовать их в тот тип который
        будет воспринят внутренней textarea. В props приходят объекты input, meta и наши кастомные значения типа placeholder 
        которые лежат как отдельные свойства. 

        Чтобы преобразовать в нужный для textarea тип мы отдельно примем на входе input, meta и props, таким образом мы можем при 
        передаче в textarea деструктуризировать отдельно  {...input} (мета не нужен элементу) и отдельно раскрыть наши кастомные
        {...props}.


            import React from "react";

            export const Textarea = ({input, meta, ...props}) => {
                return (
                    <div>
                        <textarea {...input} {...props} />
                    </div>
                )
            }



        В MyPosts

            import { Textarea } from "../../common/FormControls/FormControls";

             <Field name="newPostText" placeholder='Type Msg'  component={Textarea} validate={[required, maxLength10]} />



    Теперь можно к компоненту Textarea привязать ксс для этого в этой же папке создаем ксс файл FormControls.module.css с 
        классами которые будем цеплять к Textarea.

            .formControl .error input,
            .formControl .error textarea {
                border: 2px solid red;
            }

            .formControl .error span {
                color: red;
            }


        для проверки прицепим к Textarea

            import React from "react";
            import styles from "./FormControls.module.css"

            export const Textarea = ({ input, meta, ...props }) => {
                return (
                    <div className={styles.formControl + " " + styles.error}>
                        <div>
                            <textarea {...input} {...props} />
                        </div>
                        <span>"Some Error"</span>
                    </div>
                )
            }

        Понятно что эти классы должны появляться когда будет ошибка.



    Как мы узнаем что у нас ошибка. Так как всем круговоротом управляет redux-form, то при навешенных на field валидаторых redux-form
        будет сообщать в Textarea что произошла ошибка и мы об этом можем узнать внутри нашей формы - в meta приходит touched, error,
        warning. Теперь можно модернизировать компонент чтобы он показывал классы с ошибкой только если пользователь был в поле(touched)
        и если есть ошибка. Если без touched тогда сразу при загрузке будет показываться ошибка ведь поле пустое.

        Для динамического показа сообщений вытащим сообщение из meta.error и подставим в span 
         
            export const Textarea = ({ input, meta, ...props }) => {
                const hasError = meta.touched && meta.error;
                return (
                    <div className={styles.formControl + " " + (hasError ? styles.error : "")}>
                        <div>
                            <textarea {...input} {...props} />
                        </div>
                        { hasError && <span>{meta.error}</span> }
                    </div>
                )
            }



    
    Теперь тоже самое сделаем для сообщенийв Dialogs, заменим стандартную textarea на нашу и добавим теже валидаторы.

        import { Textarea } from "../common/FormControls/FormControls";
        import { required, maxLengthCreator } from "../../../utils/validators/validators";

        const maxLength100 = maxLengthCreator(100);
        
        const AddMsgForm = (props) => {
            return (
                <Form
                onSubmit={onSubmit}
                render={({ handleSubmit, form, submitting, pristine, values }) => (
                    <form onSubmit={handleSubmit}>
                    <div>
                         <Field placeholder='Type Msg' name="newMsgBody" component={Textarea} 
                                validate={[required, maxLength100]}/>




    Также переделаем Login, но тут у нас не textarea, a input. Значит нужно сделать свой компонент.

            import { Input } from "../common/FormControls/FormControls";
            import { required, maxLengthCreator } from "../../utils/validators/validators";

            const maxLength50 = maxLengthCreator(50);

            const LoginForm = (props) => {
                return (
                    <Form
                        onSubmit={onSubmit}
                        render={({ handleSubmit, form, submitting, pristine, values }) => (
                            <form onSubmit={handleSubmit}>
                                <div>
                                    <Field placeholder={'Login'} name={"login"} component={Input} validate={[required, maxLength50]} />
                                </div>
                                <div>
                                    <Field placeholder={'Password'} name={"password"} component={Input} validate={[required, maxLength50]}/>
                                </div>
                                <div>
                                    <Field type={"checkbox"} name={"rememberMe"} component={Input} /> remember me
                                </div>
                                <div>
                                    <button>Log In</button>
                                </div>
                            </form>
                        )}
                    />
                )
            }


        Теперь у нас дублирование кода Input и Textarea практически идентичны, сделаем рефакторинг. Так как у нас меняется только
            середина, мы вместо нее напишем children(потомок) который будем настраивать в зависимости от потребности. При этом
            props нужно деструктуризировать, а children берется из внутренности тега FormControl. 
            
            //! В видео еще в props был child, но он вроде не нужен, если не заработает добавить.
            
            const FormControl = ({ input, meta, ...props }) => {
                return (
                    <div className={styles.formControl + " " + (hasError ? styles.error : "")}>
                        <div>
                            {props.children}
                        </div>
                        { hasError && <span>{meta.error}</span> }
                    </div>
                )
            }


            export const Textarea = (props) => {
                const { input, meta, ...restProps } = props;
                return <FormControl {...props}> <textarea {...input} {...restProps} /> </FormControl>
            }

            export const Input = (props) => {
                const { input, meta, ...restProps } = props;
                return <FormControl {...props}> <input {...input} {...restProps} /> </FormControl>
            }
            

    //todo Проверить работоспособность как есть, или переделать по новому.

    //! Пару раз не запускалось писало что не определены пропсы в Диалогс и МайПостс, потом запускалось без ошибок серый экран
    //! потом запустилось нормально. Но не показывает формы даже на Логине, видимо нужно по новому записывать.
    //! Заменил в Логине на новый синтаксис, получилось, но цвет текста белый и поля тоже не выделяются.

            const maxLength16 = maxLengthCreator(16);

            const composeValidators = (...validators) => value =>
                            validators.reduce((error, validator) => error || validator(value), undefined);

            const LoginForm = (props) => {
                return (
                    <Form
                        onSubmit={onSubmit}
                        render={({ handleSubmit, form, submitting, pristine, values }) => (
                            <form onSubmit={handleSubmit}>
                                <div>
                                    <Field placeholder={'Login'} name={"login"} component={Input} 
                                            validate={composeValidators(required, maxLength16)} />
                                </div>
                                <div>
                                    <Field placeholder={'Password'} name={"password"} component={Input} 
                                            validate={composeValidators(required, maxLength16)}/>
                                </div>
                                <div>
                                    <Field type={"checkbox"} name={"rememberMe"} component={Input} /> remember me
                                </div>
                                <div>
                                    <button>Log In</button>
                                </div>
                            </form>
                        )}
                    />
                )
            }


    //! Заменил таким же образом в Диалогс и МайПостс вылезли ошибки
        src\Components\Dialogs\Dialogs.jsx
        Line 13:3:   'props' is not defined     no-undef
        Line 24:17:  'onSubmit' is not defined  no-undef

        src\Components\Profile\MyPosts\MyPosts.jsx
        Line 11:3:   'props' is not defined     no-undef
        Line 22:17:  'onSubmit' is not defined  no-undef
    //! Перезапустил, всё вроде стабилизировалось. Но Профиль пустой, а на Диалогс не пускает без логина. 

    //! В стилях убрал .formControl и они применились
        .error input,
        .error textarea {
            border: 2px solid red;
        }

        .error span {
            color: rgb(255, 217, 0);
            font-weight: bold;
        }
        
    //! В логине работает форма, должна работать и в других страницах.


*/}


{/*    ====    78. login и logout API    ====

    Будем делать логинизацию на сайт(сервер) соц сети прямо из приложения. 
    
    //! Если зайти на сайт в браузере и залогиниться, создается куки которая сидит в памяти, у нас в api.js при ajax запросе 
        //! прописано виз креденшелс - тру, благодаря  этому при нашем запросе с локал хоста(приложение) на другой домен(сервер) 
        //! куки цепляется к запросу и сервер понимает что это мы и работает с приложением.


    //! У нас есть authReducer задача которого процессить текущего пользователя.
        Раньше мы бы сделали логинредюсер чтоб собирать данные из формы, но так как мы используем редакформ он этот редюсер
        создал за нас и там он хранит все state для всех форм. 
        
    

    В логин при нажатии на кнопку сабмит 

            <LoginForm onSubmit={onSubmit} />


        в нее собираются и приходят все данные formData

            const Login = (props) => {
                const onSubmit = (formData) => {
                    console.log(formData);

        отсюда мы должны эти данные отправить на сервер(задиспатчить), но из UI комопнента мы не должны делать такой запрос, 
        поэтому мы сделаем это из бизнеса в authReducer из санки которая принимает метод диспатч, санккриэйтер - login возвращает 
        санку и может что то(параметры) принимать и это что то доступно сенке через замыкание. 

        Что бы заполнить параметры в санккриэйтере мы смотрим в документацию сервера. Там есть /auth/login видим что в нем есть
        post и delete запросы. Эти запросы создают что то и удаляют, так при логине мы создаем залогиненую сессию пользователя, а 
        при вылогинивании - удаляем. (в других серверах может быть обновление юзера как залогиненного через PUT запрос, кто как
        делает).

        Кликаем по POST и смотрим что мы должны отправить с запросом: email, password, rememberMe + capcha(ее делать не будем
        если возникнет проблема - много неверных вводов логина/пароля то будет капча, тогда просто логинимся с браузера и счетчик
        капчи собьется).


        Заполним сначала API.js 
        из которого будет браться запрос. post(put) запрос может посылать дополнительные данные в виде 
        объекта(для get и delete доп параметры можно отправить только в виде query строки дописав непосредственно к адресу)

            export const authAPI = {
                me() {
                    return instance.get(`auth/me`);
                },
                login(email, password, rememberMe = false) {
                    return instance.post(`auth/login`, { email, password, rememberMe });
                },
                logout() {
                    return instance.delete(`auth/login`);
                }
            }

        создали логин и логаут запросы, для логина указали параметры которые придут в него и далее пошлются на сервер rememberMe
        по умолчанию стоит false если вдруг не прийдет.


        В authReducer создаем login в который прийдут  email, password, rememberMe. При успешном запросе вернется пост код 0,
        и тогда мы заново задиспатчим санккриэйтер getAuthUserData - который раньше мы запрашивали при запуске приложения из 
        HeaderContainer, чтобы заново прошел поток(флоу) получения информации обо мне. Тоже сделаем для логаута - когда 
        отправляем логаут на сервер сервер удаляет созданное при логине куки, сервер будет считать нас анонимным юзером и нам
        нужно сделать себя анонимным и в нашей соц сети, для этого зачистим state юзера - initialState.
        //! заменили data на payload в  ...action.payload и SET_AUTH_USER_DATA, payload: { userId, login, email } })
        //! добавили в setAuthUserData isAuth чтобы его передавать, и теперь при логине будем передавать true а при логауте
        //! false

            export const login = (email, password, rememberMe) => (dispatch) => {
                authAPI.login(email, password, rememberMe)
                    .then(response => {
                        if (response.data.resultCode === 0) {
                            dispatch(getAuthUserData());
                        }
                    });
            }

            export const logout = () => (dispatch) => {
                authAPI.logout()
                    .then(response => {
                        if (response.data.resultCode === 0) {
                            dispatch(setAuthUserData(null, null, null, false));
                        }
                    });

            API готов, бизнесс готов(возможно с багами).



    Теперь в Login задиспатчим санккриэйтор login в бизнесс когда происходит submit. Для этого нужно получить доступ к store и 
        потому делаем контейнерный компонент который даст нам этот доступ, над Login прямо в этом же файле посредством ХОКа connect.
        
        Благодаря connect получаем доступ к login из auth-reducer  
            import { login } from '../redux/auth-reducer';

            export default connect(null, {login})(Login); - вместо mapStateToProps ставим null, а для mapDispatchToProps используем
                                                            сокращенную запись передав в объекте название санккриейтера и импортировав
                                                            его 


        //! это санк криэйтер вернет login санку, connect под тем же самым именем засовывает в props коллбек который принимает параметры
        //! (formData.email, formData.password, formData.rememberMe) и внутри себя диспатчит вызов санккриэйтера login и в него 
        //! передаются теже параметры которые приходят в коллбек
        

            const Login = (props) => {
                const onSubmit = (formData) => {
                    console.log(formData);
                    props.login(formData.email, formData.password, formData.rememberMe)
                }

        У автора получилось залогиниться через приложение при этом в хедере в правом верхнем углу вместо LogIn появился его ник.



    Теперь сделаем Редирект чтобы после успешной логинизации мы попадали на свой профиль. В Login при успешной логинизации
        сделаем Redirect который сейчас Navigate(проимпортируем его), а если не залогинены тогда выполниться код который ниже if 

            const Login = (props) => {
                const onSubmit = (formData) => {
                    console.log(formData);
                    props.login(formData.email, formData.password, formData.rememberMe)
                }

                if (props.iaAuth) {
                    return <Navigate to={"/profile"} />
                }

                return <div>
                    <h1>Login</h1>
                    <LoginForm onSubmit={onSubmit} />
                </div>
            }


        Теперь нужно получить iaAuth из контейнерного компонента, для этого положим в него iaAuth который находиться в reducerу
            auth(смотрим название в redux-store где мы combine reducers) и называется iaAuth(название в auth-reducer)

                const mapStateToProps = (state) => ({
                    isAuth: state.auth.isAuth
                })

                export default connect(mapStateToProps, {login})(Login);



    В Header создадим кнопку для логаута и добавим onClick который придет в props из контейнерного компонента.

            { props.isAuth 
                ? <div>{props.login} - <button onClick={props.logout}>Log Out</button> </div>
                : <NavLink to={ '/login'}>Login</NavLink>}


        Теперь в контейнерном компоненте добавим этот санкКриэйтер logout
            
            import {logout} from "../redux/auth-reducer";

            export default  connect(mapStateToProps, { getAuthUserData, logout } )(HeaderContainer);


        //! При вылогинивании кнопка log out не исчезла, видимо потому что isAuth остался true. Так получилось потому что в 
        //! auth-reducer мы isAuth вынесли в payload, а из authReducer не удалили его отдельно и поэтому он перезатирал тот
        //! который приходил из санок. Удалим его.

            ...state,
            ...action.payload,
            isAuth: true

        
        Теперь кнопка исчезает но мы остаемся на страничке профиля, но мы не можем там быть без id или статуса залогиненого.
        Нужно сделать как для месседжей, и также сделать что бы показывалась ошибка при вводе неправильного логина/пароля.


        
    //! Как оказалось в Api у меня были лишние строки ответа сервера, а их вроде там не должно быть, и самое главное в Authreducer
    //! у меня было слово responce вместо response - понятно что никакого ответа от сервера не было, теперь может заработает всё
    //! как нужно. Также в let { id, login, email } = response.data.data; - была 1 раз data - исправил как в видео.
    //! В Login закоментировал onSubmit потому что должен работать тот который внутри комопнента Login.
    //! Проверить!!!


    //! Profile не грузиться потому что я не сделал редирект, там как то хитро надо было делать что б юзер выделялся
    //! Логин видит что юзер влогинен(справа показывается Ник) и вылогинивание работает, но влогиниться из приложения
    //! не получается потому что там 2 onSubmit и выполняет работу только внешний но он не имеет доступа к props
    //! поэтому не отправляет запрос.


*/}


{/*    ====    79. stopSubmit (redux-form)    ====

    Сейчас если вводить неправильный логин/пароль то нету никакого сообщения об ошибке. Так как валидаторы формы у нас находятся
        по сути в UI, в самом компоненте, а не в state - то они не пускают при обычной ошибке валидирования дальше, а ошибка
        получаемая с сервера уже не в UI и для того чтобы ее обработать в redux-form есть actionCreator в который передадим
        название формы которую будем стопать при ошибке с сервера и проблемное поле с тектом ошибки, а результат вызова будем 
        диспатчить.

        Обработку этой ошибки(при этом ответ от сервера будет 1 а не 0) мы допишем в auth-reducer
        //! не известно так ли он в final-form называется и работает

            import {stopSubmit} from 'react-final-form';

            export const login = (email, password, rememberMe) => (dispatch) => {
                authAPI.login(email, password, rememberMe)
                    .then(response => {
                        if (response.data.resultCode === 0) {
                            dispatch(getAuthUserData());
                        } else {
                            let action = stopSubmit("login", {email: "Email s wrong"}); 
                            //! - посмотреть название формы правильно ли
                            dispatch(action);
                        }
                    });
            }

        Подсветилось поле email красным и под ним появилось сообщение об ошибке в span, тоесть по сути отработало как валидатор.


        Но есть проблема, сервер нам не скажет в каком из полей у нас ошибка, это может быть и password. С другой стороны мы и 
        не должны точно указывать поле потому что вдруг это взломщик и мы таким образом сообщим что имейл допустим правильный
        а не правильный только пароль. Поэтому нужно писать что неправильный логин/пароль, но и тогда нужно подсветить ошибкой 
        второе поле. Для общей подсветки всей формы используется _error, но так как такого поля нету то ничего и не сработает, 
        поэтому нужно добавить такое поле в форму и приписать на него стили. 

        Стиль для общей ошибки в FormControl.module.css
        
            .summaryError {
                border: 2px solid red;
                padding: 5px;
                color: rgb(255, 217, 0);
            }


        В Login.js импортируем стили. В форму приходят props и когда мы получаем action с error он диспатчится и попадает в эти
        props, и тогда отобразиться сообщение об ошибке в диве которое придет в props, а до этого не будет чему отображаться.

            import styles from "../common/FormControls/FormControls.module.css"

            <Field type={"checkbox"} name={"rememberMe"} component={Input} /> remember me
                </div>
                { props.error && <div className={styles.summaryError}>
                    {props.error}
                </div>}


        В auth-reducer дописываем _error и рефакторим код

            } else {
                dispatch( stopSubmit("login", {_error: "Common Error"}) );
            }
        

            Сделаем чтобы показывался текст именно ошибки с сервера, он приходит в ответе response.data.messages, проверяем есть
            ли он вообще сравнивая количество символов с 0, если да показываем его, если нет показываем стандартный текст.

            let message = response.data.messages.length > 0 ? response.data.messages : "Some error";
            dispatch( stopSubmit("login", { _error: message }) );



    Рефакторим ProfileContainer, уберем захардкоженое значение userId и если в url нету userId будем подставлять наше которое
        возьмем как и isAuth из state.
        //! Разобраться с - withRouter

            componentDidMount() {
                let userId = this.props.match.params.userId;
                if (!userId) {
                    userId = this.props.authorizedUserId;
                }

            let mapStateToProps = (state) => ({
                profile: state.profilePage.userProfile,
                status: state.profilePage.status,
                authorizedUserId: state.auth.userId,
                isAuth: state.auth.isAuth
            });

        но может так получиться что не будет айди ни в url ни в state(если не залогинен) тогда нужно сделать редирект на Login.
        //! вылез косяк когда нету айди даже когда юзер залогинен, он обновляет страницу при этом посылается запрос me()
        //! из header, но он не успевает послаться и установить данные в state поэтому нету никакого id и юзера редиректнет
        //! на Login потом пройдет запрос и юзера кинет на Profile так как он уже залогинен. Будет моргание.

        Для того чтобы такого не было, нужно сделать инициализацию приложения(показать крутилку пока идет сбор данных с сервера
        чтобы потом показать уже со всеми данными приложение).


        //! stopSubmit в новой final-form нету, не запускается приложение совсем, нужно что то менять.


*/}


{/*    ====    80. Инициализация приложения    ====

    Сейчас такая схема - при обновлении в браузере и залогиненом юзере - пытается загрузить Диалог(месседжы) и в это время идет 
        запрос на сервер me() для выяснения авторизован ли юзер, пока получаем ответ с сервера, Диалог видит что юзер не 
        авторизован(потому что ответ еще не пришел) и редиректит на Логин и только он пытается загрузиться приходит ответ с 
        сервера что мы залогинены и редиректит на Профайл и получаются моргания экрана. Аналогичная ситуация будет и с 
        темной/светлой темой и с языком сайта если юзер выбрал не то что стоит по умолчанию.


    Решение - не показываем приложение пока не выясним кто зашел(все параметры юзера) для этого запросы которые делаем в Header
        эту логику мы перенесем в App. Но App у нас ф-й, а не классовый и у нее нету контейнерного компонента, он уже не чистый
        потому что он рендерит контейнерные компоненты, поэтому не целесообразно делать над ним контейнерный классовый компонент
        а сделаем классовый из App . А в идеале чистый компонент - это ф-й компонент тот у которого всё что внутри тоже чистое, 
        поэтому не паримся и делаем Апп - классовым компонентом.

        Теперь можно подвязаться к методам жизненного цикла и делать запросы при компонентДидМаунт при этом законектить App 
        компонент чтобы он получил доступ к getAuthUserData

            import { connect } from 'react-redux';
            import {getAuthUserData} from '../src/Components/redux/auth-reducer'

            class App extends React.Component {
                componentDidMount() {
                    this.props.getAuthUserData();
                }

                render() {
                    return (
                        <BrowserRouter>
                            <div className='app-wrapper'>
                                <HeaderContainer />
                                <Navbar />
                                <div className='app-wrapper-content'>
                                    <Routes>
                                        <Route path="/dialogs" element={<DialogsContainer />} />
                                        <Route path="/profile/:userId?" element={<ProfileContainer />} />
                                        <Route path="/users" element={<UsersContainer />} />
                                        <Route path="/login" element={<LoginPage />} />
                                    </Routes>
                                </div>
                            </div>
                        </BrowserRouter>
                    );
                }
            }

            export default connect(null, { getAuthUserData } )(App);
        


    //! Не работает роутинг потому что если к компоненту которые выполняет роутинг сделать connect то роутинг работает не 
        так как должен, нужно то что мы законектили обернуть withRoute - очередным HOC чтобы роут нормально работал. Обернем через
        compose чтобы не передавать одно в другое(избежать wrapper hell).

        //! withRouter не работает уже, нужно заменять на хуки и длать ф-й компонент.

            // import { withRouter } from 'react-router-dom';
            import { compose } from 'redux';

            export default compose(
                withRouter,
                connect(null, { getAuthUserData } )) (App);

        У автора всё заработало.



    Теперь мы сделаем что приложение не будет показывать страницы до того как не проинициализируется(получим все необходимые 
        данные) для этого сделаем app-reducer который будет отвечать за всё приложение. Создаем в state свойство initialized и 
        action - INITIALIZED_SUCCESS и если такой экшн сработает то мы заменим initialized на true.

        Из App мы перенесем получение данных о пользователе dispatch( getAuthUserData() ); в app-reducer и будем диспатчить 
        в compose не его а initializeApp. Когда getAuthUserData - получит данные в initializeApp в редюсере мы задиспатчим
        initializedSuccess - что всё хорошо можно показывать страницы приложения. Но оба эти запроса асинхронны и нужно делать
        диспатч initializedSuccess только после получения данных от сервера. Чтобы получить ответ из getAuthUserData диспатча
        в aut-reducer пропишем return, так как диспатч возвращает промис, и мы на него (зенимся).then а любой then тоже возвращает
        promise то этот промис пойдет выше и мы его вернем из диспатча и раз это промис мы можем дождаться когда он зарезолвится
        (выполниться, не выжно как положительно или отрицательно) и сделать диспатч initializedSuccess.

            import { getAuthUserData } from './auth-reducer'

            const INITIALIZED_SUCCESS = 'INITIALIZED_SUCCESS';

            let initialState = {
                initialized: false
            }

            const appReducer = (state = initialState, action) => {
                switch (action.type) {
                    case INITIALIZED_SUCCESS:
                        return {
                            ...state,
                            initialized: true
                        }

                    default:
                        return state;
                }
            }

            export const initializedSuccess = () => ({ type: INITIALIZED_SUCCESS });

            export const initializeApp = () => (dispatch) => {
                let promise = dispatch(getAuthUserData()).
                    promise.then(() => {
                        dispatch(initializedSuccess());
                    })

            }

            export default appReducer;

        //! Если бы диспатчей было несколько и нам нужно было бы дождаться чтобы они все выполнились нужно было бы сделать так
            Затасовать их в массиа и прицепить к Promise.all - он запуститься когда все промисы выполняться.
            
            Promise.all([promise1, promise2, promose3])
                .then(() => {
                    dispatch(initializedSuccess());
                });


        Теперь initialized станет true и App компонент получит это в props - создадим mapStateToProps для их прокидывания - это 
        ф-я которая принимает state и возвращает объект в котором будет initialized - initialized: state.app.initialized
        только чтобы в state реально был initialized нам нужно наш новый редюсер закомбайнить к остальным в redux-store.
        

        Теперь в рендере будем возвращать всю разметку только когда мы проинициализировались иначе будем показывать Preloader
        
             render() {
                    if (!this.props.initialized) {
                        return <Preloader />
                    }

                    return (<BrowserRouter>
                        <div className='app-wrapper'>
                            <HeaderContainer />
                            <Navbar />
                            <div className='app-wrapper-content'>
                                <Routes>
                                    <Route path="/dialogs" element={<DialogsContainer />} />
                                    <Route path="/profile/:userId?" element={<ProfileContainer />} />
                                    <Route path="/users" element={<UsersContainer />} />
                                    <Route path="/login" element={<LoginPage />} />
                                </Routes>
                            </div>
                        </div>
                    </BrowserRouter>
                    );
                }
            }

            const mapSateToProps = (state) => ({
                initialized: state.app.initialized
            })

            export default compose(
                withRouter,
                connect(mapSateToProps, { initializeApp }))(App);

        Получилось, теперь работает крутилка, а потом только отображается информация и нету редиректов туда-сюда.



    Осталось сделать чтобы при logout юзера перемещало со страницы профиля, так как уже юзер анонимным становится. Сделаем не
        через редирект, а программным методом(реактовским) у нас в props есть history и у него метод push, этим методом можно
        запушить новое location(нахождение). Сделаем пуш на /login если userId после проверки всетаки не окажеться в 
        ProfileContainer

            class ProfileContainer extends React.Component {
                componentDidMount() {
                    let userId = this.props.match.params.userId;
                    if (!userId) {
                        userId = this.props.authorizedUserId;
                        if(!userId) {
                            this.props.history.push("/login")
                        }
                    }
                    this.props.getUserProfile(userId);
                    this.props.getUserStatus(userId);
                }

            //! но этот метод не очень хорош потому что мы как бы влазим в жизненный цикл компонента и делаем ререндер из UI 
            //! компонента, без согласования со state, а при редиректе ререндер будет происходить после обновления state.

            

    В UsersContainer удалили withAuthredirect чтобы не перекидывало на логин пейдж и можно было полистать юзеров

                export default compose (
                connect(mapStateToProps, { follow, unfollow, setCurrentPage, toggleFollowingInProgress, getUsers })
                )(UsersContainer);

            //! Причем withAuthredirect у меня был не в том месте где должен был быть, у автора он был на первом месте в compose
            //! как и в сегодняшнем уроке.




    //! withRouter/stopSubmit - проблемные места для новых версий


*/}


{/*    ====    81. Селекторы ( reselect p.I )    ====

    Для UI компонента нужны данные в компактном виде, тоесть для UsersPage не нужен весь state, а из него мы выбираем нужные 
        данные и через mapStateToProps представляем их как users
        
                            mapStateToProps=(state)=>({
            Component1 <--   ...                           <------------- 
                            users: state.users.items })                  \
                                                                            state
                
                            mapStateToProps=(state)=>({                  /  
            Component2 <--   ...                           <------------- 
                            users: state.users.items, 
                            userId: state.auth.userId })


        
        //! Для бизнеса хранить информацию нужно как удобно бизнесу, соблюдая целостность, удобство, обновление, ...
        тоесть если было раньше свойство users в котором объект items с массивом данных
            
            state = {
                ...
                users: {
                    items [{}, {}, {}]
                }
                ...

        а потом нам понадобилось вместо всех users их разбить на категории разрешенных и забаненых

            state = {
                ...
                users: {
                    allowedUsers [{}, {}, {}],
                    bannedUsers [{}, {}, {}]
                }
                ...

        Таким образом посредник mapStateToProps между UI и state ломается, путь к искомым данным уже не будет соответствовать, 
        а таких mapStateToProps может быть очень много, тоесть нужно будет выполнить кучу изменений в разных местах приложения
        потому что эти users нужны для разных страниц, и получается дублирование кода. Для этого нужно вынести этот код выбора
        данных из state в ф-ю которая называется селектор, будем передавать в неё весь state потому что он приходит в props
        полностью и с помощью селектора выбирать только нужную информацию, поэтому при следующей смене state нам нужно будет 
        поменять код только в одном месте - в селекторе.

                            mapStateToProps=(state)=>({
            Component1 <--   ...                           <------------- 
                            users: getUsers(state) })                     \
                                                                            getUsers =(state)=>{      
                                                                                return state.users.allowedUsers  <---------    state
                                                                            }
                                                                                
                            mapStateToProps=(state)=>({                  /  
            Component2 <--   ...                           <------------- 
                            users: getUsers(state), 
                            userId: state.auth.userId })



    Начнем рефакторить с UsersContainer, закоментируем старый mapStateToProps потому что мы плавно перейдем к библиотеке reselect
        и чтобы мы поняли почему она так важна - потому что селекторы с одной стороны нам помогают, а с другой вносят воздействие
        из-за которого компоненты чаще перерисовываются.

        Так как селекторы вроде как ближе к state потому что работают сразу с ним, потом с mapStateToProps, а потом с UI
        сделаем файл с селекторами для users в папке redux рядом с редюсерами - users-selectors.js.  Видим что всю информацию в этом
        mapStateToProps получаем из usersPage, делаем на каждое получение данных селектор.

        В селекторах 

            export const getUsersData = (state) => {
                return state.usersPage.usersData;
            }

            export const getPageSize = (state) => {
                return state.usersPage.pageSize;
            }

            export const getTotalUsersCount = (state) => {
                return state.usersPage.totalUsersCount;
            }

            export const getCurrentPage = (state) => {
                return state.usersPage.currentPage;
            }

            export const getIsFetching = (state) => {
                return state.usersPage.isFetching;
            }

            export const getFollowingInProgress = (state) => {
                return state.usersPage.followingInProgress;
            }


        В UsersContainer

            import { getCurrentPage, getFollowingInProgress, getIsFetching, getPageSize, 
                getTotalUsersCount, getUsersData } from '../redux/users-selectors';


            let mapStateToProps = (state) => {
                return {
                    users: getUsersData(state) ,
                    pageSize: getPageSize(state),
                    totalUsersCount: getTotalUsersCount(state) ,
                    currentPage: getCurrentPage(state),
                    isFetching: getIsFetching(state),
                    followingInProgress: getFollowingInProgress(state)
                }
            };


    Выявили что при клике на пейджинг юзеров(номер страницы с юзерами) она переключается на нужную, но не отображается номер
        текущей страницы - он постоянно 1, фиксим.

            export const getUsers = (currentPage, pageSize) => {
                return (dispatch) => {
                    dispatch(toggleIsFetching(true));
                    dispatch(setCurrentPage(currentPage));  - добавили диспатч текущей страницы

                    usersAPI.getUsers(currentPage, pageSize).then(data => {
                        dispatch(toggleIsFetching(false));
                        dispatch(setUsers(data.items));
                        dispatch(setTotalUsersCount(data.totalCount));
                    });
                }
            }


*/}


{/*    ====    82. mapStateToProps ( reselect p.II )    ====

    //! Сначала у нас был Реакт(мы делали свой стор), потом мы подключили Redux и пользовались его store, потом подключили
    //! библиотеку React-redux для более удобного использования. Она нам предоставляет HOC connect который делает контейнерный
    //! компонент над тем компонентом в который нам нужно передать данные из state и для слежения за state connect на него
    //! подписывается.

    //! State большой и при любом изменении connect вызывает mapStateToProps - он формирует объект который нужен компоненту из
    //! state и сравнит с предыдущим, и если они одинаковы то перерисовки компонента не будет, а если разные то будет перерисовка.
    //! Сравнение идет по ссылке как объекты, если ссылка другая значит будет перерисовка.

    //! Для примера взяли Profileontainer в render засунул консольлог - рендер профайл, а в mapStateToProps - консоль лог с тестом
    //! mapStateToProps Profile. Потом зашел на страницу Profile и пошли консольлоги, не каждый раз был рендер.
    //! для полноценной проверки создал index.js в котором каждую секунду в store шел диспатч action c типом fake

        setInterval(()=>{
            store.dispatch( {type: "FAKE"} )
        }, 1000 );

    //! Диспатч это ф-я store( store - ООП объект у которого есть метод диспатч), но react-redux от нас это скрыл для удобства.
    //! а в users-reducer дописал в state свойство fake: 10 и case в котором при получении action FAKE будет создаваться копия
    //! state и затираться это свойство, но главное тут что будет создаваться копия state, а значит это будет новая версия state

        case "FAKE": return ( ...state, fake: state.fake + 1 ) 

    //! Теперь видим что постоянно срабатывает mapStateToProps для Profile хотя изменения state идут в Users. Но рендера нету
    //! потому что в profilePage ничего не изменилось. Но mapStateToProps по производительности не очень нагружает систему
    //! потому что там просто сравнение идет, а вот перерисовка нагружает систему.

    //! В UsersContainer у нас используются простые селекторы которые только достают нужную информацию из state, но селекторы
    //! были придуманы чтобы инкапсулировать логику, поэтому в основном они сложные и могут содержать ресурсоемкие процессы
    //! циклы, мат. операции, работу с большими массивами. И при таком способе с селекторами в mapStateToProps они будут
    //! срабатывать на каждое обновление state и при этом если они будут сложные то будут нагружать систему. Также если нам
    //! нужно задебажить логику в селекторе постоянное срабатывание mapStateToProps сделает это очень затруднительным.
    //! А если в селекторе будет какой то метод типа filter который каждый раз возвращает новый массив даже если нету
    //! изменений то каждый раз будет происходить перерисовка потому что mapStateToProps будет считать его новым.

    //! Для решения этих проблем есть специальная библиотека.


*/}


{/*    ====    83. подключаем реселект ( reselect p.III )    ====

    Библиотека reselect - решает предыдущие проблемы таким образом. При запуске mapStateToProps запускается селектор и выполняет
        свои расчеты, а результат сохраняет. Также для этого селектора определяются зависимости, от какой части state зависит
        результат этого селектора и при следующем вызове mapStateToProps из всего state(это новый state потому что если бы он не
        изменился то не запустилась бы mapStateToProps) достается та часть state от которой зависит результат селектора и 
        сравнивается с предыдущей частью, если они одинаковы то возвращяется предыдущий сохраненный результат из памяти и селектор
        не запускается заново, а если разные то запускается селектор выполняется новый просчет и возвращается уже новый актуальный
        результат. //! Димыч сказал что этот подход похож на хук useEffect (хотя возможно и на useMemo)


    Подключаем руселект npm install reselect  (в видео версия 1.17.3)

    Реселект подразумевает создание сложных селекторов с помощью этой библиотеки, а примитивные селекторы как у нас оставим так.
        Создадим сложный селектор с помощью библиотеки. createSelector - спец. ф-я которая возвращает селектор, внутрь неё передаем
        ф-ю которая будет выбирать нужную часть state.

        в users-selectors

            import { createSelector } from "reselect";

            export const getUsersDataSuperSelector = createSelector( getUsersData, (users) => {
                return users.filter(u => true);
            })

            export const getUsersData = (state) => {
                return state.usersPage.usersData;
            }


        в UsersContainer

            import { getCurrentPage, getFollowingInProgress, getIsFetching,
                getPageSize, getTotalUsersCount, getUsersData, getUsersDataSuperSelector } from '../redux/users-selectors';

            let mapStateToProps = (state) => {
                return {
                    //users: getUsersData(state) ,
                    users: getUsersDataSuperSelector(state),
                    pageSize: getPageSize(state),
                    ...


        //! Таким образом мы создаем супер селектор getUsersDataSuperSelector в ф-и createSelector первым аргументом передается
        //! тот простой селектор getUsersData который достает нужный кусок state(зависимость) при изменении которого будет
        //! запускаться внутренняя логика  return users.filter(u => true).

        //! Тоесть в UsersContainer мы уже вызываем суперконтейнер и все также передаем в него state так простой селектор
        //! getUsersData сможет получить доступ к state из суперселектора. Если этот простой селектор возвращает state который
        //! не изменился то суперселектор вернет предыдущее состояние и не будет запускать внутренний код, а если вернется новый
        //! кусок state то запуститься внутренний код и из суперселектора вернеться актуальный результат его работы.

        //! зависимостей у селектора может быть много они передаются первым аргументом о порядку(вроде в массиве но нужно уточнить)

    //! поменяем названия на более легкие чтобы было как до этого


*/}


{/*    ====    84. Hooks:  useState    ====

    Хуки - ф-и которые могут выполнять сайд эффекты(локальный state) и влазить в выполнение кода в некоторые моменты(жизненный 
        цикл компонента).

    Разработчики реакта давно агитировали использовать только функциональные компоненты вместо классовых, но так как у ф-х
        не было всех возможностей классовых( локальный state,жизненный цикл компонента ) - это откладывалось. С помощью хуков
        разработчики реакт дали ф-му компоненту возможности классового.

    Классовый обладал этими возможностями потому что он делал экземпляр класса - объект, который хранился в памяти и соответственно
        мог хранить информацию(локал state) и так как это объект у него были методы(componentDidMount, componentDidUpdate, ...).
        А ф-й комопнент - просто ф-я которую мы вызвали она вернула нам JSX и удалилась из памяти.
        Реакт при вызове ф-го компонента если видит что в нем есть хуки - запоминает где то у себя вызовы этих хуков и из какого
        компонента они были сделаны(вроде как маркирует) - по словам Димыча //todo почитать механизм хуков
        


    Рассмотрим на практике на примере ProfileStatus где нам нужно хранить локал state и подвязываться к методу жизненного цикла
        componentDidUpdate, для этого скопируем этот файл и назовем ProfileStatusWithHooks.jsx. В него импортируем useState из 
        react, изменим классовый компонент на ф-й, удалим пока всю логику и несуществующие параметры. В ProfileInfo будем
        отрисовывать  ProfileStatusWithHooks вместо ProfileStatus. Оставили только разметку чтобы проверить что приложение 
        работает. Теперь добавим useState первое свойство старого state было editMode: false. Создадим useState(false) - в него
        в эту ф-ю закинем значение по умолчанию(инициализационное) - false. Эта ф-я useState возвращает массив в котором первый
        элемент - значение state(свойства) - дадим свойству название editMode - и вытащим в эту переменную, а второй элемент - ф-я 
        которая будет изменять это значение, назовем ее setEditMode.
        
            let stateWithSetState = useState(false);
            let editMode = stateWithSetState[0];
            let setEditMode = stateWithSetState[1];

        теперь у нас есть state и мы можем применить его в разметку чтобы показывать или span или input

                return (
                    <div>
                        { !editMode &&
                            <div>
                                <span >{props.status || "----------"}</span>
                            </div>
                        }
                        {editMode &&
                            <div>
                                <input autoFocus={true} 
                                    />
                            </div>
                        }
                    </div>
                );
            }

        можно вручную поменяв начальный state убедиться что происходит смена отображаемых компонентов.


    //! Когда мы в ф-м компоненте пишем useState(1) эта 1 сохраняется гдето на стороне Реакта, он запоминает что нужно
    //! следить за вызовом этого компонента и для отрисовки этого компонента будет хранить эту 1. И чтобы изменить эту 1
    //! из реакта в useState приходит коллбек ф-я которая может изменить именно эту 1 и при таком изменении на 2 раект должен
    //! заново перерисовать компонент в котором произошло это изменение, при этом снова будет вызван useState но реакт 
    //! помнит что он перерисовывал компонент потому что там было изменение useState и он проигнорирует начальное значение
    //! 1 и вернет уже текущее(запомненое) - 2.

    

    Такая запись была для понимания

            let stateWithSetState = useState(false);
            let editMode = stateWithSetState[0];
            let setEditMode = stateWithSetState[1];


        в основном пишут как деструктурированное присваивание, например

            var a, b, rest;
            [a, b] = [10, 20];

            console.log(a); // 10
            console.log(b); // 20


            [a, b, ...rest] = [10, 20, 30, 40, 50]

            console.log(rest); // [30, 40, 50]


        для нашего примера будет так

            let arr = [1, ()=>{}]; - массив со значением и ф-й коллбеком для изменения этого значения
            let [a, setA] = arr;


        Перепишем по нормальному, вместо получения массива в stateWithSetState и потом вытягивания его елементов по разным
        переменным, сделаем это сразу при объявлении переменных в одной строке

            let [editMode, setEditMode] = useState(false);

            

    Теперь будем менять значение editMode по клику, вызывая ф-ю для активации EditMode

            const activateEditMode = () => {
                setEditMode(true);
            }

            const deactivateEditMode = () => {
                setEditMode(false);
                //props.updateStatus(this.state.status); -//! это для того чтобы сообщить серверу что у нас поменялся status в 
            }                                             //! локальном state и происходила перерисовка с данными из глоб. state

            return (
                <div>
                    { !editMode &&
                        <div>
                            <span onDoubleClick={activateEditMode} >{props.status || "----------"}</span>
                        </div>
                    }
                    {editMode &&
                        <div>
                            <input autoFocus={true}  onBlur={deactivateEditMode} />
                        </div>
                    }
                </div>
            );
            

        
    Но у нас в state был еще status. Есть 2 варианта: 
        
      1) положить в useState объект с такой же структурой как у нас была 
            
            useState( {editMode: false, status: props.status} );
        
        
      2) раздробить state - сделать несколько useState 

            let [editMode, setEditMode] = useState(false);
            let [status, setStatus] = useState(props.status);


        Но раньше при изменении state мы могли обратиться только к status: this.props.status при этом editMode оставался 
        неизменным, тоесть они не зависели друг от друга, и логично и проще будет сделать вторым методом.
            
            this.setState({
                status: this.props.status
            });


        //! Если делать первым методом тогда надо  при использовании ф-и колбека setState создавать новый объект/массив и в него
        //! деструктуризровать старый + добавлять новые данные или изменять старые, а не просто изменить свойство в изначальном, 
        //! объекте, чтобы реакт заметил что объект новый и перерисовал компонент, иначе свойство поменяется но ререндера не будет.
         
            const [cards, setCards] = useState([
                { disabled: false, id: "1", named: "Blue", img: Img },
                { disabled: false, id: "2", named: "8GB", img: Img },
                { disabled: false, id: "3", named: "16GB", img: Img },
                { disabled: false, id: "4", named: "20", img: Img }
            ]);

            const addCard = () => {         //! добавление нового объекта в начало массива поэтому объект перед 
                setCards(cards => ([        //! деструктурированным массивом 
                { disabled: false, id: (cards.length + 1), named: "____", img: Img }, 
                ...cards
                ]));
                console.log(cards);
            }


        Сделаем вторым методом и создадим ф-ю для изменения статуса, в нее передается просто значение и его же будем использовать
        в качестве value для отображения, будем брать из переменной status. Также чтобы произошло отображение нужно это значение
        отправить на сервер, раскоментируем код выше и подправим его - props.updateStatus(status);

            const deactivateEditMode = () => {
                setEditMode(false);
                props.updateStatus(status);
            }

            const onStatusChange = (e) => {
                setStatus(e.currentTarget.value);
            }

                {editMode &&
                    <div>
                        <input autoFocus={true}  onBlur={deactivateEditMode} 
                        onChange={onStatusChange} value={status} />
                    </div>



    В следующем уроке сделаем этот кусок кода через useState(//! прочитать статью потому что useEffect не совсем аналогия методам
        //! жизненного цикла)
    
            componentDidUpdate(prevProps, prevState) {
                if (prevProps.status !== this.props.status){
                    this.setState({
                        status: this.props.status
                    });
                }
            }




    //todo почитать механизм хуков и про правила
    //! Почитать статью Абрамова про useEffect - в поиске - полное руководство по useEffect


*/}


{/*    ====    85. Hooks:  useEffect    ====

    В ProfileStatus  status показывается из локального state, локальный нужен нам чтобы на каждое изменение значения input при
        вводе нового статус мы не дергали глобальный state(вдруг user вообще передумает его писать и сотрет всё). А в глобальный
        state значение отправляется уже когда user уберет мышку с инпута. 

    Для синхронизации локального и глобального state мы подвязывались к методу жизненого цикла componentDidUpdate(он срабатывает
        каждый раз при изменении props которые приходят в компонент или при изменении локального state ) и в нем делали проверку 
        на равенство props которые пришли и значением status в локальном state, если они не равны то закинуть status из props
        в локальный state.



    Для ф-го компонента используем useEffect для такой синхронизации. 
    //! Это хук который срабатывает при отрисовке компонента(первоначальной отрисовке - монтировании компонента, при изменении 
    //! props или state) при этом он запускает ф-ю внутри себя.

        Такой код будет выполняться при любой перерисовке, даже при вводе в input символа происходит изменение локального state
        и будет запущен useEffect при этом он снова засетает status из props и то что мы напечатали сотреться.

            useEffect( () => {
                setStatus(props.status);
            } );
            

        Если передать пустой массив, то useEffect выполниться только при первоначальной отрисовке, как при componentDidMount

            useEffect( () => {
                setStatus(props.status);
            }, [] );

        //! но так не советуют делать. При этом мы не достигнем цели синхронизации.


        У нас синхронизация зависит от новых props, поэтому можно в массиве указать когда срабатывать useEffect - при получении
        новых props, они будут сравниваться автоматически
        
            useEffect( () => {
                setStatus(props.status);
            }, [props.status] );



    //! ПРАВИЛА ХУКОВ
            
        1) Хуки запрещено писать в условиях (если что то тру то используем хук)
        2) Не использовать в циклах
        3) 



        
    //todo почитать механизм хуков и про правила
    //! Почитать статью Абрамова про useEffect - в поиске - полное руководство по useEffect


*/}


{/*    ====    86. Virtual DOM    ====

    Браузер парсит ХТМЛ теги и на их основе создает DOM(document object model) - это огромное количество объектов с множеством 
        свойств и методов. Далее на основе этих объектов создается визуализация. Это очень ресурсо затратная операция. И когда 
        мы допустим из JS меняем или добавляем какой то тег, то браузер это видит и внося изменения в DOM полностью его
        перестраивает и перерисовывает визуал, при этом страница может мигать, сбиваться скролл, временно ломаться верстка. 

    Реакт для улучшения производительности берет задачу построения DOM на себя, в браузер загружается React и он уже проводит
        создание DOM. Компонент возвращает разметку JSX которая на выходе из реакта превращается в ХТМЛ теги, а они превращаются
        в Virtual DOM - это дом с упрощенными объектами, у них немного свойст и методов. Когда он меняется то браузер не 
        перерисовывает визуал.  Потом на основе этого виртуального ДОМа реакт создает настоящий DOM. Построение виртуал ДОМа 
        намного менее затратно по сравнению с настоящим. 

    При очередной перерисовке компонента, когда он возвращает реакту JSX(это теги HTML в JS которые в обычный ХТМЛ преобразует
        Babel) и на основании этого нового JSX создается новый виртуал ДОМ. Потом новый и старый виртуал ДОМ сравниваются
        быстрымы алгоритмами(происходит Reconciliation), находит отличия и вносит эти отличия в старый виртуал ДОМ не
        перерисовывая его полностью. И потом эти изменения точечно вносяться в обычный ДОМ не перерисовывая его полностью.

    JSX это джаваскрипт код который транспилятором Babel превращается в HTML теги. В обычном JS чтобы добавить элемент на 
        страницу его нужно создать document.elementCreate, потом задать например внутренний текст innerHTML, потом добавить
        его на страницу предварительно найдя тот элемент к которому добавляем, методом document.appendChild - добавиться 
        в конец страницы. В реакте происходит создание и добавление через React.createElement, создается 1 элемент на
        компонент и в нем уже создаются другие, поэтому и есть требование чтобы в компоненте был 1 корневой елемент и
        импортировать React в компонент  чтобы вызывать метод React.createElement. Также Babel может превращать новый 
        JS(ES6+ с новыми возможностями) в старый который поддерживается старыми браузерами.


    Компоненты возвращают много JSX кода, и когда он превращается в виртуал ДОМ и может так быть что его и не нужно 
        перерисовывать. Тоесть в комопненте сработал render, вернулся JSX, построился новый виртуал ДОМ сравнился с предыдущим
        и реакт понял что они одинаковые, и обычный DOM не перерисовался.

    Таким образом происходит оптимизация и нету лишнего рендера DOM. Но в больших проектах создание нового VDOM и сравнение с
        предыдущим все равно оказывается ресурсозатратной операцией которой нужно избегать, таким образом что не берется
        JSX из того компонента который сейчас не нужен.

    В следующем уроке рассмотрим возможность не генерировать лишний раз VirtualDOM.


*/}


{/*    ====    87. shouldComponentUpdate, PureComponent, memo    ====

    Бывают ситуации когда для компонента ничего не изменилось а ему все равно приходиться делать ререндер и возвращать 
        одинаковый JSX. Например в Profile -  

            <ProfileInfo profile={props.profile} status={props.status} updateStatus={props.updateStatus}/>
            <MyPostsContainer />

        MyPostsContainer отрисовывает MyPosts каждый раз когда обновляется Profile, а он обновляется 3 раза когда 
        происходит изменение какого то из props profile, status,authorizedUserId

            let mapStateToProps = (state) => ({
                profile: state.profilePage.userProfile,
                status: state.profilePage.status,
                authorizedUserId: state.auth.userId,
                isAuth: state.auth.isAuth
            });

        При этом для MyPosts ничего не меняется и он возвращает один и тот же JSX. Для того чтобы оптимизировать приложение
        и избавиться от таких лишних рендеров можно ф-й компонент превратить в классовый и использовать методы жизненного 
        цикла shouldComponentUpdate. Прежде чем вызвать рендер реакт спросит - нужно ли тебя обновить компонент? 

        Произойдет первичный рендер компонента, и в shouldComponentUpdate мы можем ответить что если следующие props не равны
        предыдущим то вернем true и произовйдет ререндер, а если будет false то его не произойдет. Также в это условие включаем и
        проверку state на равенство.

            import { Component } from "react";

            shouldComponentUpdate( nextProps, nextState) {
                return nextProps != this.props || nextState != this.state;
            }



    PureComponent - это компонент который делает такую проверку за нас, для этого нужно сделать extend от PureComponent.

            import { PureComponent } from "react";

            class MyPosts extends PureComponent {

        Таким образом shouldComponentUpdate можно не писать, он уже написан в PureComponent реакта.



    Но мы же стремимся перейти на ф-е компоненты, и в -фх компонентах такого поведения можно достичь если обернуть компонент
        HOCом - memo. Таким образом ф-я выполняется 1 раз и при следующемзапросе если ничего не изменилось то ее не запускают
        заново, а возвращается старое значение(jsx).
        
            const MyPosts = React.memo( props => {   
                                  
                let postsElements = 
                    props.postsData.map((el, ind) => <Post  msg={el.post} likesCount={el.likesCount} key={ind} />);

                return (
                <div className={style.form__newPost}>
                    <div className={style.newPost__title}>New Post
                    <AddNewPostForm onSubmit={onAddPost}/>
                    </div>
                    {postsElements}
                </div>
                );
            });

        //! React.memo это HOC для мемоизации ф-ного компонента - предотвращает ререндер если не изменяются props( state ?). 
        //! useMemo это хук для мемоизации ф-и(без компонента) - используем для получения значения которое было высчитано
        //! разово, без перевычисления, если только не изменилась одна из его зависимостей, тогда значение будет перевычеслено.


*/}


{/*    ====    88. pure function (чистая функция)    ====







*/}


{/*    ====    89. Тесты, jest, tdd, тестируем reducer    ====







*/}